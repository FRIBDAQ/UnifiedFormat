<?xml version="1.0" encoding="UTF-8"?>


<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN"
                      "file:///usr/share/xml/docbook/schema/dtd/4.5/docbookx.dtd
"
>
<book>
    <bookinfo>
      <title>NSCLDAQ Unified Format Library</title>
      <author><firstname>Ron</firstname><surname>Fox</surname></author>
      <revhistory>
          <revision>
             <revnumber>1.0</revnumber>
             <date>June 6, 2022</date>
             <authorinitials>RF</authorinitials>
             <revremark>Original Release</revremark>
          </revision>
      </revhistory>
    </bookinfo>
    <chapter>
       <title>Introduction</title>
       <section>
        <title>Motivation</title>
        <para>
         Data in the NSCLDAQ system are distributed online through ring buffers.
         While a ring buffer, at its lowest level, is just a stream of bytes
         produced by a producer and consumed by zero or more consumers,
         in practice, a structure is layered on top of this byte stream.
        </para>
        <para>
         Items are placed by producers as Ring Items.  A Ring Item consists of
         a header and a payload.  The header contains the complete size of the item
         and an item type.  As NSCLDAQ has evolved, so too have the formats
         of the payloads for various item types.  This makes writing programs
         that can process data from all versions of NSCLDAQ difficult to
         write correctly.
        </para>
        <para>
         This document describes a set of libraries which should ease this burden,
         and allow you to very simply write programs that can operate on data
         from any of the NSCLDAQ data formats.
        </para>
       </section>

       <section>
        <title>Document Organization</title>
        <para>
            The remainder of this document is organized as follows:
        </para>
        <itemizedlist>
            <listitem>
               <para>
                   The remainder of this chapter,
                   describes what you need to do to incorporate this library
                   into your program (compilation and link directives).
               </para>
            </listitem>
            <listitem>
               <para>
                  <link linkend='ch.organization' endterm='ch.organization.title' />
                  Describes the organization of the library.
               </para>
            </listitem>
            <listitem>
               <para>
                  <link linkend='ch.factories' endterm='ch.factories.title' />
                  Describes the abstract factory design pattern and how it's applied
                  to this library.
               </para>
            </listitem>
            <listitem>
               <para>
                  <link linkend='ch.reference' endterm='ch.reference.title' />
                  Provides detailed reference pages.
               </para>
            </listitem>
        </itemizedlist>
        <section>
            <title>Incorporating this library into your programs</title>
            <para>
                As with most Linux library installations, there are
                <filename>include</filename> and <filename>lib</filename> directories
                under the installation directory.  If <literal>$INSTALL_ROOT</literal>
                is the top level installation directory, at compilation time you'll
                need to add
            </para>
            <informalexample>
                <programlisting>
-I$INSTALL_ROOT/include
                </programlisting>
            </informalexample>
            <para>
                to your compilation flags so that header files can be located
                by the compiler's preprocessor.  Note that there are several
                subdirectories below this top level header directory, however
                you <emphasis>should not</emphasis> add those to the header
                file search path.
            </para>
            <para>
                The software consists of several libraries.  These must
                be added to the link and, since the libraries are shared,
                an rpath directive must be added so that the run time
                loader can locate those libraries when programs using them
                start.  
            </para>
            <para>
                This means adding the following flags to the link command:
            </para>
            <informalexample>
                <programlisting>
-L$INSTALL_ROOT/lib -lNSCLDAQFormat \
    -lV10Format -lV11Format -lV12Format -lAbstractFormat \
    -Wl,-rpath=$INSTALL_ROOT/lib
                </programlisting>
            </informalexample>
        </section>
       </section>
    </chapter>
    <chapter id='ch.organization'>
       <title id='ch.organization.title'>Library Organization</title>
       <para>
        This chapter describes the organization of the libraries.  
       </para>
       <para>
        The first question a user might reasonbly ask is how a library can hide
        the format differences between the versions of NSCLDAQ from a program.
        This can be done mostly by understanding that each version layers on additional
        fields and capabilities on the base of fields and capabilities supplied by
        the prior version.  For example V11 adds the ability to have a body header
        used in event building to the V10 format.  V12, makes a slight change to
        the value that indicates there is no body header and provides the ability to
        track the original source id of objects whose body headers are otherwise
        overwritten during event building.
       </para>
       <para>
        The format libary:
       </para>
       <orderedlist>
        <listitem>
           <para>
              Provides a set of classes that is derived from a base class that
              completely hides the actual layout of each item, only providing
              constructors and accessors to retrieve/set fields in the underlying
              data of each object.
           </para>
           <para>
            Where capabilities dont' yet exist, the library either hands off
            reasonable defaults or throws exceptions.
           </para>
        </listitem>
        <listitem>
           <para>
              Provides a set of object factories, one for each supported
              NSCLDAQ version to generate objects either from parameterization,
              undifferentiated items or from sources of data (e.g. ringbuffers,
              file descriptors or c++ streams).  The factories also provide support
              for serializing objects to these entities.
           </para>
        </listitem>
        <listitem>
           <para>
              Given information about the version of NSCLDAQ used (either an
              explicit version number or a data format item, the library can
              provide an instance of the appropriate factory.
           </para>
        </listitem>
       </orderedlist>
       <para>
        In this way a program is not looking at the actual data but simply getting or
        setting properties of the data based on an interface that can accomodate
        the maximal capabilities of a ring item over all versions.
       </para>
       <para>
        The next sections describe and give examples of
       </para>
       <itemizedlist>
        <listitem>
           <para>
              <link linkend='sec.ringitems' endterm='sec.ringitems.title' />
              The ring item classes which encapsulate the data from each ring item
              type.
           </para>
        </listitem>
        <listitem>
           <para>
              <link linkend='sec.factories' endterm='sec.factories.title' />
              The factory classes see, however
              <link linkend='ch.factories' endterm='ch.factories.title' /> for more.
              
           </para>
        </listitem>
       </itemizedlist>
       <section id='sec.ringitems'>
        <title id='sec.ringitems.title'>Ring Item classes.</title>
        <para>
         Ring item contents are hidden from users behind a family of classes.
         A set of base classes, abstract ring items define a interfaces for each
         type of ring item. For each supported version of NSCLDAQ a set of subclasses
         exists that actually provide those interfaces for that specific data format.
         In the next section we'll see how we can then use the factory classes
         and factory selector to produce items without knowing the detailed format
         of those items.
        </para>
        <para>
            The headers for the abstract ring items types are located in
            the <filename>include</filename> subdirectory of the library's
            installation directory root.  Subdirectories named
            <literal>v</literal><emphasis>nn</emphasis> where <emphasis>nn</emphasis>
            is the NSCLDAQ version number host the headers for specific NSCLDAQ
            versions.  For example  <filename>include/v11</filename> holds
            the headers for version 11.  
        </para>
        <para>
            Since each of the version dependent headers will reference the
            abstract headers, it's important to only add the top level include
            directory to the header search path.  Here's a code fragment
            that shows how to create and fill in a physics data item
            with event builder information for version 11 (note that in
            practice you'll do this using a ring item factory as described
            in the next section).
        </para>
        <example>
            <title>Generating a Physics item for NSCLDAQ-11</title>
            <programlisting>
#include &lt;v11/CPhysicsEventItem.h&gt;     <co id='v11phys.header' />
...
v11::CPhysicsEventItem item;                      <co id='v11phys.create' />
item.setBodyHeader(someTimestamp, someSourceId); <co id='v11phys.setbodyheader' />
uint16_t* pBody = reinterpret_cast&lt;uint16_t*&gt;(item.getBodyCursor); <co id='v11phys.getcursor' />
...
item.setBodyCursor(pBody);                   <co id='v11phys.updatecursor' />
item.updateSize();                           <co id='v11phys.setsize' />
...

            </programlisting>
        </example>
        <calloutlist>
            <callout arearefs='v11phys.header' >
                <para>
                    Note how we explicitly pull in the header from the v11
                    subdirectory of the header directory tree for the library.
                    This header will, in turn, refer to the header in the
                    top level directory, which supplies the base interface.
                </para>
            </callout>
            <callout arearefs='v11phys.create' >
                <para>
                    After some code that's not relevant, a V11 Physics item is
                    created.  Note that each subclass family lives in a namespace
                    that indicates its version.  The parameter-less constructor
                    just reservers a default amount of storage (about 8192 bytes),
                    and reserves the ring item header filling in the type field
                    with <literal>v11::PHYSICS_EVENT</literal>.  An optional parameter
                    can be used to reserve additional storage if needed.
                </para>
                <para>
                    We'll still need to fill in the header's size field as we'll
                    see later on.
                </para>
            </callout>
            <callout arearefs='v11phys.setbodyheader' >
                <para>
                    Event builder data is in the item's body header which contains
                    a timestamp, sourceid and barrier type.  The
                    <methodname>setBodyHeader</methodname> sets the body header
                    of the item, if necessary sliding down any existing body data
                    to accomodate it.  The barrier type argumetn of
                    <methodname>setBodyHeader</methodname> defaults to
                    <literal>0</literal> which implies the event is not an
                    event builder barrier.
                </para>
            </callout>
            <callout arearefs='v11phys.getcursor' >
                <para>
                    Ring items have a <firstterm>body cursor</firstterm>. This is
                    the location at which additional body data can be stored. The
                    <methodname>getBodyCursor</methodname> method retrieves a
                    <type>void*</type> pointer to this storage in a format
                    independent manner.  This provides us a pointer which we
                    can use to fill in the data from the physics trigger.
                </para>
                <para>
                    Note that the code in the section marked <literal>...</literal>
                    below is assumed to fill in the physics data and advance
                    the <varname>pBody</varname> pointer to point past the
                    body data we put in.
                </para>
            </callout>
            <callout arearefs='v11phys.updatecursor' >
                <para>
                    Sets the item's body cursor this does two things:
                    First it allows several distinct sections of code to fill
                    in the body of an item without knowing what other sections
                    of code did.  Each section just asks for the current body
                    cursor, fills in its chunk of data and updates the body cursor
                    for the next chunk.  More importantly, however, the body
                    cursor tells the item's encapsulating object the extent of the
                    object's storage.
                </para>
            </callout>
            <callout arearefs='v11phys.setsize' >
                <para>
                    Uses the objects current body cursor to compute the size
                    of the object and stores that in the item's header.
                    The physics item is now completely filled in.  Later sections
                    will describe what we do with that item.
                </para>
            </callout>
        </calloutlist>
       </section>
        <section id='sec.factories' >
            <title id='sec.factories.title'>Factories.</title>
            <para>
                Factories are classes that create instances of other classes.
                Abstract factories are a family (inheritance hierarchy) of factory
                classes, where each factory instance createst instances of classes
                from parallel class hierarchies.  
            </para>
            <para>
                I Know the previous paragraph might sound a bit confusing.  Let's
                describe this in the concrete terms of how factories and the
                abstract factory pattern fit into this library:
            </para>
            <itemizedlist>
                <listitem>
                   <para>
                      We have a base class factory with an interface that describes
                      various ways to create different types of ring items.
                   </para>
                </listitem>
                <listitem>
                   <para>
                      For each supported version of NSCLDAQ we have a factory
                      which knows how to instantiate objects from the class
                      hierarchy that implement its own ring item data formats.
                   </para>
                </listitem>
                <listitem>
                   <para>
                      Finally, and this is slightly different from the classic
                      abstract factory pattern, we have a factory factory which,
                      given information about the version of NSCLDAQ being used
                      (either an explicit version number or, in the case of
                      versions 11 and higher a data format item), can give us an
                      instance of the correct factory to use for that version of NSCLDAQ.
                      <footnote>
                        <para>
                            Our use of the abstract factory pattern differs from the
                            classic presentation in that in the classic presentation,
                            there's a factory that makes use of specific factories for
                            the desired concrete set of objects.
                        </para>
                        <para>
                            For more on the abstract factory pattern as it is normally used,
                            see e.g.
                            <ulink url='https://en.wikipedia.org/wiki/Abstract_factory_pattern'>
                                this Wikipedia article.
                            </ulink>
                        </para>
                    </footnote>
                   </para>
                   <para>
                    Since all factories provide the same interface as the factory
                    base class, once we've selected the factory we're going to use,
                    we don't need to know anything about the NSCLDAQ version.
                    The same interface will be used for all versions to produce
                    ring item objects which support the same interface across
                    all versions.
                   </para>
                </listitem>
            </itemizedlist>
            <para>
                Before continuing with the next chapter, which describes abstract
                factories in detail, let's look at a simple example of using
                a concrete factory to build a physics
                item, as we did in the previous section:
            </para>
            <example>
                <title>Using Factories to Make a Physics Item for NSCLDAQ-11</title>
                <programlisting>
#include &lt;v11/RingItemFactory.h&gt;    <co id='v11fact.include' />
#include &lt;CPhysicsEventItem.h&gt;      <co id='v11fact.physics' />
#include &lt;memory&gt;                   <co id='v11fact.memory' />
...

v11::RingItemFactory fact;               <co id='v11fact.instance' />
std::unique_ptr&lt;::CPhysicsEventItem&gt; pItem(fact.makePhysicsEventItem()); <co id='v11fact.make' />

pItem-&gt;setBodyHeader(someTimestamp, someSourceId); 
uint16_t* pBody = reinterpret_cast&lt;uint16_t*&gt;(pItem-&gt;getBodyCursor); 
...
pItem-&gt;setBodyCursor(pBody);                   
pItem-&gt;updateSize();                          
...
            </programlisting>
            </example>
            <calloutlist>
                <callout arearefs='v11fact.include' >
                    <para>
                        In this example, we will, directly create a V11
                        ring item factory.  Therefore we need the header
                        for that class.  In the next chapter we'll seee how to
                        select an appropriate ring item factory if we only know the
                        correct version at run-time.
                    </para>
                </callout>
                <callout arearefs='v11fact.physics' >
                    <para>
                        Note that we include the header for the abstract
                        <classname>CPhysicsEventItem</classname>.  This is what
                        factories create.  This is the base class for the version specific
                        classes such as <classname>v11::CPhysicsEventItem</classname>.
                    </para>
                    <para>
                        We choose this class so that, once we've instantiated the
                        physics item using the appropriate factory, we no longer need
                        to know the version of NSCLDAQ we're operating with.
                    </para>
                </callout>
                <callout arearefs='v11fact.memory' >
                    <para>
                        This header, part of the C++ standard library, supplies, among other
                        things, smart pointer classes which can help avoid memory leaks.
                        Our factory classes produce dynamically allocated items.
                        Using e.g. <classname>std::unique_ptr</classname> can ensure
                        these objects are deleted.
                    </para>
                </callout>
                <callout arearefs='v11fact.instance' >
                    <para>
                        This line of code creates an instance of the
                        object factory for NSCLDAQ-11.  Since we use virtual
                        methods to support a polymorphic base class/subclass
                        class hierarchy, we need to have an object as virtual methods
                        cannot be static.
                    </para>
                </callout>
                <callout arearefs='v11fact.make' >
                    <para>
                        This line is a bit involved.  Let's look at it from the
                        inside out.  We ask the <varname>fact</varname>
                        object to create a new physics event item.  Since it is
                        an instance of a <classname>v11::RingItemFactory</classname>,
                        what well get is a pointer to a <classname>v11::CPhysicsEventItem</classname>
                        object returned as a pointer to its base class
                        <classname>::CPhysicsEventItem</classname>.
                    </para>
                    <para>
                        We use this to initialize a
                        <classname>std::unique_ptr&lt;::CPhysicsEventItem&gt;</classname>
                        object named <varname>pItem</varname>.  Once the unique
                        pointer is created it can be used exactly as if it were
                        a <classname>::CPhysicsEventItem*</classname>.  When we call methods
                        using this pointer like object, due to polymorphism the
                        NSCLDAQ-11 version of those methods will get called.
                    </para>
                    <para>
                        Once <varname>pItem</varname> goes out of scope, the item
                        it 'points to' will be deleted.  This includes going out
                        of scope due to an unhandled exception.
                    </para>
                    <para>
                        Once <varname>pItem</varname> is created it can be used
                        to fill in the body header and body of the item just as
                        we did in the example in the previous section.  The result,
                        since we used the V11 factory is a V11 Physics event item.
                    </para>
                    <para>
                        Note that the code which fills in the item, which may be
                        very far  from the code which selects the factory, does not
                        need to know that we are making items for NSCLDAQ-11.
                    </para>
                    <para>
                        You might wonder about the call to set the body header.  What
                        would happen if we'd chosen the <classname>v10::RingItemFactory</classname>
                        for our factory?  NSCLDAQ-10 items don't have body headers.
                        The implementation of <methodname>setBodyHeader</methodname>
                        for NSCLDAQ-10 item types is just a no-op which means that you
                        would wind up with a perfectly good NSCLDAQ-10 ring item.
                    </para>
                </callout>
            </calloutlist>
        </section>
    </chapter>
    <chapter id='ch.factories'>
       <title id='ch.factories.title'>Factories and the Abstract Factory Pattern</title>
       <para>
        In the last section of the previous chapter, we touched on the role factories
        play in the formatting library.  We'll look a bit deeper at the subject of
        abstract factories, factories and and important set of functions
        that allow you to select an appropriate factory at run time.
       </para>
       <para>
        We've seen that in the format library:
       </para>
       <itemizedlist>
        <listitem>
           <para>
              There is a factory base class that establishes the interfaces
              that version specific factories must implement.  This is an
              abstract base class called <classname>RingItemFactoryBase</classname>.
           </para>
        </listitem>
        <listitem>
           <para>
              Each supported format version has a concrete instance of this
              factory.  Normally these are called
              <classname>v<replaceable>nn</replaceable>::RingItemFactory</classname>
              where <replaceable>nn</replaceable> is the NSCLDAQ version for which
              that factory creates items (e.g. <classname>v11::RingItemFactory</classname>
              makes ring items for NSCLDAQ-11).
           </para>
           <para>
            Each factory implements the base class interface. This means that
            once you have a pointer or reference to a factory in your possession, you
            can treat it as a generic <classname>RingItemFactoryBase</classname>
            object and polymorphism will take care of the rest without your
            code needing to be aware of the actual factory you are using.
           </para>
        </listitem>
       </itemizedlist>
       <para>
        In addition to these concepts, the format factory implements a set of
        functions that can be used to get a reference to an
        <emphasis>appropriate</emphasis> factory object.  This can be done either
        by passing a version designator or  passing a <classname>::CDataFormat</classname>
        object by reference.  In NSCLDAQ-11 and later, these objects contain
        information about the version of NSCLDAQ that produced them.  In an event
        file or stream of online events, these indicate the format of the data
        to follow.
       </para>
       <para>
        In the next example, we'll produce the same physics event item we've been
        producing in our earlier examples but we'll select the factory at runtime
        using a version designator.  In the example, the version designator is
        hard coded but could be computationally determined (e.g. passed into the
        program form the command line)
       </para>
       <example>
        <title>Using a Version Designator to Construct a Ring Item Factory:</title>
        <programlisting>
#include &lt;NSCLDAQFormatFactorySelector.h&gt;
#include &lt;RingItemFactoryBase.h&gt;    <co id='select.headers' />
#include &lt;CPhysicsEventItem.h&gt;
#include &lt;memory&gt;
..

::RingItemFactoryBase&amp; fact(FormatSelector::selectFactory(FormatSelector::v11)); <co id='select.select' />
std::unique_ptr&lt;::CPhysicsEventItem&gt; pItem(fact.makePhysicsEventItem());  <co id='select.makeitem' />
                                                                  <co id='select.fillbody' />
pItem-&gt;setBodyHeader(someTimestamp, someSourceId); 
uint16_t* pBody = reinterpret_cast&lt;uint16_t*&gt;(pItem-&gt;getBodyCursor); 
...
pItem-&gt;setBodyCursor(pBody);                   
pItem-&gt;updateSize();                          
...

        </programlisting>
       </example>
       <calloutlist>
        <callout arearefs='select.headers' >
            <para>
                Includes the headers we need. Note that none of them are
                version specific.  This is the value aded by using the
                factory selector defined in
                <filename>NSCLDAQFormatFactorySelector.h</filename>.
                <filename>RingItemFactoryBase.h</filename> defines the abstract
                base class that establishes the factory API.
            </para>
        </callout>
        <callout arearefs='select.select' >
            <para>
                This call has a lot to unwrap.  Again let's start from the
                inside and work our way out.  <methodname>FormatSelector::selectFactory</methodname>
                is a family of functions that return references to factory objects.
                This version is parameterized by an explicit version designator
                <literal>FormatSelector::v11</literal> (version 11).
            </para>
            <para>
                The selection functions maintain a memory of the factories they've
                produced.  If, in a later section of code you ask for a factory
                for the same version; you'll get a reference to the same factory
                object.  This implies that the selection subsystem maintains ownership
                of the factories it produces and your code must not delete factories
                it receives.
            </para>
            <para>
                The resulting reference is used to initialize a reference to a
                <classname>::RingItemFactoryBase</classname> object.  Using a reference
                maintains the association between virtual functions and the
                implementations provided by the factory returned from
                <methodname>FormatSelector::selectFactory</methodname>.
                This calling methods on this reference will, actually, call methods on the
                <classname>v11::RingItemFactory</classname> that
                <methodname>FormatSelector::selectFactory</methodname> returned.
            </para>
        </callout>
        <callout arearefs='select.makeitem' >
            <para>
                As before, we use the factory to make a physics event item.
                The  pointer to the resulting dynamically allocated item
                initializes a <classname>std::unique_ptr</classname> so that
                the delete of that object is automatic when th smart pointer like
                object goes out of scope.
            </para>
        </callout>
        <callout arearefs='select.fillbody' >
            <para>
                The remainder of the code in this example is identical
                to the code used to fill in the physics item bodies of the
                previous examples in this document.
            </para>
        </callout>
       </calloutlist>
       <para>
        The key point in this is that the only point in time where
        we used knowledge of the DAQ version is when we called
        <methodname>FormatSelector::selectFactory</methodname>
        passing in the version format selector.
       </para>
       <para>
        Beginning with NSCLDAQ-11, prior to the begining of each run and,
        at the beginning of each event file a data format item is written which
        indicates the format of the data that follows.  There is a format selector
        item that can be passed a reference to an encapsulated data format item
        to provide the correct format factory for that format item.
       </para>
       <para>
        This does provide a bit of a chicken and egg problem...given a raw ring item,
        how do you get a data format item.  In the code that follows, we'll start
        with an undifferentiated <classname>::CRingItem</classname> and try to
        see if it represents a ring format item.  We'll then use the fact that
        we're guaranteed that ring format items look the same in all
        versions of NSCLDAQ that support them.
       </para>
       <example>
        <title>Using ring format items to select a format factory</title>
        <programlisting>
#include &lt;NSCLDAQFormatFactorySelector.h&gt;
#include &lt;RingItemFactoryBase.h&gt; 
#include &lt;CRingItem.h&gt;
#include &lt;CRingFormatItem.h&gt;    <co id='fmt.formatitem' />
#include &lt;memory&gt;
#include &lt;DataFormat.h&gt;         <co id='fmt.dataformat' />

static enum FormatSelector::SupportedVersions defaultVersion(FormatSelector::v10); <co id='fmt.defaultfmt' />
...
:RingItemFactoryBase* pFactory(0);

std::unique_ptr&lt;::CRingItem&gt; item(getRingItem());  <co id='fmt.getitem' />
if (item-&gt;type() == RING_FORMAT) {                    <co id='fmt.isformat' />
    ::CRingFormatItem* pFormatItem =
        reinterpret_cast&lt;::CRingFormatItem*&gt;(item.get()); <co id='fmt.cast' />
    pFactory = &amp;(FormatSelector::selectFactory(*pFormatItem)); <co id='fmt.selectfromitem' />
} else {
    pFactory = &amp;(FormatSelector::selectFactory(defaultVersion)); <co id='fmt.selectdefault' />
}

::RingItemFactoryBase&amp; fact(*pFactory);               <co id='fmt.makereference' />

...

        </programlisting>
       </example>
       <para>
        There's a lot to unpack in this fragment of code and some of it is a bit
        sneaky.  Therefore let's look at this code very carefully.
       </para>
       <calloutlist>
        <callout arearefs='fmt.formatitem' >
          <para>
            We'll need to use the definitions of the
            <classname>CRingFormatItem</classname> so we include it's header here.
          </para>
        </callout>
        <callout arearefs='fmt.dataformat' >
            <para>
                The <filename>DataFormat.h</filename> file provides
                format definitions for each of the supported data formats.
                In this case, we pull in the data format from the abstract
                directory.  The main thing we want here is the ring item type
                definitions which, for the most part, are stable across versions.
            </para>
        </callout>
        <callout arearefs='fmt.defaultfmt' >
            <para>
                We store the default format type in a variable.  You might imagine
                that processing in the omitted code could modify this.   Version
                10 is a reasonable default because there isn't a data format item
                for that version.
            </para>
        </callout>
        <callout arearefs='fmt.getitem' >
            <para>
                This line just uses some function we dreamed out
                <function>getRingItem</function> to return a pointer
                to a dynamically allocated ring item gotten somehow.
                We initialize a unique_ptr as usual to ensure destruction.
            </para>
        </callout>
        <callout arearefs='fmt.isformat' >
            <para>
                Asks the item we got for its item type.  The type is checked
                against <literal>RING_FORMAT</literal> which is defined in
                <filename>DataFormat.h</filename>.  This is the type value
                for items that contain ring item formatting information.
            </para>
        </callout>
        <callout arearefs='fmt.cast' >
            <para>
                This line is a bit tricky.  It uses the fact that the specific
                ring item classes just wrap data containing the raw ring item.
                It further uses the fact that the format of a data format item
                is fixed over all versions that support it.  The result is therefore
                a pointer to the same wrapped object but treated as a
                data format item that knows how to interrrogate the underlying
                data to extract the format.
            </para>
        </callout>
        <callout arearefs='fmt.selectfromitem' >
            <para>
                This version of <methodname>FormatSelector::selectFactory</methodname>
                uses a reference to the format item to obtain and pass back
                a reference to the factory implied by the data format item.
                There's a bit of trickiness here as well.  We're passed back
                a reference and that's, in the end, what we want, but references
                can only be initialized.  They can't be assigned.
                Therefore, we accept the factory as a pointer and store it away
                in a pointer with a scope outside the if bodies.
            </para>
        </callout>
        <callout arearefs='fmt.selectdefault' >
            <para>
                If the item was not a format item we just create the factory
                corresponding to the default format type.
            </para>
        </callout>
        <callout arearefs='fmt.makereference' >
            <para>
                When we get to this point in the program, the factory pointer has
                a non null value.  We initialize the reference <varname>fact</varname>
                to refer to what our factory pointer points to.   Once all this is done
                we can continue processing data.
            </para>
        </callout>
       </calloutlist>
       <para>
        The key take away from this example is that we can produce an appropriate
        object factory without actually knowing the version of NSCLDAQ that
        produced the data we're processing; if the streamof data we're processing
        has a format item (comes from NSCLDAQ-11 or later).
       </para>
    </chapter>
    <chapter id='ch.reference'>
       <title id='ch.reference.title'>Reference pages</title>
       <para>
        The reference pages here take into consideration both the organization
        of the library and the order in which classes are likely to be used
        in a program.  Thus we start with a section that has reference material
        for the factory selector functions the abstract factory and the the abstract
        format classes that determine the functionality all other format classes
        have.
       </para>
       <para>
        Subsequent sections provide reference material for the version 10, version 11
        and version 12 factories and format classes.
       </para>
       <section>
        <title>Abstract Formatting</title>
        <refentry>
           <refmeta>
              <refentrytitle>Format Selector</refentrytitle>
              <manvolnum>3format</manvolnum>
           </refmeta>
           <refnamediv>
              <refname>Format Selector</refname>
              <refpurpose>Select Specific Format Factory</refpurpose>
            </refnamediv>
            <refsynopsisdiv>
                <programlisting>
#include &lt;NSCLDAQFactorySelector.h&gt;

namespace FormatSelector {
    enum SupportedVersions {v10, v11, v12};

    RingItemFactoryBase&amp; selectFactory(SupportedVersions version);
    RingItemFactoryBase&amp; selectFactory(CDataFormatItem&amp; item);


}


                </programlisting>
            </refsynopsisdiv>
            <refsect1>
                     <title>DESCRIPTION</title>
                  <para>
                    The definitions in the <literal>FormatSelector</literal>
                    namespace provide mechnisms to select  specific format factory
                    either from an explicit format specifier or from a data format item.
                    Note that data format items appear in NSCLDAQ-11 and later.
                  </para>
                  <para>
                    The format factories instantiated by these functions are cached
                    for later lookup.  This implies that:
                  </para>
                  <orderedlist>
                    <listitem>
                       <para>
                          Ownership of the factories continues to reside with this
                          module.  Deleting a factory returned from this API
                          will result in undefined, possibly fatal, behavior.
                       </para>
                    </listitem>
                    <listitem>
                       <para>
                          Several attempts to get a factory reference for the same
                          format version will return references to the same factory
                          instance.
                       </para>
                    </listitem>
                  </orderedlist>
            </refsect1>
            <refsect1>
                <title>DATA TYPES</title>
                <para>
                    The <type>FormatSelector::SupportedVersions</type> enum
                    is a type that is used as an NSCLDAQ version selector.
                </para>
            </refsect1>
            <refsect1>
                <title>API</title>
                <para>
                    Note that while all functions live in the
                    <literal>FormatSelector</literal> namespace
                    this is not shown in the function list below for the sake
                    of brevity.
                </para>
                <variablelist>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>::RingItemFactoryBase&amp;</type>
                           <methodname>selectFactory</methodname>
                           <methodparam>
                               <type>SupportedVersions</type><parameter>version</parameter>
                           </methodparam>
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Returns a reference to a ring item factory that is
                            suitable for creatig ring items for the NSCLDAQ
                            version selected by <parameter>version</parameter>.
                            The factory continues to be owned by the selection
                            subsystem and must <emphasis>not</emphasis> be deleted
                            by the caller.
                           </para>
                           <para>
                            A cache of factories ensures that several attempts
                            to obtain a factory for the same version will return
                            references to the same factory.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>::RingItemFactoryBase&amp; </type>
                           <methodname>selectFactory</methodname>
                           <methodparam>
                               <type>CDataFormatItem&amp;</type><parameter> item</parameter>
                           </methodparam>
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Given a reference to a data format item from any
                            version of NSCLDAQ that can produce these, provides
                            a factory for the version of NSCLDAQ indicated by that
                            item.  This wraps the prior overload for
                            <methodname>selectFactory</methodname> so everything
                            described above about the returned reference holds for
                            this one.
                           </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
                <para>
                    If a version is selected which is somehow not supported,
                    <classname>std::invalid_argument</classname> is thrown by
                    the <methodname>selectFactoryMethods</methodname> above.
                </para>
            </refsect1>
            
        </refentry>
        <refentry>
           <refmeta>
              <refentrytitle>RingItemFactoryBase</refentrytitle>
              <manvolnum>3format</manvolnum>
           </refmeta>
           <refnamediv>
              <refname>RingItemFactoryBase</refname>
              <refpurpose>Provide interface for ring item factoires.</refpurpose>
            </refnamediv>
            <refsynopsisdiv>
                <programlisting>
#include &lt;RingItemFactoryBase.h&gt;

class RingItemFactoryBase {
public:
    virtual CRingItem* makeRingItem(uint16_t type, size_t maxBody) = 0;
    virtual CRingItem* makeRingItem(uint16_t type, uint64_t timestamp, uint32_t sourceId,
            size_t maxBody, uint32_t barrierType = 0 ) = 0;
    virtual CRingItem* makeRingItem(const CRingItem&amp; rhs) = 0;
    virtual CRingItem* makeRingItem(const RingItem* pRawRing) = 0;


    virtual CRingItem* getRingItem(CRingBuffer&amp; ringbuf) = 0;
    virtual CRingItem* getRingItem(int fd) = 0;
    virtual CRingItem* getRingItem(std::istream&amp; in) = 0;

    virtual std::ostream&amp; putRingItem(const CRingItem* pItem, std::ostream&amp; out) = 0;
    virtual void putRingItem(const CRingItem* pItem, int fd) = 0;
    virtual void putRingItem(const CRingItem* pItem, CRingBuffer&amp; ringbuf) = 0;

    virtual CAbnormalEndItem* makeAbnormalEndItem() = 0;
    virtual CAbnormalEndItem* makeAbnormalEndItem(const CRingItem&amp; rhs) = 0;

    virtual CDataFormatItem* makeDataFormatItem() = 0;
    virtual CDataFormatItem* makeDataFormatItem(const CRingItem&amp; rhs) = 0;

    virtual CGlomParameters* makeGlomParameters(
        uint64_t interval, bool isBuilding, uint16_t policy
    )  = 0;
    virtual CGlomParameters* makeGlomParameters(const CRingItem&amp; rhs) = 0;

    virtual CPhysicsEventItem* makePhysicsEventItem(size_t maxBody) = 0;
    virtual CPhysicsEventItem* makePhysicsEventItem(
        uint64_t timestamp, uint32_t source, uint32_t barrier, size_t maxBody
    ) = 0;
    virtual CPhysicsEventItem* makePhysicsEventItem(const CRingItem&amp; rhs) = 0;

    virtual CRingFragmentItem* makeRingFragmentItem(
        uint64_t timestamp, uint32_t source, uint32_t payloadSize,
        const void* payload, uint32_t barrier=0
    ) = 0;
    virtual CRingFragmentItem* makeRingFragmentItem(const CRingItem&amp; rhs) = 0;


    virtual CRingPhysicsEventCountItem* makePhysicsEventCountItem(
        uint64_t count, uint32_t timeoffset, time_t stamp,
    int divisor=1
    ) = 0;
    virtual CRingPhysicsEventCountItem* makePhysicsEventCountItem(const CRingItem&amp; rhs) = 0;

    virtual CRingScalerItem* makeScalerItem(size_t numScalers) = 0;
    virtual CRingScalerItem* makeScalerItem(
        uint32_t startTime,
        uint32_t stopTime,
        time_t   timestamp,
        std::vector&lt;uint32_t&gt; scalers,
        bool                  isIncremental = true,
        uint32_t              sid = 0,
        uint32_t              timeOffsetDivisor = 1
    ) = 0;
    virtual CRingScalerItem* makeScalerItem(const CRingItem&amp; rhs) = 0;

    virtual CRingTextItem* makeTextItem(
        uint16_t type,
                std::vector&lt;std::string&gt; theStrings
    ) = 0;
    virtual CRingTextItem* makeTextItem(
        uint16_t type,
                std::vector&lt;std::string&gt; theStrings,
                uint32_t                 offsetTime,
                time_t                   timestamp, uint32_t divisor=1
    ) = 0;
    virtual CRingTextItem* makeTextItem(const CRingItem&amp; rhs) = 0;

    virtual CUnknownFragment* makeUnknownFragment(
        uint64_t timestamp, uint32_t sourceid, uint32_t barrier,
        uint32_t size, void* pPayload
    ) = 0;
    virtual CUnknownFragment* makeUnknownFragment(const CRingItem&amp; rhs) = 0;

    virtual CRingStateChangeItem* makeStateChangeItem(
        uint32_t itemType, uint32_t runNumber,
        uint32_t timeOffset,
        time_t   timestamp,
        std::string title
    ) = 0;
    virtual CRingStateChangeItem* makeStateChangeItem(const CRingItem&amp; rhs) = 0;

};


                </programlisting>
            </refsynopsisdiv>
            <refsect1>
                     <title>DESCRIPTION</title>
                  <para>
                    The <classname>CRingItemFactoryBase</classname> class provides
                    an abstract base class for the ring item factories implemented
                    by version specific libraries.  Note that specific return classes
                    defined as forward classes in the header and, therefore,
                    you need to <literal>#include</literal> the specific ring item
                    classes you need to actually use.
                  </para>
                  <para>
                    All return values are  pointers to dynamically allocated
                    objects.  These objects are owned by the caller and must be
                    deleted by the caller when no longer needed.  The return pointer
                    types are from the abstract library, however the actual return
                    types from any version specific factory will be objects of
                    the correct version's library.  
                  </para>
                  <para>
                    Since storage management can be difficult, users are encouraged
                    to use these methods to initialize smart pointer objects
                    such as <classname>std::unique_ptr</classname> or
                    <classname>std::shared_ptr</classname> to ensure that these
                    objects are, in fact, properly managed.
                  </para>
            </refsect1>
            <refsect1>
                <title>METHODS</title>
                <para>
                    Note that all public methods are pure virtual and must be
                    implemented by any concrete version specific factory.
                </para>
                <variablelist>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual CRingItem*</type>
                           <methodname> makeRingItem</methodname>
                           <methodparam>
                               <type>uint16_t </type><parameter>type</parameter>
                           </methodparam>
                           <methodparam>
                               <type>size_t </type><parameter>maxBody</parameter>
                           </methodparam>
                            
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Creates an undifferentiated ring item.  The
                            storage should be sufficient to hold
                            <parameter>maxBody</parameter> bytes of data.
                            The ring item header should be initialized such
                            that its type is <parameter>type</parameter>.
                           </para>
                           <para>
                            The precise initialization of the remainder of the
                            ring item's storage is implementation dependent.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual CRingItem* </type>
                           <methodname>makeRingItem</methodname>
                           <methodparam>
                               <type>uint16_t </type><parameter>type</parameter>
                           </methodparam>
                           <methodparam>
                               <type>uint64_t </type><parameter>timestamp</parameter>
                           </methodparam>
                           <methodparam>
                               <type>uint32_t </type><parameter>sourceId</parameter>
                           </methodparam>
                            <methodparam>
                                <type>size_t </type><parameter>maxBody</parameter>
                            </methodparam>
                            <methodparam>
                                <type>uint32_t </type><parameter>barrierType</parameter>
                                <initializer>0</initializer>
                            </methodparam>
                             
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            As before but also provides the body header parameters:
                            <parameter>timestamp</parameter>, which will be used
                            as the event timestamp in any body header,
                            <parameter>sourceId</parameter> which will be used
                             as the item's source id and
                             <parameter>barrierType</parameter> which is an optional
                             parameter that specifies the barrier type.  This defaults
                             to zero as that's the most common
                           </para>
                           <para>
                            The implementation of this method shall be equivalent
                            to:
                           </para>
                           <informalexample>
                            <programlisting>
std::auto_ptr&lt;::CRingItem&gt; pItem(fact.makeRingItem(type, maxbody));
pItem->setBodyHeader(timestamp, sourceId, barrierType);
                            </programlisting>
                           </informalexample>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual CRingItem*</type>
                           <methodname> makeRingItem</methodname>
                           <methodparam>
                               <type>const CRingItem&amp; </type><parameter>rhs</parameter>
                           </methodparam>
                            
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Makes a new ring item that is a copy of the
                            ring item that is referenced by the
                            <parameter>rhs</parameter>.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual CRingItem* </type>
                           <methodname>makeRingItem</methodname>
                           <methodparam>
                               <type>const RingItem* </type><parameter>pRawRing</parameter>
                           </methodparam>
                            
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Copies the contents of <parameter>pRawRing</parameter>
                            into local storage of a new ringitem object.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual CRingItem* </type>
                           <methodname>getRingItem</methodname>
                           <methodparam>
                               <type>CRingBuffer&amp; </type><parameter>ringbuf</parameter>
                           </methodparam>
                            
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Givena reference to an NSCLDAQ
                            <type>CRingBuffer</type> object that is created
                            as a consumer; consumes a raw ring item from that
                            ringbuffer encapsulating it in a
                            <classname>CRingItem</classname>.
                           </para>
                           <para>
                            Note that ringbuffers and ring items are such that
                            the actual NSCLDAQ library version used does not matter much
                            in the execution of this method.  
                           </para>
                           <para>
                            If a complete ring item is not yet available for
                            this consumer <parameter>ringbuf</parameter>,
                            the calling program will block until one is.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual CRingItem* </type>
                           <methodname>getRingItem</methodname>
                           <methodparam>
                               <type>int </type><parameter>fd</parameter>
                           </methodparam>
                            
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Consumes a ring item from the file descriptor
                            <parameter>fd</parameter> and wraps it in a
                            new <classname>CRingItem</classname> object.
                            If the file descriptor is e.g. a pipe and no
                            ring item is available, this will block.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual CRingItem* </type>
                           <methodname>getRingItem</methodname>
                           <methodparam>
                               <type>std::istream&amp; </type><parameter>in</parameter>
                           </methodparam>
                            
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Consumes a raw ring item from the stream
                            <parameter>in</parameter> wraps it up in a new
                            <classname>CRingBuffer</classname> class, returning
                            a pointer to that object.  If <parameter>in</parameter>
                            is e.g. a pipe and no object is available, the program
                            will block until one is seen.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual std::ostream&amp; </type>
                           <methodname>putRingItem</methodname>
                           <methodparam>
                               <type>const CRingItem*</type><parameter> pItem</parameter>
                           </methodparam>
                           <methodparam>
                               <type>std::ostream&amp; </type><parameter>out</parameter>
                           </methodparam>
                            
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Puts the encapsulated ring item
                            pointed to by <parameter>pItem</parameter> to the C++
                            output stream <parameter>out</parameter>.  A reference
                            to the stream after the output is returned.
                           </para>
                           <para>
                            The ring itme is output in raw format.  This allows
                            <methodname>getRingItem</methodname> to reconstruct
                            the ring item.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual void </type>
                           <methodname>putRingItem</methodname>
                           <methodparam>
                               <type>const CRingItem* </type><parameter>pItem</parameter>
                           </methodparam>
                           <methodparam>
                               <type>int </type><parameter>fd</parameter>
                           </methodparam>
                            
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Outputs the ring item pointed to by
                            <parameter>pItem</parameter> to whatever
                            the file descriptor <parameter>fd</parameter>
                            is open on.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual void </type>
                           <methodname>putRingItem</methodname>
                           <methodparam>
                               <type>const CRingItem* </type><parameter>pItem</parameter>
                           </methodparam>
                           <methodparam>
                               <type>CRingBuffer&amp;</type><parameter> ringbuf</parameter>
                           </methodparam>
                            
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Puts the raw ring item encapsulated in
                            <parameter>pItem</parameter> into the ring buffer
                            refrenced by <parameter>ringbuf</parameter>.
                            <parameter>ringbuf</parameter> must have been created
                            
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual CAbnormalEndItem* </type>
                           <methodname>makeAbnormalEndItem()</methodname>
                           <void />
                            
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Creates an abnormal end ring item type.  This is
                            used by versions of NSCLDAQ to flag a run that was not
                            properly ended.  If this item type cannot be
                            created <literal>nullptr</literal> must be returned.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual CAbnormalEndItem* </type>
                           <methodname>makeAbnormalEndItem</methodname>
                           <methodparam>
                               <type>const CRingItem&amp; </type><parameter>rhs</parameter>
                           </methodparam>
                            
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Given an undifferentiated ring item reference,
                            <parameter>rhs</parameter>, creates the equivalent
                            <classname>CAbnormalEndItem</classname>. Note that if
                            this is not possible (e.g. because <parameter>rhs</parameter>
                            is not an abnormal end item or because the version of
                            NSCLDAQ format in the concrete implementation does not
                            yet support <classname>CAbnormalEndItem</classname>s,
                            <classname>std::bad_cast</classname> must be thrown.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual CDataFormatItem* </type>
                           <methodname>makeDataFormatItem</methodname>
                           <void />
                            
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Creates and returns a pointer to a data format
                            item for the format represented by the concrete
                            factory.  If the version represented by the concrete
                            factory does not support data format items,
                            this method must return <literal>nullptr</literal>
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual CDataFormatItem* </type>
                           <methodname>makeDataFormatItem</methodname>
                           <methodparam>
                               <type>const CRingItem&amp;</type><parameter> rhs</parameter>
                           </methodparam>
                            
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Given an undifferentiated ring item;
                            <parameter>rhs</parameter>, an equivalent
                            <classname>CDataFormatItem</classname> object is
                            created and a pointer to it returned.
                            If <parameter>rhs</parameter> is not a data format
                            item, or data format items are not supported by the
                            concreate implementation the implementation must
                            throw <classname>std::bad_cast</classname>.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual CGlomParameters*</type>
                           <methodname> makeGlomParameters</methodname>
                           <methodparam>
                               <type>uint64_t </type><parameter>interval</parameter>
                           </methodparam>
                           <methodparam>
                               <type>bool </type><parameter>isBuilding</parameter>
                           </methodparam>
                           <methodparam>
                               <type>uint16_t </type><parameter>policy</parameter>
                           </methodparam>
                            
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Creates and returns a pointer to a
                            <classname>CGlomParameters</classname> item described
                            by its parameters.  If the underlying format does not
                            support glom parameter items, <literal>nullptr</literal>
                            must be returned.
                           </para>
                           <para>
                            Glom is the component of the event builder that
                            glues events together from a totally time ordered stream
                            of event fragments.  If <parameter>isBuilding</parameter>
                            is true, glom is building events and not running in the
                            test mode in which it just emits fragments without
                            bothering to build them.  When building, fragments
                            are built if they all fit in the timestamp window
                            defined by <parameter>interval</parameter>.  The units
                            of this are dependent on the application and simply
                            represent timestamp ticks.  
                           </para>
                           <para>
                            <parameter>policy</parameter>
                            is an integer that describes how output event timestamps
                            are created from the fragment timestamps in an event.
                            Constants in <filename>DataFormat.h</filename> describe
                             the legal values for this parameter which are:
                           </para>
                           <itemizedlist>
                            <listitem>
                               <para>
                                  <emphasis>GLOM_TIMESTAMP_FIRST</emphasis>  -
                                  The event timestamp is taken from the timestamp
                                  of its first, earliest, fragment.
                               </para>
                            </listitem>
                            <listitem>
                               <para>
                                  <emphasis>GLOM_TIMESTAMP_LAST</emphasis>  -
                                  The event timestamp is taken from the timestamp
                                  of its last, latest, fragment.
                               </para>
                            </listitem>
                            <listitem>
                               <para>
                                  <emphasis>GLOM_TIMESTAMP_AVERAGE</emphasis>  -
                                  the timestamp is computed from the average of
                                  all fragment timestamps in the event.
                               </para>
                            </listitem>
                           </itemizedlist>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual CGlomParameters* </type>
                           <methodname>makeGlomParameters</methodname>
                           <methodparam>
                               <type>const CRingItem&amp; </type><parameter>rhs</parameter>
                           </methodparam>
                            
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            If <parameter>rhs</parameter> references a
                            glom parameters item returns a newly created,
                            equivalent <classname>CGomParameters</classname> object's
                            pointer.   If <parameter>rhs</parameter> is not a glom
                            parameters object or if the concrete implementation does
                            not yet support items of that time,
                            <classname>std::bad_cast</classname> must be thrown.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual CPhysicsEventItem* </type>
                           <methodname>makePhysicsEventItem</methodname>
                           <methodparam>
                               <type>size_t </type><parameter>maxBody</parameter>
                           </methodparam>
                            
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Creates a new physics event item. <parameter>maxBody</parameter>
                            sets the maximum size event body that will be filled in.
                            It is used to reserve space into which the ring item will
                            be formatted.  The return value is a pointer to a newly
                            created physics event item object.
                           </para>
                           <para>
                            If the underlying format of the concrete factory
                            supports body headers, this item will not be
                            created with a body header.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual CPhysicsEventItem*</type>
                           <methodname> makePhysicsEventItem</methodname>
                           <methodparam>
                               <type>uint64_t </type><parameter>timestamp</parameter>
                           </methodparam>
                           <methodparam>
                               <type>uint32_t</type><parameter> source</parameter>
                           </methodparam>
                           <methodparam>
                               <type>uint32_t </type><parameter>barrier</parameter>
                           </methodparam>
                           <methodparam>
                               <type>size_t </type><parameter>maxBody</parameter>
                           </methodparam>
                            
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Makes a physics event item with a body header
                            (if supported by the concrete format).  IF body headers
                            are not supported the implementation should just invoke
                            the prior creational method.
                           </para>
                           <para>
                            As before, <parameter>maxBody</parameter> determines
                            the maximum body size of the item.  The remaining
                            parameter determine the contents of the body header:
                            <parameter>timestamp</parameter> is the Event/fragment
                            timestamp, <parameter>source</parameter> is the Event/fragment
                            source id and <parameter>barrier</parameter> is the event/fragment's
                            barrier type.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual CPhysicsEventItem* </type>
                           <methodname>makePhysicsEventItem</methodname>
                           <methodparam>
                               <type>const CRingItem&amp;</type><parameter> rhs</parameter>
                           </methodparam>
                            
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Given <parameter>rhs</parameter> a reference to a
                            ring item that actually contains a physics event,
                            creates a new ring item of type <classname>CPHysicsEventItem</classname>
                            that is a functional equivalent of <parameter>rhs</parameter>
                            and returns a pointer to that item.
                           </para>
                           <para>
                            If <parameter>rhs</parameter> is not, in fact,
                            a physics event item, this method throws
                            <classname>std::bad_cast</classname>.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual CRingFragmentItem* </type>
                           <methodname>makeRingFragmentItem</methodname>
                           <methodparam>
                               <type>   uint64_t </type><parameter>timestamp</parameter>
                           </methodparam>
                           <methodparam>
                               <type> uint32_t </type><parameter>source</parameter>
                           </methodparam>
                           <methodparam>
                               <type>uint32_t </type><parameter>payloadSize</parameter>
                           </methodparam>
                           <methodparam>
                               <type>const void* </type><parameter>payload</parameter>
                           </methodparam>
                           <methodparam>
                               <type>uint32_t </type><parameter>barrier</parameter>
                               <initializer>0</initializer>
                           </methodparam>
                            
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            A <classname>CRingFragmentItem</classname> represents
                            an event fragment whose payload is a ring item.
                            The fragment itself looks like a ring item and has an
                            obligatory body header. The body header is followed by
                            a payload which, for this type is assumed to be another
                            ring item.
                           </para>
                           <para>
                            The contents of the obligatory body header are defined by
                            <parameter>timestamp</parameter>, the fragment timestamp,
                            <parameter>source</parameter>, the fragment source id and
                            <parameter>barrier</parameter>, the optional barrier type.
                            If not provided <parameter>barrier</parameter> defaults to
                            zero which is no barrier.
                           </para>
                           <para>
                            The payload is defined by
                            <parameter>paylaodSize</parameter> which is the number
                            of bytes in the payload and <parameter>payload</parameter>
                            which points to the payload itself.
                           </para>
                           <para>
                            The return value is a pointer to a new created
                            <classname>CRingFragmentItem</classname>.
                            If the concrete factory is of a format that does not
                            support <classname>CRingFragmentItem</classname> object
                            (does not implement the ring fragment raw ring item),
                            a <literal>nullptr</literal> must be returned.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual CRingFragmentItem* </type>
                           <methodname>makeRingFragmentItem</methodname>
                           <methodparam>
                               <type>const CRingItem&amp; </type><parameter>rhs</parameter>
                           </methodparam>
                            
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            If <parameter>rhs</parameter> references a
                            <classname>CRingItem</classname> whose contents are
                            a fragment item, this method creates a new
                            <classname>CRingFragmentItem</classname>, fills it with
                            the contents of the <parameter>rhs</parameter> and
                            returns a pointer to the new item.
                           </para>
                           <para>
                            If <parameter>rhs</parameter> is not a ring fragment item
                            or the version of NSCLDAQ used by the concrete factory
                            does not support <classname>CRingFragmentItem</classname>s,
                            <classname>std::bad_cast</classname> must be thrown.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual CRingPhysicsEventCountItem* </type>
                           <methodname>makePhysicsEventCountItem</methodname>
                           <methodparam>
                               <type>uint64_t </type><parameter>count</parameter>
                           </methodparam>
                           <methodparam>
                               <type>uint32_t </type><parameter>timeoffset</parameter>
                           </methodparam>
                           <methodparam>
                               <type>time_t </type><parameter>stamp</parameter>
                           </methodparam>
                           <methodparam>
                               <type>int </type><parameter>divisor</parameter>
                               <initializer>1</initializer>
                           </methodparam>
                            
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            A physics event count item represents the number of
                            event triggers on a data source. This can be used
                            online analysis programs to know the fraction of the
                            data they are able to analyze.
                           </para>
                           <para>
                            <parameter>count</parameter> is the total number
                            of triggers this run.  <parameter>timeoffset</parameter>
                            is the time offset into the run at which the number
                            of triggers represents.  <parameter>divisor</parameter>,
                            if supplied indicates the number of timeoffset ticks
                            in a second.  This allows for run offsets to be represented
                            with sub-second resolution.  The <parameter>stamp</parameter>
                            parameter represents the clock time at which the item was created.
                           </para>
                           <para>
                            All versions of NSCLDAQ since version 10 (the lowest
                            version we attempt to handle in this library) support
                            event count items.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual CRingPhysicsEventCountItem* </type>
                           <methodname>makePhysicsEventCountItem</methodname>
                           <methodparam>
                               <type>const CRingItem&amp;</type><parameter> rhs</parameter>
                           </methodparam>
                            
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            If the contents of <parameter>rhs</parameter> are a
                            physics event count raw item, this method creates a new
                            <classname>CRingPhysicsEventCountItem</classname> object
                            to wrap a copy of the item in <parameter>rhs</parameter> and
                            returns a pointer to that object.
                           </para>
                           <para>
                            If <parameter>rhs</parameter> is not encapsulating an
                            event count item; <classname>std::bad_cast</classname>
                            is thrown.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual CRingScalerItem* </type>
                           <methodname>makeScalerItem</methodname>
                           <methodparam>
                               <type>size_t </type><parameter>numScalers</parameter>
                           </methodparam>
                            
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Creates a new scaler item and returns a pointer to it.
                            Object methods can be used to modify the contents of the
                            item.   The item is sized for <parameter>numScalers</parameter>
                            32 bit scalers.  The clock timestamp for the item
                            is its creation time. The counting interval is initialized
                            to from zero to zero and the time divisor is initialized to
                            1.
                           </para>
                           <para>
                            For formats that support a body header, this item
                            should be created with no body header.   A full
                            body header can, of course, be added with
                            the object's <methodname>setBodyHeader</methodname>.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual CRingScalerItem* </type>
                           <methodname>makeScalerItem</methodname>
                           <methodparam>
                               <type>uint32_t </type><parameter>startTime</parameter>
                           </methodparam>
                           <methodparam>
                               <type>uint32_t </type><parameter>stopTime</parameter>
                           </methodparam>
                           <methodparam>
                               <type>time_t   </type><parameter>timestamp</parameter>
                           </methodparam>
                           <methodparam>
                               <type>std::vector&lt;uint32_t&gt; </type><parameter>scalers</parameter>
                           </methodparam>
                           <methodparam>
                               <type>bool </type><parameter>isIncremental </parameter>
                               <initializer>true</initializer>
                           </methodparam>
                           <methodparam>
                               <type>uint32_t </type><parameter>sid</parameter>
                               <initializer>0</initializer>
                           </methodparam>
                           <methodparam>
                               <type>uint32_t</type><parameter>timeOffsetDivisor</parameter>
                               <initializer>1</initializer>
                           </methodparam>
                            
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Constructs a scaler item and returns a pointer to it.
                            The <parameter>startTime</parameter> and
                            <parameter>stopTime</parameter> parameters provide the
                            offset into the run at which the counting interval started
                            and ended.  The <parameter>divisor</parameter>
                            provides the number of ticks per second for both of these
                            parameters.
                           </para>
                           <para>
                            <parameter>scalers</parameter> is the array of
                            scaler values.  <parameter>isIncremental</parameter>
                            indicates if the scalers were zeroed after the read.
                           </para>
                           <para>
                            For versions that support an original source id,
                            <parameter>sid</parameter> provides this value.
                            This allows event built data to track the source id
                            of the emitter of this item even as Glom rewrites the
                            body header source id.
                           </para>
                           <para>
                            See concrete implementations for information about
                            how, if at all, the implementation fills in a body header
                            for the item.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual CRingScalerItem* </type>
                           <methodname>makeScalerItem</methodname>
                           <methodparam>
                               <type>const CRingItem&amp; </type><parameter>rhs</parameter>
                           </methodparam>
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            If <parameter>rhs</parameter> encapsulates a raw
                            scaler item a new <classname>CRingScalerItem</classname>
                            is created and the data in <parameter>rhs</parameter>
                            are copied into the new item.  A pointer to that new
                            item is returned.
                           </para>
                           <para>
                            If <parameter>rhs</parameter> does not represent
                            scaler data, <classname>std::bad_cast</classname>
                            is thrown.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual CRingTextItem* </type>
                           <methodname>makeTextItem</methodname>
                           <methodparam>
                               <type>uint16_t </type><parameter>type</parameter>
                           </methodparam>
                           <methodparam>
                               <type>std::vector&lt;std::string&gt; </type><parameter>theStrings</parameter>
                           </methodparam>
                             
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Creates a ring item that contains a set of strings.
                            The <parameter>type</parameter> parameter contains
                            the type of the ring item (type field of ring item header).
                            The possible values for this are in <filename>DataFormat.h</filename>
                            and can be:
                           </para>
                           <itemizedlist>
                            <listitem>
                               <para>
                                  <emphasis>PACKET_TYPES</emphasis>  describes
                                  the set of packet data types physics event bodies
                                  may have.
                               </para>
                            </listitem>
                            <listitem>
                               <para>
                                  <emphasis>MONITORED_VARIABLES</emphasis>
                                  Contains a set of variable names and values as
                                  Tcl scriptlets that would set those variables
                                  to their values.
                               </para>
                            </listitem>
                           </itemizedlist>
                           <para>
                            <parameter>theStrings</parameter> contains the
                            strings to put in the payload section of the body.
                           </para>
                           <para>
                            Timing information in the bodiesof this ring item type
                            are initialized as follows:  The run offset time is zero,
                            The clock timestamp is the creation time of the
                            object and the offset divisor is <literal>1</literal>.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual CRingTextItem* </type>
                           <methodname>makeTextItem</methodname>
                           <methodparam>
                               <type>    uint16_t </type><parameter>type</parameter>
                           </methodparam>
                           <methodparam>
                               <type>std::vector&lt;std::string&gt; </type><parameter>theStrings</parameter>
                           </methodparam>
                           <methodparam>
                               <type>uint32_t </type><parameter>offsetTime</parameter>
                           </methodparam>
                           <methodparam>
                               <type>time_t</type><parameter>timestamp</parameter>
                           </methodparam>
                           <methodparam>
                               <type>uint32_t </type><parameter>divisor</parameter>
                               <initializer>1</initializer>
                           </methodparam>
                            
                           
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Creates an item with a list of text strings encapsulates it
                            in a <classname>CRingTextItem</classname> and returns a
                            pointer to the resulting item.  As before,
                            <parameter>type</parameter> is the ring item type
                            and <parameter>theStrings</parameter> are the
                            text strings to store in the ring item.
                           </para>
                           <para>
                            Additional parameters provide time information.
                            <parameter>offsetTime </parameter> is the offset into the
                            run while <parameter>divisor</parameter> is the number
                            of counts in <parameter>offsetTime</parameter> per second.
                            <parameter>timestamp</parameter> is the clock time that will
                            tag the item.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual CRingTextItem* </type>
                           <methodname>makeTextItem</methodname>
                           <methodparam>
                               <type>const CRingItem&amp;</type><parameter> rhs</parameter>
                           </methodparam>
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Given that <parameter>rhs</parameter> encapsulates a
                            ring text item, this method creates a new
                            <parameter>CRingTextItem</parameter>, copies the raw
                            ring item encapsulated by <parameter>rhs</parameter>
                            and returns a pointer to that new
                            <classname>CRingTextItem</classname>.
                           </para>
                           <para>
                            If the ring item type of <parameter>rhs</parameter>
                            makes it clear that this is not a valid text item, a
                            <classname>std::bad_cast</classname> will be thrown.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual CUnknownFragment* </type>
                           <methodname>makeUnknownFragment</methodname>
                           <methodparam>
                               <type>uint64_t </type><parameter>timestamp</parameter>
                           </methodparam>
                           <methodparam>
                               <type>uint32_t </type><parameter>sourceid</parameter>
                           </methodparam>
                           <methodparam>
                               <type>uint32_t</type><parameter> barrier</parameter>
                           </methodparam>
                           <methodparam>
                               <type>uint32_t </type><parameter>size</parameter>
                           </methodparam>
                           <methodparam>
                               <type>void* </type><parameter>pPayload</parameter>
                           </methodparam>
                            
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            This method is the same as <methodname>makeRingFragmentItem</methodname>
                            but the payload is not assumed to be a ring item.
                            While ring fragment items have type
                            <literal>EVB_FRAGMENT</literal>,  these have type
                            <literal>EVB_UNKNOWN_PAYLOAD</literal>
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual CUnknownFragment* </type>
                           <methodname>makeUnknownFragment</methodname>
                           <methodparam>
                               <type>const CRingItem&amp; </type><parameter>rhs</parameter>
                           </methodparam>
                            
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Again see <methodname>makeRingFragmentItem</methodname>.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual CRingStateChangeItem* </type>
                           <methodname>makeStateChangeItem</methodname>
                           <methodparam>
                               <type>uint32_t </type><parameter>itemType</parameter>
                           </methodparam>
                           <methodparam>
                               <type>uint32_t</type><parameter> runNumber</parameter>
                           </methodparam>
                           <methodparam>
                               <type>uint32_t</type><parameter>timeOffset</parameter>
                           </methodparam>
                           <methodparam>
                               <type>time_t </type><parameter>timestamp</parameter>
                           </methodparam>
                           <methodparam>
                               <type>std::string </type><parameter>title</parameter>
                           </methodparam>
                            
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Creates a new state change ring item wrapping it in a
                            <classname>CRingStateChangeItem</classname> and returning a
                            pointer to the new object.
                           </para>
                           <para>
                            The <parameter>itemType</parameter> parameter provides
                            the exact state change reason.  Its possible values are
                            defined in <filename>DataFormat.h</filename> and are:
                            <literal>BEGIN_RUN</literal>, <literal>PAUSE_RUN</literal>,
                            <literal>RESUME_RUN</literal>, and <literal>END_RUN</literal>
                            with obvious (I hope) meanings.
                           </para>
                           <para>
                            <parameter>runNumber</parameter> provides the run number
                            of the run having the transition, and <parameter>title</parameter>
                            its title string.  <parameter>timeOffset</parameter>
                            provides the time offset into the run while
                            <parameter>timestamp</parameter> is intended
                            to provide an absolute clock time at which the
                            transtion occured.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual CRingStateChangeItem* </type>
                           <methodname>makeStateChangeItem</methodname>
                           <methodparam>
                               <type>const CRingItem&amp;</type><parameter> rhs</parameter>
                           </methodparam>
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            If <parameter>rhs</parameter> is a <classname>CRingItem</classname>
                            that is wrapping a state change raw ring item, this
                            method creates a new <classname>CRingStateChangeItem</classname>,
                            wraps a copy of the raw ring item in <parameter>rhs</parameter>
                            and returns a pointer to the new item to the caller.
                            If <parameter>rhs</parameter> is not a valid
                            state change item, <classname>std::bad_cast</classname>
                            is thrown.
                           </para>
                        </listitem>
                    </varlistentry>                
                </variablelist>
                             
            </refsect1>
        </refentry>
        
        <refentry>
           <refmeta>
              <refentrytitle>CRingItem (abstract)</refentrytitle>
              <manvolnum>3format</manvolnum>
           </refmeta>
           <refnamediv>
              <refname>CRingItem</refname>
              <refpurpose>Ultimate ring item base class</refpurpose>
            </refnamediv>
            <refsynopsisdiv>
                <programlisting>
#include &lt;CRingItem.h&lt;

class CRingItem {

public:
      CRingItem(uint16_t type, size_t maxBody = CRingItemStaticBufferSize - 10);

      CRingItem(const CRingItem&amp; rhs);
      CRingItem(pRingItem pItem);
      virtual ~CRingItem();
      virtual size_t getStorageSize() const;
      virtual size_t getBodySize()    const;
      virtual const void*  getBodyPointer() const;
      virtual void* getBodyPointer();
      void*  getBodyCursor();
      pRingItem  getItemPointer();
      const RingItem*  getItemPointer() const;
      uint32_t type() const;
      uint32_t size() const;
      virtual bool mustSwap() const;
      virtual bool hasBodyHeader() const;
      virtual void* getBodyHeader() const = 0;
      virtual uint64_t getEventTimestamp() const;
      virtual uint32_t getSourceId() const;
      virtual uint32_t getBarrierType() const;
      virtual void setBodyHeader(uint64_t timestamp, uint32_t sourceId,
                         uint32_t barrierType = 0) = 0;
      virtual void setBodyCursor(void* pNewCursor);
      virtual void updateSize();            /* Set the header size given the cursor. */
      virtual std::string typeName() const; // Textual type of item.
      virtual std::string toString() const; // Provide string dump of the item.
      virtual void* appendBodyData(const void* pSrc, uint32_t nBytes);


};
                </programlisting>
            </refsynopsisdiv>
            <refsect1>
                     <title>DESCRIPTION</title>
                  <para>
                    This is the ultimate base class for all ring item format classes.
                    It lives in the global namespace.  It provides interfaces
                    and services used by other derived classes.
                  </para>
                  <para>
                    While most of the virtual methods have default implementations,
                    if you are building a new formatting class hierarchy, you should
                    not count on those doing what you want if they require
                    knowledge of the format of the ring item format.
                  </para>
            </refsect1>
            <refsect1>
                <title>METHODS</title>
                <variablelist>
                    <varlistentry>
                       <term>
                        <constructorsynopsis>
                            <methodname>CRingItem</methodname>
                            <methodparam>
                                <type>uint16_t</type><parameter>type</parameter>
                            </methodparam>
                            <methodparam>
                                <type>size_t </type><parameter>maxBody</parameter>
                                <initializer>CRingItemStaticBufferSize - 10</initializer>
                            </methodparam>
                        </constructorsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Constructor.  <parameter>type</parameter> will be stored
                            in the ring item header's type field.  Note that
                            the header form is common for all formats.
                            The <parameter>type</parameter> is 16 bit wide because in
                            the original design it was also used to determine the
                            byte order of the originator.  Specifically, if the
                            'low order' 16 bits of a type field were zero, the
                            byte order of the originator was the opposite of the
                            consumer.  Now that little-endianess has won the
                            byte order wars and big-endinaness only appears
                            vestigially in network byte ordering,  We define
                            the byte ordering of Ring items to be little-endian.
                           </para>
                           <para>
                            <parameter>maxBody</parameter> determines the maximum
                            number of bytes the internal storage for the ring item
                            can hold in the body (the part following the header).
                            Note that the design of <classname>CRingItem</classname>
                            includes a decently sized static block of data.
                            If this value indicates the data will fit in that
                            block, no dynamic memory allocation is required and
                            that block is used.  If this value indicates that
                            the data won't fit, a block is dynamically allocated
                            and used.  The intent is to minimize the costly
                            set of dynamic memory allocations/deallocations
                            needed if all <classname>CRingItem</classname>
                            constructions dynamically allocated the needed
                            data.
                           </para>
                           <para>
                            The default value for <parameter>maxBody</parameter>
                            allows callers to use the static buffer and is
                            defined in <filename>CRingItem.h</filename>.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <constructorsynopsis>
                            <methodname>CRingItem</methodname>
                            <methodparam>
                                <type>pRingItem </type><parameter>pItem</parameter>
                            </methodparam>
                        </constructorsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Wraps a <classname>CRingItem</classname> object
                            around a raw ring item.  The type
                            <type>pRingItem</type> is defined in
                            <filename>DataFormat.h</filename>.
                           </para>
                           <para>
                            <parameter>pItem</parameter> is used to size
                            the ring item and copied into the data storage
                            region of the item.  The body cursor is set to point
                            after the ring item data.  This allows the
                            item to be mutated (via <methodname>getBodyPointer</methodname>)
                            and to be extended (via <methodname>getBodyCursor</methodname>,
                            <methodname>setBodyCursor</methodname>, and <methodname>updateSize</methodname>).
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual size_t </type>
                           <methodname>getStorageSize</methodname>
                           <void />
                           <modifier>const</modifier>
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Returns the capacity of the block of data that is being used
                            to store the ring item.   Can be used to determine
                            if sufficient storage has been allocated to
                            hold the desired ring item.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual size_t </type>
                           <methodname>getBodySize</methodname>
                           <void />
                           <modifier>const</modifier>
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Returns the current size, in bytes,
                            of the ring item body.
                            This computes the number of bytes between the
                            pointers returned by
                            <methodname>getBodyCursor</methodname> and the
                            <methodname>geBodyPointer</methodname>.  For it to be
                            accurate, <methodname>getBodyCursor</methodname>
                            must be updated (via <methodname>setBodyCursor</methodname>)
                            to point past the body of the ring item as it is
                            so far.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual const void*  </type>
                           <methodname>getBodyPointer</methodname>
                           <void /><modifier>const</modifier>
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Returns a pointer to the body of the item. Since
                            the pointer is const, this is intended to allow
                            read access.  Note that the concept of a ring item
                            <firstterm>body</firstterm> is not that straightforward.
                            In version 10, for example the body begins right after
                            the ring item header.  In v11, v12, which support body
                            headers the body may begin after the <type>uint32_t</type>
                            indicating there is no body header (which has different values
                            depending on version) or it may begin after the body
                            header if there is on.  Therefore, this is virtual
                            and implemented on a per version basis.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type> virtual void* </type>
                           <methodname>getBodyPointer</methodname>
                           <void />
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Same as above except that the pointer can be used
                            to modify the body contents.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>void*  </type>
                          <methodname>getBodyCursor</methodname>
                          <void />
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the body cursor of the item. When a ring item
                            is created, a pointer, called the body cursor is
                            created which points to the first free byte of memory
                            into which data can be appended to the ring item.
                            As data are appended to the ring item, the
                            object's body cursor should be reste with
                            <methodname>setBodyCursor</methodname>, at some point,
                            when the ring item has been completely built,
                            <methodname>updateSize</methodname> should be called
                            to compute the ring item's size and store it in the
                            size field of the ring item's header.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>pRingItem  </type>
                          <methodname>getItemPointer</methodname>
                          <void />
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns a pointer to the ring item as encapsulated
                            by this class.  Note that <type>pRingItem</type>
                            is defined in <filename>DataFormat.h</filename>.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>const RingItem*  </type>
                          <methodname>getItemPointer</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Same as above but the pointer only allows read access
                            to the contents of the ring item.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>uint32_t </type>
                          <methodname>type</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the full 32 bit size field of the
                            ring item.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>uint32_t </type>
                          <methodname>size</methodname>
                          <void /> <modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the size field of the header. Note that unless
                            <methodname>updateSize</methodname> has been called,
                            this value is not a reliable measure of the number
                            of bytes that make up the ring item.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual bool </type>
                          <methodname>mustSwap</methodname>
                          <void /> <modifier> const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns <literal>false</literal>.  All data is
                            now specified be little endian as are all computing
                            systems processing that data.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual bool </type>
                          <methodname>hasBodyHeader</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns <literal>true</literal> if the ring item
                            has a body header.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void* </type>
                          <methodname>getBodyHeader</methodname>
                          <void /> <modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns a pointer to the body header of the item
                            if it has one.  If it does not returns a
                            <literal>nullptr</literal>. 
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual uint64_t </type>
                           <methodname>getEventTimestamp</methodname>
                           <void /> <modifier>const</modifier>
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Returns the event/fragment timestamp stored
                            in the body header of the ring item.  If the ring
                            item has no body header,
                            <classname>std::logic_error</classname> is thrown.
                            You can use e.g. <methodname>hasBodyHeader</methodname>
                            to test for the presence of a body header in the
                            item.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual uint32_t </type>
                          <methodname>getSourceId</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Retrieves the source id from the ring item's body header.
                            If the ring item does not have a body header,
                            <classname>std::logic_error</classname> is throw
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual uint32_t </type>
                          <methodname>getBarrierType</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the barrier type field from the item's
                            body header.   If the ring item does not have a body
                            header, <classname>std::logic_error</classname>
                            is thrown.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        (pure virtual)
                        <methodsynopsis>
                          <type>virtual void </type>
                          <methodname>setBodyHeader</methodname>
                          <methodparam>
                              <type>uint64_t </type><parameter>timestamp</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t </type><parameter>sourceId</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t </type><parameter>barrierType</parameter>
                              <initializer>0</initializer>
                          </methodparam>
                       </methodsynopsis>
                       
                       </term>
                       <listitem>
                           <para>
                            If the format supports body headers a body header is
                            added to the item (if it does not already have one) or
                            the body header is modified as described by the method's
                            parameters.  If the format does not support body headers,
                            this should be implemented as a no-op.
                           </para>
                           <para>
                            Note that body data must never be overwritten.
                            If an item has a non-empty body but no body header,
                            then that body must be moved to make space for the
                            body header which is then put in the appropriate
                            place (after the ring item header in currently
                            supported formats).
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void </type>
                          <methodname>setBodyCursor</methodname>
                          <methodparam>
                              <type>void* </type><parameter>pNewCursor</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Updates the internal body cursor of the object
                            with <parameter>pNewCursor</parameter>.  If coupled
                            with a call to <methodname>updateSize</methodname>,
                            this causes the size field of the ring item header
                            to be computed and updated.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void</type>
                          <methodname>updateSize</methodname>
                          <void />
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Treating the current body cursor value as a pointer
                            to the byte following the current contents of the
                            ring item, the size of the ring item is computed
                            and stored in the size field of the ring item
                            header.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual std::string </type>
                          <methodname>typeName</methodname>
                          <void /> <modifier>() const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            The base class returns the string:
                            <literal>Unknown</literal> followed by the parenthesized
                            numeric
                            type from the ring item header in hexadecimal.
                            Derived classes are
                            expected to return a text string which indicates the
                            type of the ring item. 
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual std::string </type>
                          <methodname>toString</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Retuns a human readable stringified dump
                            of the body of the item.  In this case this is just
                            a byte by byte dump.  Derived classes are expected
                            to return something a bit more meaningful.  The
                            NSCLDAQ dumper, e.g. uses this string to
                            dump items it encounters.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void* </type>
                          <methodname>appendBodyData</methodname>
                          <methodparam>
                              <type>const void* </type><parameter>pSrc</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t </type><parameter>nBytes
                              </parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Appends the <parameter>nBytes</parameter> bytes
                            of data pointed to by <parameter>pSrc</parameter>
                            to the ring item.  The data are placed where
                            the current body cursor is pointing.  The body cursor
                            is updated and the size recomputed.
                           </para>
                           <para>
                            This is equivalent to the following code fragment:
                           </para>
                           <informalexample>
                            <programlisting>
  uint8_t* p = reinterpret_cast&lt;uint8_t*&gt;(getBodyCursor());
  memcpy(p, pSrc, nBytes);
  p += nBytes;
  setBodyCursor(p);
  updateSize();
  return p;

                            </programlisting>
                           </informalexample>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </refsect1>
        </refentry>
        <refentry>
           <refmeta>
              <refentrytitle>CAbnormalEndItem (abstract)</refentrytitle>
              <manvolnum>3format</manvolnum>
           </refmeta>
           <refnamediv>
              <refname>CAnbormaleEndItem (abstract)</refname>
              <refpurpose>Support ring items that flag abnormally ended runs.</refpurpose>
            </refnamediv>
            <refsynopsisdiv>
                <programlisting>
#include &lt;CAbnormalEndItem.h&gt;

class CAbnormalEndItem : public CRingItem
{
public:
    CAbnormalEndItem();
    virtual ~CAbnormalEndItem();

    virtual void* getBodyHeader() const;
    virtual void  setBodyHeader(uint64_t timestamp, uint32_t sourceId,
                         uint32_t barrierType = 0);

    virtual std::string typeName() const;
    virtual std::string toString() const;
};

                </programlisting>
            </refsynopsisdiv>
            <refsect1>
                     <title>DESCRIPTION</title>
                  <para>
                    In the event a data taking run ends abnormally,
                    Abnormal end run items can be emittted.  One purpose of
                    these is to inform event loggers that the event file they have
                    open can be closed. 
                  </para>
                  <para>
                    Normally an abnormal end run item is an indication of a
                    DAQ state transition from active or paused to not ready.
                  </para>
                  <para>
                    Abnormal end items were introduced into NSCLDAQ in version
                    11.  In version 11 and 12, they are simply ring item headers
                    with no body but the type <literal>ABNORMAL_ENDRUN</literal>.
                  </para>
            </refsect1>
            <refsect1>
                <title>METHODS</title>
                <para>
                    The methods below are normally implemented in version
                    specific implementation of <classname>CAbnormalEndRun</classname>
                </para>
                <variablelist>
                    <varlistentry>
                       <term><constructorsynopsis>
                           <methodname>CAbnormalEndItem</methodname>
                        <void />
                       </constructorsynopsis></term>
                       <listitem>
                           <para>
                            Constructs the item.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void* </type>
                          <methodname>getBodyHeader</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Normally returns <literal>nullptr</literal>
                            since these items don't have body headers.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void  </type>
                          <methodname>setBodyHeader</methodname>
                          <methodparam>
                              <type>uint64_t </type><parameter>timestamp</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t </type><parameter>sourceId</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t </type><parameter>barrierType</parameter>
                              <initializer>0</initializer>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Since the <classname>CAbnormalEndItem</classname>
                            never has a body header, this is a no-op.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual std::string </type>
                          <methodname>typeName</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the string
                            <literal>Abnormal End</literal>
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual std::string </type>
                          <methodname>toString</methodname>
                          <void /> <modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the string
                            <literal>Abnormal End\n</literal> where the
                            <literal>\n</literal> should be interpreted to mean
                            a new line.
                           </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </refsect1>
        </refentry>
        <refentry>
           <refmeta>
              <refentrytitle>CDataFormatItem (abstract)</refentrytitle>
              <manvolnum>3format</manvolnum>
           </refmeta>
           <refnamediv>
              <refname>CDataFormatItem (abstract)</refname>
              <refpurpose>Ring item that describes format version</refpurpose>
            </refnamediv>
            <refsynopsisdiv>
                <programlisting>
#include &lt;CDataFormatItem.h&gt;

class CDataFormatItem : public CRingItem
{
public:
    CDataFormatItem();
    virtual ~CDataFormatItem();

    CDataFormatItem(const CDataFormatItem&amp; rhs);
    CDataFormatItem(const CRingItem&amp; rhs) ;


    virtual uint16_t getMajor() const;
    virtual uint16_t getMinor() const;


    virtual std::string typeName() const;
    virtual std::string toString() const;

    virtual void* getBodyHeader() const;
    virtual void setBodyHeader(uint64_t timestamp, uint32_t sourceId,
                         uint32_t barrierType = 0);

};

                </programlisting>
            </refsynopsisdiv>
            <refsect1>
                     <title>DESCRIPTION</title>
                  <para>
                    THe data format ring item was introduced beginning in
                    NSCLDAQ-11.  It provides information about the version
                    (and therefore the  format) of NSCLDAQ that
                    generated the stream of ring items that follow.
                  </para>
            </refsect1>
            <refsect1>
                <title>METHODS</title>
                <variablelist>
                   <varlistentry>
                      <term><constructorsynopsis>
                          <methodname>CDataFormatItem</methodname>
                        <void />
                      </constructorsynopsis></term>
                      <listitem>
                          <para>
                            The constructor fill sin the item with the
                            major and minor vesions that define the data
                            format.
                       </para>
                    </listitem>
                   </varlistentry>
                   <varlistentry>
                      <term><methodsynopsis>
                         <type>virtual uint16_t </type>
                         <methodname>getMajor </methodname>
                         <void /><modifier>const</modifier>
                      </methodsynopsis></term>
                      <listitem>
                          <para>
                            Returns the major version of the data format.  In
                            practice, this is sufficient to establish the data
                            format.
                       </para>
                    </listitem>
                   </varlistentry>
                   <varlistentry>
                      <term><methodsynopsis>
                         <type>virtual uint16_t </type>
                         <methodname>getMinor</methodname>
                         <void /><modifier>const</modifier>
                      </methodsynopsis></term>
                      <listitem>
                          <para>
                            Returns the minor version of the data format.  In practice
                            this is seldom necessary.
                       </para>
                    </listitem>
                   </varlistentry>
                   <varlistentry>
                      <term><methodsynopsis>
                         <type>virtual std::string </type>
                         <methodname>typeName</methodname>
                         <void /><modifier>const</modifier>
                      </methodsynopsis></term>
                      <listitem>
                          <para>
                            Return the string:
                            <literal>Ring Item format version</literal>
                       </para>
                    </listitem>
                   </varlistentry>
                   <varlistentry>
                      <term><methodsynopsis>
                         <type>virtual std::string </type>
                         <methodname>toString</methodname>
                         <void /> <modifier>const</modifier>
                      </methodsynopsis></term>
                      <listitem>
                          <para>
                            Returns a human readable string that describes the
                            contents of the ring item.
                       </para>
                    </listitem>
                   </varlistentry>
                   <varlistentry>
                      <term><methodsynopsis>
                         <type>virtual void* </type>
                         <methodname>getBodyHeader</methodname>
                         <void /><modifier>const</modifier>
                      </methodsynopsis></term>
                      <listitem>
                          <para>
                            Returns <literal>nullptr</literal> since these items
                            never have a body header.
                       </para>
                    </listitem>
                   </varlistentry>
                   <varlistentry>
                      <term><methodsynopsis>
                         <type>virtual void </type>
                         <methodname>setBodyHeader</methodname>
                         <methodparam>
                             <type>uint64_t </type><parameter>timestamp</parameter>
                         </methodparam>
                         <methodparam>
                             <type>uint32_t </type><parameter>sourceId</parameter>
                         </methodparam>
                         <methodparam>
                             <type>uint32_t </type><parameter>barrierType </parameter>
                             <initializer>0</initializer>
                         </methodparam>
                      </methodsynopsis></term>
                      <listitem>
                          <para>
                            No-op since these items don't have body headers.
                       </para>
                    </listitem>
                   </varlistentry>                    
                </variablelist>
            </refsect1>
        </refentry>
        <refentry>
           <refmeta>
              <refentrytitle>CGlomParameters (abstract)</refentrytitle>
              <manvolnum>3format</manvolnum>
           </refmeta>
           <refnamediv>
              <refname>CGlomParameters (abstract)</refname>
              <refpurpose>Document event building parameters</refpurpose>
            </refnamediv>
            <refsynopsisdiv>
                <programlisting>
#include &lt;CGlomParameters.h&gt;

class CGlomParameters : public CRingItem
{
public:
    
    typedef enum _TimestampPolicy {
        first = 0, last = 1, average = 2
    } TimestampPolicy;
    
public:
    CGlomParameters(uint64_t interval, bool isBuilding, TimestampPolicy policy);
    
    virtual uint64_t coincidenceTicks() const;
    virtual bool     isBuilding() const;
    virtual TimestampPolicy timestampPolicy() const;

    virtual std::string typeName() const;  
    virtual std::string toString() const;
        
    virtual void* getBodyHeader() const;
    virtual void setBodyHeader(uint64_t timestamp, uint32_t sourceId,
                         uint32_t barrierType = 0);
    

};

                </programlisting>
            </refsynopsisdiv>
            <refsect1>
                     <title>DESCRIPTION</title>
                  <para>
                    NSCLDAQ versions that support event building use this ring item
                    type to allow the event builder to document its event builder
                    settings.  The most important of these is the actual event
                    building coincidence interval.
                  </para>
            </refsect1>
            <refsect1>
                <title>METHODS</title>
                <para>
                    The following public methods are provided.
                </para>
                <variablelist>
                    <varlistentry>
                       <term><constructorsynopsis>
                           <methodname>CGlomParameters</methodname>
                        <methodparam>
                            <type>uint64_t </type><parameter>interval</parameter>
                        </methodparam>
                        <methodparam>
                            <type>bool </type><parameter>isBuilding</parameter>
                        </methodparam>
                        <methodparam>
                            <type>TimestampPolicy </type><parameter>policy</parameter>
                        </methodparam>
                       </constructorsynopsis></term>
                       <listitem>
                           <para>
                            Fully parameterized construction.  <parameter>interval</parameter>
                            is the coincidence interval used to build events from
                            the sorted fragments.  If <parameter>isBuilding</parameter>
                            is false, the output stream is just a stream of single
                            fragment events, regardless of the coincidence interval.
                            This is intended for use in testing only.
                            <para>policy</para> is the policy used to derive
                            timestamps of the output event stream from the
                            fragments that compose them.
                            See <literal>DATA TYPES and CONSTANTS</literal>
                            for valid values and their meanings.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual uint64_t </type>
                          <methodname>coincidenceTicks</methodname>
                          <void /> <modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the coincidence interval stored in the object.
                            The units of this value are timestamp ticks.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual bool     </type>
                          <methodname>isBuilding</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the state of the object's building flag.
                            If true, the data are event built. If not the
                            event builder was run in a test mode where
                            each event output consists of a single fragment.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual TimestampPolicy </type>
                          <methodname>timestampPolicy</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the timestamp policy used to derive the
                            timestamp of output events.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual std::string </type>
                          <methodname>typeName</methodname>
                          <void /> <modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns a string that identifies the ring item type:
                            <literal>Glom Parameters</literal>.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual std::string </type>
                          <methodname>toString</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns a stringified representation of the object.
                            Intended for use in e.g. <command>dumper</command>.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void* </type>
                          <methodname>getBodyHeader</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns a pointer to the object's body header.
                            Since glom parameter items dont, at present,
                            have body headers, expect a
                            <literal>nullptr</literal> to be returned.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term></term><methodsynopsis>
                          <type>virtual void </type>
                          <methodname>setBodyHeader</methodname>
                          <methodparam>
                              <type>uint64_t </type><parameter>timestamp</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t sourceId</type><parameter></parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t </type><parameter>barrierType</parameter>
                              <initializer>0</initializer>
                          </methodparam>
                       </methodsynopsis>
                       <listitem>
                           <para>
                            Sets/adds a body header to the item.  Since
                            glom parameter items don't have a body header,
                            this is a no-op.
                           </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </refsect1>
            <refsect1>
                <title>DATA TYPES and CONSTANTS</title>
                <para>
                    The <classname>CGlomParameters</classname> class provides
                    a single data type:  <type>TimestampPolicy</type>.  THe
                    event builder in NSCLDAQ supports hierarchical event building.
                    This means that the output of an event builder can be input
                    for a subsequent event builder in the data acquisition
                    data flow.
                </para>
                <para>
                    This allows detector systems which require an event builder
                    of their own to be run together with other detector systems
                    by simply providing a second level event builder to glue together
                    events from each detector subsystem into coincident events.
                </para>
                <para>
                    This ability for hierarchical event building requires that
                    output events are also given a timestamp.  The
                    <type>TimestampPolicy</type> data type provides a type that
                    specifies how this output timestamp is determined.  It
                    can have the following values:
                </para>
                <variablelist>
                    <varlistentry>
                       <term><literal>first</literal></term>
                       <listitem>
                           <para>
                            The output timestamp is taken from the earliest (first)
                            fragment's timestamp.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><literal>last</literal></term>
                       <listitem>
                           <para>
                            The output timestamp is taken from the latest (last)
                            fragment's timestamp.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><literal>average</literal></term>
                       <listitem>
                           <para>
                            The output timestamp is the average of all timestamps
                            of the fragments that make up the event.
                           </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </refsect1>
        </refentry>
       </section>
    </chapter>
</book>