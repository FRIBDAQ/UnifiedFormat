<?xml version="1.0" encoding="UTF-8"?>


<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN"
                      "file:///usr/share/xml/docbook/schema/dtd/4.5/docbookx.dtd
"
>
<book>
    <bookinfo>
      <title>NSCLDAQ Unified Format Library</title>
      <author><firstname>Ron</firstname><surname>Fox</surname></author>
      <revhistory>
          <revision>
             <revnumber>1.0</revnumber>
             <date>June 6, 2022</date>
             <authorinitials>RF</authorinitials>
             <revremark>Original Release</revremark>
          </revision>
      </revhistory>
    </bookinfo>
    <chapter>
       <title>Introduction</title>
       <section>
        <title>Motivation</title>
        <para>
         Data in the NSCLDAQ system are distributed online through ring buffers.
         While a ring buffer, at its lowest level, is just a stream of bytes
         produced by a producer and consumed by zero or more consumers,
         in practice, a structure is layered on top of this byte stream.
        </para>
        <para>
         Items are placed by producers as Ring Items.  A Ring Item consists of
         a header and a payload.  The header contains the complete size of the item
         and an item type.  As NSCLDAQ has evolved, so too have the formats
         of the payloads for various item types.  This makes writing programs
         that can process data from all versions of NSCLDAQ difficult to
         write correctly.
        </para>
        <para>
         This document describes a set of libraries which should ease this burden,
         and allow you to very simply write programs that can operate on data
         from any of the NSCLDAQ data formats.
        </para>
       </section>

       <section>
        <title>Document Organization</title>
        <para>
            The remainder of this document is organized as follows:
        </para>
        <itemizedlist>
            <listitem>
               <para>
                   The remainder of this chapter,
                   describes what you need to do to incorporate this library
                   into your program (compilation and link directives).
               </para>
            </listitem>
            <listitem>
               <para>
                  <link linkend='ch.organization' endterm='ch.organization.title' />
                  Describes the organization of the library.
               </para>
            </listitem>
            <listitem>
               <para>
                  <link linkend='ch.factories' endterm='ch.factories.title' />
                  Describes the abstract factory design pattern and how it's applied
                  to this library.
               </para>
            </listitem>
            <listitem>
               <para>
                  <link linkend='ch.reference' endterm='ch.reference.title' />
                  Provides detailed reference pages.
               </para>
            </listitem>
        </itemizedlist>
        <section>
            <title>Incorporating this library into your programs</title>
            <para>
                As with most Linux library installations, there are
                <filename>include</filename> and <filename>lib</filename> directories
                under the installation directory.  If <literal>$INSTALL_ROOT</literal>
                is the top level installation directory, at compilation time you'll
                need to add
            </para>
            <informalexample>
                <programlisting>
-I$INSTALL_ROOT/include
                </programlisting>
            </informalexample>
            <para>
                to your compilation flags so that header files can be located
                by the compiler's preprocessor.  Note that there are several
                subdirectories below this top level header directory, however
                you <emphasis>should not</emphasis> add those to the header
                file search path.
            </para>
            <para>
                The software consists of several libraries.  These must
                be added to the link and, since the libraries are shared,
                an rpath directive must be added so that the run time
                loader can locate those libraries when programs using them
                start.  
            </para>
            <para>
                This means adding the following flags to the link command:
            </para>
            <informalexample>
                <programlisting>
-L$INSTALL_ROOT/lib -lNSCLDAQFormat \
    -lV10Format -lV11Format -lV12Format -lAbstractFormat \
    -Wl,-rpath=$INSTALL_ROOT/lib
                </programlisting>
            </informalexample>
        </section>
       </section>
    </chapter>
    <chapter id='ch.organization'>
       <title id='ch.organization.title'>Library Organization</title>
       <para>
        This chapter describes the organization of the libraries.  
       </para>
       <para>
        The first question a user might reasonbly ask is how a library can hide
        the format differences between the versions of NSCLDAQ from a program.
        This can be done mostly by understanding that each version layers on additional
        fields and capabilities on the base of fields and capabilities supplied by
        the prior version.  For example V11 adds the ability to have a body header
        used in event building to the V10 format.  V12, makes a slight change to
        the value that indicates there is no body header and provides the ability to
        track the original source id of objects whose body headers are otherwise
        overwritten during event building.
       </para>
       <para>
        The format libary:
       </para>
       <orderedlist>
        <listitem>
           <para>
              Provides a set of classes that is derived from a base class that
              completely hides the actual layout of each item, only providing
              constructors and accessors to retrieve/set fields in the underlying
              data of each object.
           </para>
           <para>
            Where capabilities dont' yet exist, the library either hands off
            reasonable defaults or throws exceptions.
           </para>
        </listitem>
        <listitem>
           <para>
              Provides a set of object factories, one for each supported
              NSCLDAQ version to generate objects either from parameterization,
              undifferentiated items or from sources of data (e.g. ringbuffers,
              file descriptors or c++ streams).  The factories also provide support
              for serializing objects to these entities.
           </para>
        </listitem>
        <listitem>
           <para>
              Given information about the version of NSCLDAQ used (either an
              explicit version number or a data format item, the library can
              provide an instance of the appropriate factory.
           </para>
        </listitem>
       </orderedlist>
       <para>
        In this way a program is not looking at the actual data but simply getting or
        setting properties of the data based on an interface that can accomodate
        the maximal capabilities of a ring item over all versions.
       </para>
       <para>
        The next sections describe and give examples of
       </para>
       <itemizedlist>
        <listitem>
           <para>
              <link linkend='sec.ringitems' endterm='sec.ringitems.title' />
              The ring item classes which encapsulate the data from each ring item
              type.
           </para>
        </listitem>
        <listitem>
           <para>
              <link linkend='sec.factories' endterm='sec.factories.title' />
              The factory classes see, however
              <link linkend='ch.factories' endterm='ch.factories.title' /> for more.
              
           </para>
        </listitem>
       </itemizedlist>
       <section id='sec.ringitems'>
        <title id='sec.ringitems.title'>Ring Item classes.</title>
        <para>
         Ring item contents are hidden from users behind a family of classes.
         A set of base classes, abstract ring items define a interfaces for each
         type of ring item. For each supported version of NSCLDAQ a set of subclasses
         exists that actually provide those interfaces for that specific data format.
         In the next section we'll see how we can then use the factory classes
         and factory selector to produce items without knowing the detailed format
         of those items.
        </para>
        <para>
            The headers for the abstract ring items types are located in
            the <filename>include</filename> subdirectory of the library's
            installation directory root.  Subdirectories named
            <literal>v</literal><emphasis>nn</emphasis> where <emphasis>nn</emphasis>
            is the NSCLDAQ version number host the headers for specific NSCLDAQ
            versions.  For example  <filename>include/v11</filename> holds
            the headers for version 11.  
        </para>
        <para>
            Since each of the version dependent headers will reference the
            abstract headers, it's important to only add the top level include
            directory to the header search path.  Here's a code fragment
            that shows how to create and fill in a physics data item
            with event builder information for version 11 (note that in
            practice you'll do this using a ring item factory as described
            in the next section).
        </para>
        <example>
            <title>Generating a Physics item for NSCLDAQ-11</title>
            <programlisting>
#include &lt;v11/CPhysicsEventItem.h&gt;     <co id='v11phys.header' />
...
v11::CPhysicsEventItem item;                      <co id='v11phys.create' />
item.setBodyHeader(someTimestamp, someSourceId); <co id='v11phys.setbodyheader' />
uint16_t* pBody = reinterpret_cast&lt;uint16_t*&gt;(item.getBodyCursor); <co id='v11phys.getcursor' />
...
item.setBodyCursor(pBody);                   <co id='v11phys.updatecursor' />
item.updateSize();                           <co id='v11phys.setsize' />
...

            </programlisting>
        </example>
        <calloutlist>
            <callout arearefs='v11phys.header' >
                <para>
                    Note how we explicitly pull in the header from the v11
                    subdirectory of the header directory tree for the library.
                    This header will, in turn, refer to the header in the
                    top level directory, which supplies the base interface.
                </para>
            </callout>
            <callout arearefs='v11phys.create' >
                <para>
                    After some code that's not relevant, a V11 Physics item is
                    created.  Note that each subclass family lives in a namespace
                    that indicates its version.  The parameter-less constructor
                    just reservers a default amount of storage (about 8192 bytes),
                    and reserves the ring item header filling in the type field
                    with <literal>v11::PHYSICS_EVENT</literal>.  An optional parameter
                    can be used to reserve additional storage if needed.
                </para>
                <para>
                    We'll still need to fill in the header's size field as we'll
                    see later on.
                </para>
            </callout>
            <callout arearefs='v11phys.setbodyheader' >
                <para>
                    Event builder data is in the item's body header which contains
                    a timestamp, sourceid and barrier type.  The
                    <methodname>setBodyHeader</methodname> sets the body header
                    of the item, if necessary sliding down any existing body data
                    to accomodate it.  The barrier type argumetn of
                    <methodname>setBodyHeader</methodname> defaults to
                    <literal>0</literal> which implies the event is not an
                    event builder barrier.
                </para>
            </callout>
            <callout arearefs='v11phys.getcursor' >
                <para>
                    Ring items have a <firstterm>body cursor</firstterm>. This is
                    the location at which additional body data can be stored. The
                    <methodname>getBodyCursor</methodname> method retrieves a
                    <type>void*</type> pointer to this storage in a format
                    independent manner.  This provides us a pointer which we
                    can use to fill in the data from the physics trigger.
                </para>
                <para>
                    Note that the code in the section marked <literal>...</literal>
                    below is assumed to fill in the physics data and advance
                    the <varname>pBody</varname> pointer to point past the
                    body data we put in.
                </para>
            </callout>
            <callout arearefs='v11phys.updatecursor' >
                <para>
                    Sets the item's body cursor this does two things:
                    First it allows several distinct sections of code to fill
                    in the body of an item without knowing what other sections
                    of code did.  Each section just asks for the current body
                    cursor, fills in its chunk of data and updates the body cursor
                    for the next chunk.  More importantly, however, the body
                    cursor tells the item's encapsulating object the extent of the
                    object's storage.
                </para>
            </callout>
            <callout arearefs='v11phys.setsize' >
                <para>
                    Uses the objects current body cursor to compute the size
                    of the object and stores that in the item's header.
                    The physics item is now completely filled in.  Later sections
                    will describe what we do with that item.
                </para>
            </callout>
        </calloutlist>
       </section>
        <section id='sec.factories' >
            <title id='sec.factories.title'>Factories.</title>
            <para>
                Factories are classes that create instances of other classes.
                Abstract factories are a family (inheritance hierarchy) of factory
                classes, where each factory instance createst instances of classes
                from parallel class hierarchies.  
            </para>
            <para>
                I Know the previous paragraph might sound a bit confusing.  Let's
                describe this in the concrete terms of how factories and the
                abstract factory pattern fit into this library:
            </para>
            <itemizedlist>
                <listitem>
                   <para>
                      We have a base class factory with an interface that describes
                      various ways to create different types of ring items.
                   </para>
                </listitem>
                <listitem>
                   <para>
                      For each supported version of NSCLDAQ we have a factory
                      which knows how to instantiate objects from the class
                      hierarchy that implement its own ring item data formats.
                   </para>
                </listitem>
                <listitem>
                   <para>
                      Finally, and this is slightly different from the classic
                      abstract factory pattern, we have a factory factory which,
                      given information about the version of NSCLDAQ being used
                      (either an explicit version number or, in the case of
                      versions 11 and higher a data format item), can give us an
                      instance of the correct factory to use for that version of NSCLDAQ.
                      <footnote>
                        <para>
                            Our use of the abstract factory pattern differs from the
                            classic presentation in that in the classic presentation,
                            there's a factory that makes use of specific factories for
                            the desired concrete set of objects.
                        </para>
                        <para>
                            For more on the abstract factory pattern as it is normally used,
                            see e.g.
                            <ulink url='https://en.wikipedia.org/wiki/Abstract_factory_pattern'>
                                this Wikipedia article.
                            </ulink>
                        </para>
                    </footnote>
                   </para>
                   <para>
                    Since all factories provide the same interface as the factory
                    base class, once we've selected the factory we're going to use,
                    we don't need to know anything about the NSCLDAQ version.
                    The same interface will be used for all versions to produce
                    ring item objects which support the same interface across
                    all versions.
                   </para>
                </listitem>
            </itemizedlist>
            <para>
                Before continuing with the next chapter, which describes abstract
                factories in detail, let's look at a simple example of using
                a concrete factory to build a physics
                item, as we did in the previous section:
            </para>
            <example>
                <title>Using Factories to Make a Physics Item for NSCLDAQ-11</title>
                <programlisting>
#include &lt;v11/RingItemFactory.h&gt;    <co id='v11fact.include' />
#include &lt;CPhysicsEventItem.h&gt;      <co id='v11fact.physics' />
#include &lt;memory&gt;                   <co id='v11fact.memory' />
...

v11::RingItemFactory fact;               <co id='v11fact.instance' />
std::unique_ptr&lt;::CPhysicsEventItem&gt; pItem(fact.makePhysicsEventItem()); <co id='v11fact.make' />

pItem-&gt;setBodyHeader(someTimestamp, someSourceId); 
uint16_t* pBody = reinterpret_cast&lt;uint16_t*&gt;(pItem-&gt;getBodyCursor); 
...
pItem-&gt;setBodyCursor(pBody);                   
pItem-&gt;updateSize();                          
...
            </programlisting>
            </example>
            <calloutlist>
                <callout arearefs='v11fact.include' >
                    <para>
                        In this example, we will, directly create a V11
                        ring item factory.  Therefore we need the header
                        for that class.  In the next chapter we'll seee how to
                        select an appropriate ring item factory if we only know the
                        correct version at run-time.
                    </para>
                </callout>
                <callout arearefs='v11fact.physics' >
                    <para>
                        Note that we include the header for the abstract
                        <classname>CPhysicsEventItem</classname>.  This is what
                        factories create.  This is the base class for the version specific
                        classes such as <classname>v11::CPhysicsEventItem</classname>.
                    </para>
                    <para>
                        We choose this class so that, once we've instantiated the
                        physics item using the appropriate factory, we no longer need
                        to know the version of NSCLDAQ we're operating with.
                    </para>
                </callout>
                <callout arearefs='v11fact.memory' >
                    <para>
                        This header, part of the C++ standard library, supplies, among other
                        things, smart pointer classes which can help avoid memory leaks.
                        Our factory classes produce dynamically allocated items.
                        Using e.g. <classname>std::unique_ptr</classname> can ensure
                        these objects are deleted.
                    </para>
                </callout>
                <callout arearefs='v11fact.instance' >
                    <para>
                        This line of code creates an instance of the
                        object factory for NSCLDAQ-11.  Since we use virtual
                        methods to support a polymorphic base class/subclass
                        class hierarchy, we need to have an object as virtual methods
                        cannot be static.
                    </para>
                </callout>
                <callout arearefs='v11fact.make' >
                    <para>
                        This line is a bit involved.  Let's look at it from the
                        inside out.  We ask the <varname>fact</varname>
                        object to create a new physics event item.  Since it is
                        an instance of a <classname>v11::RingItemFactory</classname>,
                        what well get is a pointer to a <classname>v11::CPhysicsEventItem</classname>
                        object returned as a pointer to its base class
                        <classname>::CPhysicsEventItem</classname>.
                    </para>
                    <para>
                        We use this to initialize a
                        <classname>std::unique_ptr&lt;::CPhysicsEventItem&gt;</classname>
                        object named <varname>pItem</varname>.  Once the unique
                        pointer is created it can be used exactly as if it were
                        a <classname>::CPhysicsEventItem*</classname>.  When we call methods
                        using this pointer like object, due to polymorphism the
                        NSCLDAQ-11 version of those methods will get called.
                    </para>
                    <para>
                        Once <varname>pItem</varname> goes out of scope, the item
                        it 'points to' will be deleted.  This includes going out
                        of scope due to an unhandled exception.
                    </para>
                    <para>
                        Once <varname>pItem</varname> is created it can be used
                        to fill in the body header and body of the item just as
                        we did in the example in the previous section.  The result,
                        since we used the V11 factory is a V11 Physics event item.
                    </para>
                    <para>
                        Note that the code which fills in the item, which may be
                        very far  from the code which selects the factory, does not
                        need to know that we are making items for NSCLDAQ-11.
                    </para>
                    <para>
                        You might wonder about the call to set the body header.  What
                        would happen if we'd chosen the <classname>v10::RingItemFactory</classname>
                        for our factory?  NSCLDAQ-10 items don't have body headers.
                        The implementation of <methodname>setBodyHeader</methodname>
                        for NSCLDAQ-10 item types is just a no-op which means that you
                        would wind up with a perfectly good NSCLDAQ-10 ring item.
                    </para>
                </callout>
            </calloutlist>
        </section>
    </chapter>
    <chapter id='ch.factories'>
       <title id='ch.factories.title'>Factories and the Abstract Factory Pattern</title>
       <para>
        In the last section of the previous chapter, we touched on the role factories
        play in the formatting library.  We'll look a bit deeper at the subject of
        abstract factories, factories and and important set of functions
        that allow you to select an appropriate factory at run time.
       </para>
       <para>
        We've seen that in the format library:
       </para>
       <itemizedlist>
        <listitem>
           <para>
              There is a factory base class that establishes the interfaces
              that version specific factories must implement.  This is an
              abstract base class called <classname>RingItemFactoryBase</classname>.
           </para>
        </listitem>
        <listitem>
           <para>
              Each supported format version has a concrete instance of this
              factory.  Normally these are called
              <classname>v<replaceable>nn</replaceable>::RingItemFactory</classname>
              where <replaceable>nn</replaceable> is the NSCLDAQ version for which
              that factory creates items (e.g. <classname>v11::RingItemFactory</classname>
              makes ring items for NSCLDAQ-11).
           </para>
           <para>
            Each factory implements the base class interface. This means that
            once you have a pointer or reference to a factory in your possession, you
            can treat it as a generic <classname>RingItemFactoryBase</classname>
            object and polymorphism will take care of the rest without your
            code needing to be aware of the actual factory you are using.
           </para>
        </listitem>
       </itemizedlist>
       <para>
        In addition to these concepts, the format factory implements a set of
        functions that can be used to get a reference to an
        <emphasis>appropriate</emphasis> factory object.  This can be done either
        by passing a version designator or  passing a <classname>::CDataFormat</classname>
        object by reference.  In NSCLDAQ-11 and later, these objects contain
        information about the version of NSCLDAQ that produced them.  In an event
        file or stream of online events, these indicate the format of the data
        to follow.
       </para>
       <para>
        In the next example, we'll produce the same physics event item we've been
        producing in our earlier examples but we'll select the factory at runtime
        using a version designator.  In the example, the version designator is
        hard coded but could be computationally determined (e.g. passed into the
        program form the command line)
       </para>
       <example>
        <title>Using a Version Designator to Construct a Ring Item Factory:</title>
        <programlisting>
#include &lt;NSCLDAQFormatFactorySelector.h&gt;
#include &lt;RingItemFactoryBase.h&gt;    <co id='select.headers' />
#include &lt;CPhysicsEventItem.h&gt;
#include &lt;memory&gt;
..

::RingItemFactoryBase&amp; fact(FormatSelector::selectFactory(FormatSelector::v11)); <co id='select.select' />
std::unique_ptr&lt;::CPhysicsEventItem&gt; pItem(fact.makePhysicsEventItem());  <co id='select.makeitem' />
                                                                  <co id='select.fillbody' />
pItem-&gt;setBodyHeader(someTimestamp, someSourceId); 
uint16_t* pBody = reinterpret_cast&lt;uint16_t*&gt;(pItem-&gt;getBodyCursor); 
...
pItem-&gt;setBodyCursor(pBody);                   
pItem-&gt;updateSize();                          
...

        </programlisting>
       </example>
       <calloutlist>
        <callout arearefs='select.headers' >
            <para>
                Includes the headers we need. Note that none of them are
                version specific.  This is the value aded by using the
                factory selector defined in
                <filename>NSCLDAQFormatFactorySelector.h</filename>.
                <filename>RingItemFactoryBase.h</filename> defines the abstract
                base class that establishes the factory API.
            </para>
        </callout>
        <callout arearefs='select.select' >
            <para>
                This call has a lot to unwrap.  Again let's start from the
                inside and work our way out.  <methodname>FormatSelector::selectFactory</methodname>
                is a family of functions that return references to factory objects.
                This version is parameterized by an explicit version designator
                <literal>FormatSelector::v11</literal> (version 11).
            </para>
            <para>
                The selection functions maintain a memory of the factories they've
                produced.  If, in a later section of code you ask for a factory
                for the same version; you'll get a reference to the same factory
                object.  This implies that the selection subsystem maintains ownership
                of the factories it produces and your code must not delete factories
                it receives.
            </para>
            <para>
                The resulting reference is used to initialize a reference to a
                <classname>::RingItemFactoryBase</classname> object.  Using a reference
                maintains the association between virtual functions and the
                implementations provided by the factory returned from
                <methodname>FormatSelector::selectFactory</methodname>.
                This calling methods on this reference will, actually, call methods on the
                <classname>v11::RingItemFactory</classname> that
                <methodname>FormatSelector::selectFactory</methodname> returned.
            </para>
        </callout>
        <callout arearefs='select.makeitem' >
            <para>
                As before, we use the factory to make a physics event item.
                The  pointer to the resulting dynamically allocated item
                initializes a <classname>std::unique_ptr</classname> so that
                the delete of that object is automatic when th smart pointer like
                object goes out of scope.
            </para>
        </callout>
        <callout arearefs='select.fillbody' >
            <para>
                The remainder of the code in this example is identical
                to the code used to fill in the physics item bodies of the
                previous examples in this document.
            </para>
        </callout>
       </calloutlist>
       <para>
        The key point in this is that the only point in time where
        we used knowledge of the DAQ version is when we called
        <methodname>FormatSelector::selectFactory</methodname>
        passing in the version format selector.
       </para>
       <para>
        Beginning with NSCLDAQ-11, prior to the begining of each run and,
        at the beginning of each event file a data format item is written which
        indicates the format of the data that follows.  There is a format selector
        item that can be passed a reference to an encapsulated data format item
        to provide the correct format factory for that format item.
       </para>
       <para>
        This does provide a bit of a chicken and egg problem...given a raw ring item,
        how do you get a data format item.  In the code that follows, we'll start
        with an undifferentiated <classname>::CRingItem</classname> and try to
        see if it represents a ring format item.  We'll then use the fact that
        we're guaranteed that ring format items look the same in all
        versions of NSCLDAQ that support them.
       </para>
       <example>
        <title>Using ring format items to select a format factory</title>
        <programlisting>
#include &lt;NSCLDAQFormatFactorySelector.h&gt;
#include &lt;RingItemFactoryBase.h&gt; 
#include &lt;CRingItem.h&gt;
#include &lt;CRingFormatItem.h&gt;    <co id='fmt.formatitem' />
#include &lt;memory&gt;
#include &lt;DataFormat.h&gt;         <co id='fmt.dataformat' />

static enum FormatSelector::SupportedVersions defaultVersion(FormatSelector::v10); <co id='fmt.defaultfmt' />
...
:RingItemFactoryBase* pFactory(0);

std::unique_ptr&lt;::CRingItem&gt; item(getRingItem());  <co id='fmt.getitem' />
if (item-&gt;type() == RING_FORMAT) {                    <co id='fmt.isformat' />
    ::CRingFormatItem* pFormatItem =
        reinterpret_cast&lt;::CRingFormatItem*&gt;(item.get()); <co id='fmt.cast' />
    pFactory = &amp;(FormatSelector::selectFactory(*pFormatItem)); <co id='fmt.selectfromitem' />
} else {
    pFactory = &amp;(FormatSelector::selectFactory(defaultVersion)); <co id='fmt.selectdefault' />
}

::RingItemFactoryBase&amp; fact(*pFactory);               <co id='fmt.makereference' />

...

        </programlisting>
       </example>
       <para>
        There's a lot to unpack in this fragment of code and some of it is a bit
        sneaky.  Therefore let's look at this code very carefully.
       </para>
       <calloutlist>
        <callout arearefs='fmt.formatitem' >
          <para>
            We'll need to use the definitions of the
            <classname>CRingFormatItem</classname> so we include it's header here.
          </para>
        </callout>
        <callout arearefs='fmt.dataformat' >
            <para>
                The <filename>DataFormat.h</filename> file provides
                format definitions for each of the supported data formats.
                In this case, we pull in the data format from the abstract
                directory.  The main thing we want here is the ring item type
                definitions which, for the most part, are stable across versions.
            </para>
        </callout>
        <callout arearefs='fmt.defaultfmt' >
            <para>
                We store the default format type in a variable.  You might imagine
                that processing in the omitted code could modify this.   Version
                10 is a reasonable default because there isn't a data format item
                for that version.
            </para>
        </callout>
        <callout arearefs='fmt.getitem' >
            <para>
                This line just uses some function we dreamed out
                <function>getRingItem</function> to return a pointer
                to a dynamically allocated ring item gotten somehow.
                We initialize a unique_ptr as usual to ensure destruction.
            </para>
        </callout>
        <callout arearefs='fmt.isformat' >
            <para>
                Asks the item we got for its item type.  The type is checked
                against <literal>RING_FORMAT</literal> which is defined in
                <filename>DataFormat.h</filename>.  This is the type value
                for items that contain ring item formatting information.
            </para>
        </callout>
        <callout arearefs='fmt.cast' >
            <para>
                This line is a bit tricky.  It uses the fact that the specific
                ring item classes just wrap data containing the raw ring item.
                It further uses the fact that the format of a data format item
                is fixed over all versions that support it.  The result is therefore
                a pointer to the same wrapped object but treated as a
                data format item that knows how to interrrogate the underlying
                data to extract the format.
            </para>
        </callout>
        <callout arearefs='fmt.selectfromitem' >
            <para>
                This version of <methodname>FormatSelector::selectFactory</methodname>
                uses a reference to the format item to obtain and pass back
                a reference to the factory implied by the data format item.
                There's a bit of trickiness here as well.  We're passed back
                a reference and that's, in the end, what we want, but references
                can only be initialized.  They can't be assigned.
                Therefore, we accept the factory as a pointer and store it away
                in a pointer with a scope outside the if bodies.
            </para>
        </callout>
        <callout arearefs='fmt.selectdefault' >
            <para>
                If the item was not a format item we just create the factory
                corresponding to the default format type.
            </para>
        </callout>
        <callout arearefs='fmt.makereference' >
            <para>
                When we get to this point in the program, the factory pointer has
                a non null value.  We initialize the reference <varname>fact</varname>
                to refer to what our factory pointer points to.   Once all this is done
                we can continue processing data.
            </para>
        </callout>
       </calloutlist>
       <para>
        The key take away from this example is that we can produce an appropriate
        object factory without actually knowing the version of NSCLDAQ that
        produced the data we're processing; if the streamof data we're processing
        has a format item (comes from NSCLDAQ-11 or later).
       </para>
    </chapter>
    <chapter id='ch.reference'>
       <title id='ch.reference.title'>Reference pages</title>
       <para>
        The reference pages here take into consideration both the organization
        of the library and the order in which classes are likely to be used
        in a program.  Thus we start with a section that has reference material
        for the factory selector functions the abstract factory and the the abstract
        format classes that determine the functionality all other format classes
        have.
       </para>
       <para>
        Subsequent sections provide reference material for the version 10, version 11
        and version 12 factories and format classes.
       </para>
       <section>
        <title>Abstract Formatting</title>
        <refentry>
           <refmeta>
              <refentrytitle>Format Selector</refentrytitle>
              <manvolnum>3format</manvolnum>
           </refmeta>
           <refnamediv>
              <refname>Format Selector</refname>
              <refpurpose>Select Specific Format Factory</refpurpose>
            </refnamediv>
            <refsynopsisdiv>
                <programlisting>
#include &lt;NSCLDAQFactorySelector.h&gt;

namespace FormatSelector {
    enum SupportedVersions {v10, v11, v12};

    RingItemFactoryBase&amp; selectFactory(SupportedVersions version);
    RingItemFactoryBase&amp; selectFactory(CDataFormatItem&amp; item);


}


                </programlisting>
            </refsynopsisdiv>
            <refsect1>
                     <title>DESCRIPTION</title>
                  <para>
                    The definitions in the <literal>FormatSelector</literal>
                    namespace provide mechnisms to select  specific format factory
                    either from an explicit format specifier or from a data format item.
                    Note that data format items appear in NSCLDAQ-11 and later.
                  </para>
                  <para>
                    The format factories instantiated by these functions are cached
                    for later lookup.  This implies that:
                  </para>
                  <orderedlist>
                    <listitem>
                       <para>
                          Ownership of the factories continues to reside with this
                          module.  Deleting a factory returned from this API
                          will result in undefined, possibly fatal, behavior.
                       </para>
                    </listitem>
                    <listitem>
                       <para>
                          Several attempts to get a factory reference for the same
                          format version will return references to the same factory
                          instance.
                       </para>
                    </listitem>
                  </orderedlist>
            </refsect1>
            <refsect1>
                <title>DATA TYPES</title>
                <para>
                    The <type>FormatSelector::SupportedVersions</type> enum
                    is a type that is used as an NSCLDAQ version selector.
                </para>
            </refsect1>
            <refsect1>
                <title>API</title>
                <para>
                    Note that while all functions live in the
                    <literal>FormatSelector</literal> namespace
                    this is not shown in the function list below for the sake
                    of brevity.
                </para>
                <variablelist>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>::RingItemFactoryBase&amp;</type>
                           <methodname>selectFactory</methodname>
                           <methodparam>
                               <type>SupportedVersions</type><parameter>version</parameter>
                           </methodparam>
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Returns a reference to a ring item factory that is
                            suitable for creatig ring items for the NSCLDAQ
                            version selected by <parameter>version</parameter>.
                            The factory continues to be owned by the selection
                            subsystem and must <emphasis>not</emphasis> be deleted
                            by the caller.
                           </para>
                           <para>
                            A cache of factories ensures that several attempts
                            to obtain a factory for the same version will return
                            references to the same factory.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>::RingItemFactoryBase&amp; </type>
                           <methodname>selectFactory</methodname>
                           <methodparam>
                               <type>CDataFormatItem&amp;</type><parameter> item</parameter>
                           </methodparam>
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Given a reference to a data format item from any
                            version of NSCLDAQ that can produce these, provides
                            a factory for the version of NSCLDAQ indicated by that
                            item.  This wraps the prior overload for
                            <methodname>selectFactory</methodname> so everything
                            described above about the returned reference holds for
                            this one.
                           </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
                <para>
                    If a version is selected which is somehow not supported,
                    <classname>std::invalid_argument</classname> is thrown by
                    the <methodname>selectFactoryMethods</methodname> above.
                </para>
            </refsect1>
            
        </refentry>
        <refentry>
           <refmeta>
              <refentrytitle>RingItemFactoryBase</refentrytitle>
              <manvolnum>3format</manvolnum>
           </refmeta>
           <refnamediv>
              <refname>RingItemFactoryBase</refname>
              <refpurpose>Provide interface for ring item factoires.</refpurpose>
            </refnamediv>
            <refsynopsisdiv>
                <programlisting>
#include &lt;RingItemFactoryBase.h&gt;

class RingItemFactoryBase {
public:
    virtual CRingItem* makeRingItem(uint16_t type, size_t maxBody) = 0;
    virtual CRingItem* makeRingItem(uint16_t type, uint64_t timestamp, uint32_t sourceId,
            size_t maxBody, uint32_t barrierType = 0 ) = 0;
    virtual CRingItem* makeRingItem(const CRingItem&amp; rhs) = 0;
    virtual CRingItem* makeRingItem(const RingItem* pRawRing) = 0;


    virtual CRingItem* getRingItem(CRingBuffer&amp; ringbuf) = 0;
    virtual CRingItem* getRingItem(int fd) = 0;
    virtual CRingItem* getRingItem(std::istream&amp; in) = 0;

    virtual std::ostream&amp; putRingItem(const CRingItem* pItem, std::ostream&amp; out) = 0;
    virtual void putRingItem(const CRingItem* pItem, int fd) = 0;
    virtual void putRingItem(const CRingItem* pItem, CRingBuffer&amp; ringbuf) = 0;

    virtual CAbnormalEndItem* makeAbnormalEndItem() = 0;
    virtual CAbnormalEndItem* makeAbnormalEndItem(const CRingItem&amp; rhs) = 0;

    virtual CDataFormatItem* makeDataFormatItem() = 0;
    virtual CDataFormatItem* makeDataFormatItem(const CRingItem&amp; rhs) = 0;

    virtual CGlomParameters* makeGlomParameters(
        uint64_t interval, bool isBuilding, uint16_t policy
    )  = 0;
    virtual CGlomParameters* makeGlomParameters(const CRingItem&amp; rhs) = 0;

    virtual CPhysicsEventItem* makePhysicsEventItem(size_t maxBody) = 0;
    virtual CPhysicsEventItem* makePhysicsEventItem(
        uint64_t timestamp, uint32_t source, uint32_t barrier, size_t maxBody
    ) = 0;
    virtual CPhysicsEventItem* makePhysicsEventItem(const CRingItem&amp; rhs) = 0;

    virtual CRingFragmentItem* makeRingFragmentItem(
        uint64_t timestamp, uint32_t source, uint32_t payloadSize,
        const void* payload, uint32_t barrier=0
    ) = 0;
    virtual CRingFragmentItem* makeRingFragmentItem(const CRingItem&amp; rhs) = 0;


    virtual CRingPhysicsEventCountItem* makePhysicsEventCountItem(
        uint64_t count, uint32_t timeoffset, time_t stamp,
    int divisor=1
    ) = 0;
    virtual CRingPhysicsEventCountItem* makePhysicsEventCountItem(const CRingItem&amp; rhs) = 0;

    virtual CRingScalerItem* makeScalerItem(size_t numScalers) = 0;
    virtual CRingScalerItem* makeScalerItem(
        uint32_t startTime,
        uint32_t stopTime,
        time_t   timestamp,
        std::vector&lt;uint32_t&gt; scalers,
        bool                  isIncremental = true,
        uint32_t              sid = 0,
        uint32_t              timeOffsetDivisor = 1
    ) = 0;
    virtual CRingScalerItem* makeScalerItem(const CRingItem&amp; rhs) = 0;

    virtual CRingTextItem* makeTextItem(
        uint16_t type,
                std::vector&lt;std::string&gt; theStrings
    ) = 0;
    virtual CRingTextItem* makeTextItem(
        uint16_t type,
                std::vector&lt;std::string&gt; theStrings,
                uint32_t                 offsetTime,
                time_t                   timestamp, uint32_t divisor=1
    ) = 0;
    virtual CRingTextItem* makeTextItem(const CRingItem&amp; rhs) = 0;

    virtual CUnknownFragment* makeUnknownFragment(
        uint64_t timestamp, uint32_t sourceid, uint32_t barrier,
        uint32_t size, void* pPayload
    ) = 0;
    virtual CUnknownFragment* makeUnknownFragment(const CRingItem&amp; rhs) = 0;

    virtual CRingStateChangeItem* makeStateChangeItem(
        uint32_t itemType, uint32_t runNumber,
        uint32_t timeOffset,
        time_t   timestamp,
        std::string title
    ) = 0;
    virtual CRingStateChangeItem* makeStateChangeItem(const CRingItem&amp; rhs) = 0;

};


                </programlisting>
            </refsynopsisdiv>
            <refsect1>
                     <title>DESCRIPTION</title>
                  <para>
                    The <classname>CRingItemFactoryBase</classname> class provides
                    an abstract base class for the ring item factories implemented
                    by version specific libraries.  Note that specific return classes
                    defined as forward classes in the header and, therefore,
                    you need to <literal>#include</literal> the specific ring item
                    classes you need to actually use.
                  </para>
                  <para>
                    All return values are  pointers to dynamically allocated
                    objects.  These objects are owned by the caller and must be
                    deleted by the caller when no longer needed.  The return pointer
                    types are from the abstract library, however the actual return
                    types from any version specific factory will be objects of
                    the correct version's library.  
                  </para>
                  <para>
                    Since storage management can be difficult, users are encouraged
                    to use these methods to initialize smart pointer objects
                    such as <classname>std::unique_ptr</classname> or
                    <classname>std::shared_ptr</classname> to ensure that these
                    objects are, in fact, properly managed.
                  </para>
            </refsect1>
            <refsect1>
                <title>METHODS</title>
                <para>
                    Note that all public methods are pure virtual and must be
                    implemented by any concrete version specific factory.
                </para>
                <variablelist>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual CRingItem*</type>
                           <methodname> makeRingItem</methodname>
                           <methodparam>
                               <type>uint16_t </type><parameter>type</parameter>
                           </methodparam>
                           <methodparam>
                               <type>size_t </type><parameter>maxBody</parameter>
                           </methodparam>
                            
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Creates an undifferentiated ring item.  The
                            storage should be sufficient to hold
                            <parameter>maxBody</parameter> bytes of data.
                            The ring item header should be initialized such
                            that its type is <parameter>type</parameter>.
                           </para>
                           <para>
                            The precise initialization of the remainder of the
                            ring item's storage is implementation dependent.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual CRingItem* </type>
                           <methodname>makeRingItem</methodname>
                           <methodparam>
                               <type>uint16_t </type><parameter>type</parameter>
                           </methodparam>
                           <methodparam>
                               <type>uint64_t </type><parameter>timestamp</parameter>
                           </methodparam>
                           <methodparam>
                               <type>uint32_t </type><parameter>sourceId</parameter>
                           </methodparam>
                            <methodparam>
                                <type>size_t </type><parameter>maxBody</parameter>
                            </methodparam>
                            <methodparam>
                                <type>uint32_t </type><parameter>barrierType</parameter>
                                <initializer>0</initializer>
                            </methodparam>
                             
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            As before but also provides the body header parameters:
                            <parameter>timestamp</parameter>, which will be used
                            as the event timestamp in any body header,
                            <parameter>sourceId</parameter> which will be used
                             as the item's source id and
                             <parameter>barrierType</parameter> which is an optional
                             parameter that specifies the barrier type.  This defaults
                             to zero as that's the most common
                           </para>
                           <para>
                            The implementation of this method shall be equivalent
                            to:
                           </para>
                           <informalexample>
                            <programlisting>
std::auto_ptr&lt;::CRingItem&gt; pItem(fact.makeRingItem(type, maxbody));
pItem->setBodyHeader(timestamp, sourceId, barrierType);
                            </programlisting>
                           </informalexample>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual CRingItem*</type>
                           <methodname> makeRingItem</methodname>
                           <methodparam>
                               <type>const CRingItem&amp; </type><parameter>rhs</parameter>
                           </methodparam>
                            
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Makes a new ring item that is a copy of the
                            ring item that is referenced by the
                            <parameter>rhs</parameter>.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual CRingItem* </type>
                           <methodname>makeRingItem</methodname>
                           <methodparam>
                               <type>const RingItem* </type><parameter>pRawRing</parameter>
                           </methodparam>
                            
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Copies the contents of <parameter>pRawRing</parameter>
                            into local storage of a new ringitem object.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual CRingItem* </type>
                           <methodname>getRingItem</methodname>
                           <methodparam>
                               <type>CRingBuffer&amp; </type><parameter>ringbuf</parameter>
                           </methodparam>
                            
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Givena reference to an NSCLDAQ
                            <type>CRingBuffer</type> object that is created
                            as a consumer; consumes a raw ring item from that
                            ringbuffer encapsulating it in a
                            <classname>CRingItem</classname>.
                           </para>
                           <para>
                            Note that ringbuffers and ring items are such that
                            the actual NSCLDAQ library version used does not matter much
                            in the execution of this method.  
                           </para>
                           <para>
                            If a complete ring item is not yet available for
                            this consumer <parameter>ringbuf</parameter>,
                            the calling program will block until one is.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual CRingItem* </type>
                           <methodname>getRingItem</methodname>
                           <methodparam>
                               <type>int </type><parameter>fd</parameter>
                           </methodparam>
                            
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Consumes a ring item from the file descriptor
                            <parameter>fd</parameter> and wraps it in a
                            new <classname>CRingItem</classname> object.
                            If the file descriptor is e.g. a pipe and no
                            ring item is available, this will block.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual CRingItem* </type>
                           <methodname>getRingItem</methodname>
                           <methodparam>
                               <type>std::istream&amp; </type><parameter>in</parameter>
                           </methodparam>
                            
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Consumes a raw ring item from the stream
                            <parameter>in</parameter> wraps it up in a new
                            <classname>CRingBuffer</classname> class, returning
                            a pointer to that object.  If <parameter>in</parameter>
                            is e.g. a pipe and no object is available, the program
                            will block until one is seen.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual std::ostream&amp; </type>
                           <methodname>putRingItem</methodname>
                           <methodparam>
                               <type>const CRingItem*</type><parameter> pItem</parameter>
                           </methodparam>
                           <methodparam>
                               <type>std::ostream&amp; </type><parameter>out</parameter>
                           </methodparam>
                            
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Puts the encapsulated ring item
                            pointed to by <parameter>pItem</parameter> to the C++
                            output stream <parameter>out</parameter>.  A reference
                            to the stream after the output is returned.
                           </para>
                           <para>
                            The ring itme is output in raw format.  This allows
                            <methodname>getRingItem</methodname> to reconstruct
                            the ring item.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual void </type>
                           <methodname>putRingItem</methodname>
                           <methodparam>
                               <type>const CRingItem* </type><parameter>pItem</parameter>
                           </methodparam>
                           <methodparam>
                               <type>int </type><parameter>fd</parameter>
                           </methodparam>
                            
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Outputs the ring item pointed to by
                            <parameter>pItem</parameter> to whatever
                            the file descriptor <parameter>fd</parameter>
                            is open on.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual void </type>
                           <methodname>putRingItem</methodname>
                           <methodparam>
                               <type>const CRingItem* </type><parameter>pItem</parameter>
                           </methodparam>
                           <methodparam>
                               <type>CRingBuffer&amp;</type><parameter> ringbuf</parameter>
                           </methodparam>
                            
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Puts the raw ring item encapsulated in
                            <parameter>pItem</parameter> into the ring buffer
                            refrenced by <parameter>ringbuf</parameter>.
                            <parameter>ringbuf</parameter> must have been created
                            
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual CAbnormalEndItem* </type>
                           <methodname>makeAbnormalEndItem()</methodname>
                           <void />
                            
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Creates an abnormal end ring item type.  This is
                            used by versions of NSCLDAQ to flag a run that was not
                            properly ended.  If this item type cannot be
                            created <literal>nullptr</literal> must be returned.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual CAbnormalEndItem* </type>
                           <methodname>makeAbnormalEndItem</methodname>
                           <methodparam>
                               <type>const CRingItem&amp; </type><parameter>rhs</parameter>
                           </methodparam>
                            
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Given an undifferentiated ring item reference,
                            <parameter>rhs</parameter>, creates the equivalent
                            <classname>CAbnormalEndItem</classname>. Note that if
                            this is not possible (e.g. because <parameter>rhs</parameter>
                            is not an abnormal end item or because the version of
                            NSCLDAQ format in the concrete implementation does not
                            yet support <classname>CAbnormalEndItem</classname>s,
                            <classname>std::bad_cast</classname> must be thrown.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual CDataFormatItem* </type>
                           <methodname>makeDataFormatItem</methodname>
                           <void />                            
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Creates and returns a pointer to a data format
                            item for the format represented by the concrete
                            factory.  If the version represented by the concrete
                            factory does not support data format items,
                            this method must return <literal>nullptr</literal>
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual CDataFormatItem* </type>
                           <methodname>makeDataFormatItem</methodname>
                           <methodparam>
                               <type>const CRingItem&amp;</type><parameter> rhs</parameter>
                           </methodparam>
                            
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Given an undifferentiated ring item;
                            <parameter>rhs</parameter>, an equivalent
                            <classname>CDataFormatItem</classname> object is
                            created and a pointer to it returned.
                            If <parameter>rhs</parameter> is not a data format
                            item, or data format items are not supported by the
                            concreate implementation the implementation must
                            throw <classname>std::bad_cast</classname>.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual CGlomParameters*</type>
                           <methodname> makeGlomParameters</methodname>
                           <methodparam>
                               <type>uint64_t </type><parameter>interval</parameter>
                           </methodparam>
                           <methodparam>
                               <type>bool </type><parameter>isBuilding</parameter>
                           </methodparam>
                           <methodparam>
                               <type>uint16_t </type><parameter>policy</parameter>
                           </methodparam>
                            
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Creates and returns a pointer to a
                            <classname>CGlomParameters</classname> item described
                            by its parameters.  If the underlying format does not
                            support glom parameter items, <literal>nullptr</literal>
                            must be returned.
                           </para>
                           <para>
                            Glom is the component of the event builder that
                            glues events together from a totally time ordered stream
                            of event fragments.  If <parameter>isBuilding</parameter>
                            is true, glom is building events and not running in the
                            test mode in which it just emits fragments without
                            bothering to build them.  When building, fragments
                            are built if they all fit in the timestamp window
                            defined by <parameter>interval</parameter>.  The units
                            of this are dependent on the application and simply
                            represent timestamp ticks.  
                           </para>
                           <para>
                            <parameter>policy</parameter>
                            is an integer that describes how output event timestamps
                            are created from the fragment timestamps in an event.
                            Constants in <filename>DataFormat.h</filename> describe
                             the legal values for this parameter which are:
                           </para>
                           <itemizedlist>
                            <listitem>
                               <para>
                                  <emphasis>GLOM_TIMESTAMP_FIRST</emphasis>  -
                                  The event timestamp is taken from the timestamp
                                  of its first, earliest, fragment.
                               </para>
                            </listitem>
                            <listitem>
                               <para>
                                  <emphasis>GLOM_TIMESTAMP_LAST</emphasis>  -
                                  The event timestamp is taken from the timestamp
                                  of its last, latest, fragment.
                               </para>
                            </listitem>
                            <listitem>
                               <para>
                                  <emphasis>GLOM_TIMESTAMP_AVERAGE</emphasis>  -
                                  the timestamp is computed from the average of
                                  all fragment timestamps in the event.
                               </para>
                            </listitem>
                           </itemizedlist>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual CGlomParameters* </type>
                           <methodname>makeGlomParameters</methodname>
                           <methodparam>
                               <type>const CRingItem&amp; </type><parameter>rhs</parameter>
                           </methodparam>
                            
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            If <parameter>rhs</parameter> references a
                            glom parameters item returns a newly created,
                            equivalent <classname>CGomParameters</classname> object's
                            pointer.   If <parameter>rhs</parameter> is not a glom
                            parameters object or if the concrete implementation does
                            not yet support items of that time,
                            <classname>std::bad_cast</classname> must be thrown.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual CPhysicsEventItem* </type>
                           <methodname>makePhysicsEventItem</methodname>
                           <methodparam>
                               <type>size_t </type><parameter>maxBody</parameter>
                           </methodparam>
                            
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Creates a new physics event item. <parameter>maxBody</parameter>
                            sets the maximum size event body that will be filled in.
                            It is used to reserve space into which the ring item will
                            be formatted.  The return value is a pointer to a newly
                            created physics event item object.
                           </para>
                           <para>
                            If the underlying format of the concrete factory
                            supports body headers, this item will not be
                            created with a body header.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual CPhysicsEventItem*</type>
                           <methodname> makePhysicsEventItem</methodname>
                           <methodparam>
                               <type>uint64_t </type><parameter>timestamp</parameter>
                           </methodparam>
                           <methodparam>
                               <type>uint32_t</type><parameter> source</parameter>
                           </methodparam>
                           <methodparam>
                               <type>uint32_t </type><parameter>barrier</parameter>
                           </methodparam>
                           <methodparam>
                               <type>size_t </type><parameter>maxBody</parameter>
                           </methodparam>
                            
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Makes a physics event item with a body header
                            (if supported by the concrete format).  IF body headers
                            are not supported the implementation should just invoke
                            the prior creational method.
                           </para>
                           <para>
                            As before, <parameter>maxBody</parameter> determines
                            the maximum body size of the item.  The remaining
                            parameter determine the contents of the body header:
                            <parameter>timestamp</parameter> is the Event/fragment
                            timestamp, <parameter>source</parameter> is the Event/fragment
                            source id and <parameter>barrier</parameter> is the event/fragment's
                            barrier type.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual CPhysicsEventItem* </type>
                           <methodname>makePhysicsEventItem</methodname>
                           <methodparam>
                               <type>const CRingItem&amp;</type><parameter> rhs</parameter>
                           </methodparam>
                            
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Given <parameter>rhs</parameter> a reference to a
                            ring item that actually contains a physics event,
                            creates a new ring item of type <classname>CPHysicsEventItem</classname>
                            that is a functional equivalent of <parameter>rhs</parameter>
                            and returns a pointer to that item.
                           </para>
                           <para>
                            If <parameter>rhs</parameter> is not, in fact,
                            a physics event item, this method throws
                            <classname>std::bad_cast</classname>.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual CRingFragmentItem* </type>
                           <methodname>makeRingFragmentItem</methodname>
                           <methodparam>
                               <type>   uint64_t </type><parameter>timestamp</parameter>
                           </methodparam>
                           <methodparam>
                               <type> uint32_t </type><parameter>source</parameter>
                           </methodparam>
                           <methodparam>
                               <type>uint32_t </type><parameter>payloadSize</parameter>
                           </methodparam>
                           <methodparam>
                               <type>const void* </type><parameter>payload</parameter>
                           </methodparam>
                           <methodparam>
                               <type>uint32_t </type><parameter>barrier</parameter>
                               <initializer>0</initializer>
                           </methodparam>
                            
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            A <classname>CRingFragmentItem</classname> represents
                            an event fragment whose payload is a ring item.
                            The fragment itself looks like a ring item and has an
                            obligatory body header. The body header is followed by
                            a payload which, for this type is assumed to be another
                            ring item.
                           </para>
                           <para>
                            The contents of the obligatory body header are defined by
                            <parameter>timestamp</parameter>, the fragment timestamp,
                            <parameter>source</parameter>, the fragment source id and
                            <parameter>barrier</parameter>, the optional barrier type.
                            If not provided <parameter>barrier</parameter> defaults to
                            zero which is no barrier.
                           </para>
                           <para>
                            The payload is defined by
                            <parameter>paylaodSize</parameter> which is the number
                            of bytes in the payload and <parameter>payload</parameter>
                            which points to the payload itself.
                           </para>
                           <para>
                            The return value is a pointer to a new created
                            <classname>CRingFragmentItem</classname>.
                            If the concrete factory is of a format that does not
                            support <classname>CRingFragmentItem</classname> object
                            (does not implement the ring fragment raw ring item),
                            a <literal>nullptr</literal> must be returned.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual CRingFragmentItem* </type>
                           <methodname>makeRingFragmentItem</methodname>
                           <methodparam>
                               <type>const CRingItem&amp; </type><parameter>rhs</parameter>
                           </methodparam>
                            
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            If <parameter>rhs</parameter> references a
                            <classname>CRingItem</classname> whose contents are
                            a fragment item, this method creates a new
                            <classname>CRingFragmentItem</classname>, fills it with
                            the contents of the <parameter>rhs</parameter> and
                            returns a pointer to the new item.
                           </para>
                           <para>
                            If <parameter>rhs</parameter> is not a ring fragment item
                            or the version of NSCLDAQ used by the concrete factory
                            does not support <classname>CRingFragmentItem</classname>s,
                            <classname>std::bad_cast</classname> must be thrown.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual CRingPhysicsEventCountItem* </type>
                           <methodname>makePhysicsEventCountItem</methodname>
                           <methodparam>
                               <type>uint64_t </type><parameter>count</parameter>
                           </methodparam>
                           <methodparam>
                               <type>uint32_t </type><parameter>timeoffset</parameter>
                           </methodparam>
                           <methodparam>
                               <type>time_t </type><parameter>stamp</parameter>
                           </methodparam>
                           <methodparam>
                               <type>int </type><parameter>divisor</parameter>
                               <initializer>1</initializer>
                           </methodparam>
                            
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            A physics event count item represents the number of
                            event triggers on a data source. This can be used
                            online analysis programs to know the fraction of the
                            data they are able to analyze.
                           </para>
                           <para>
                            <parameter>count</parameter> is the total number
                            of triggers this run.  <parameter>timeoffset</parameter>
                            is the time offset into the run at which the number
                            of triggers represents.  <parameter>divisor</parameter>,
                            if supplied indicates the number of timeoffset ticks
                            in a second.  This allows for run offsets to be represented
                            with sub-second resolution.  The <parameter>stamp</parameter>
                            parameter represents the clock time at which the item was created.
                           </para>
                           <para>
                            All versions of NSCLDAQ since version 10 (the lowest
                            version we attempt to handle in this library) support
                            event count items.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual CRingPhysicsEventCountItem* </type>
                           <methodname>makePhysicsEventCountItem</methodname>
                           <methodparam>
                               <type>const CRingItem&amp;</type><parameter> rhs</parameter>
                           </methodparam>
                            
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            If the contents of <parameter>rhs</parameter> are a
                            physics event count raw item, this method creates a new
                            <classname>CRingPhysicsEventCountItem</classname> object
                            to wrap a copy of the item in <parameter>rhs</parameter> and
                            returns a pointer to that object.
                           </para>
                           <para>
                            If <parameter>rhs</parameter> is not encapsulating an
                            event count item; <classname>std::bad_cast</classname>
                            is thrown.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual CRingScalerItem* </type>
                           <methodname>makeScalerItem</methodname>
                           <methodparam>
                               <type>size_t </type><parameter>numScalers</parameter>
                           </methodparam>
                            
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Creates a new scaler item and returns a pointer to it.
                            Object methods can be used to modify the contents of the
                            item.   The item is sized for <parameter>numScalers</parameter>
                            32 bit scalers.  The clock timestamp for the item
                            is its creation time. The counting interval is initialized
                            to from zero to zero and the time divisor is initialized to
                            1.
                           </para>
                           <para>
                            For formats that support a body header, this item
                            should be created with no body header.   A full
                            body header can, of course, be added with
                            the object's <methodname>setBodyHeader</methodname>.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual CRingScalerItem* </type>
                           <methodname>makeScalerItem</methodname>
                           <methodparam>
                               <type>uint32_t </type><parameter>startTime</parameter>
                           </methodparam>
                           <methodparam>
                               <type>uint32_t </type><parameter>stopTime</parameter>
                           </methodparam>
                           <methodparam>
                               <type>time_t   </type><parameter>timestamp</parameter>
                           </methodparam>
                           <methodparam>
                               <type>std::vector&lt;uint32_t&gt; </type><parameter>scalers</parameter>
                           </methodparam>
                           <methodparam>
                               <type>bool </type><parameter>isIncremental </parameter>
                               <initializer>true</initializer>
                           </methodparam>
                           <methodparam>
                               <type>uint32_t </type><parameter>sid</parameter>
                               <initializer>0</initializer>
                           </methodparam>
                           <methodparam>
                               <type>uint32_t</type><parameter>timeOffsetDivisor</parameter>
                               <initializer>1</initializer>
                           </methodparam>
                            
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Constructs a scaler item and returns a pointer to it.
                            The <parameter>startTime</parameter> and
                            <parameter>stopTime</parameter> parameters provide the
                            offset into the run at which the counting interval started
                            and ended.  The <parameter>divisor</parameter>
                            provides the number of ticks per second for both of these
                            parameters.
                           </para>
                           <para>
                            <parameter>scalers</parameter> is the array of
                            scaler values.  <parameter>isIncremental</parameter>
                            indicates if the scalers were zeroed after the read.
                           </para>
                           <para>
                            For versions that support an original source id,
                            <parameter>sid</parameter> provides this value.
                            This allows event built data to track the source id
                            of the emitter of this item even as Glom rewrites the
                            body header source id.
                           </para>
                           <para>
                            See concrete implementations for information about
                            how, if at all, the implementation fills in a body header
                            for the item.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual CRingScalerItem* </type>
                           <methodname>makeScalerItem</methodname>
                           <methodparam>
                               <type>const CRingItem&amp; </type><parameter>rhs</parameter>
                           </methodparam>
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            If <parameter>rhs</parameter> encapsulates a raw
                            scaler item a new <classname>CRingScalerItem</classname>
                            is created and the data in <parameter>rhs</parameter>
                            are copied into the new item.  A pointer to that new
                            item is returned.
                           </para>
                           <para>
                            If <parameter>rhs</parameter> does not represent
                            scaler data, <classname>std::bad_cast</classname>
                            is thrown.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual CRingTextItem* </type>
                           <methodname>makeTextItem</methodname>
                           <methodparam>
                               <type>uint16_t </type><parameter>type</parameter>
                           </methodparam>
                           <methodparam>
                               <type>std::vector&lt;std::string&gt; </type><parameter>theStrings</parameter>
                           </methodparam>
                             
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Creates a ring item that contains a set of strings.
                            The <parameter>type</parameter> parameter contains
                            the type of the ring item (type field of ring item header).
                            The possible values for this are in <filename>DataFormat.h</filename>
                            and can be:
                           </para>
                           <itemizedlist>
                            <listitem>
                               <para>
                                  <emphasis>PACKET_TYPES</emphasis>  describes
                                  the set of packet data types physics event bodies
                                  may have.
                               </para>
                            </listitem>
                            <listitem>
                               <para>
                                  <emphasis>MONITORED_VARIABLES</emphasis>
                                  Contains a set of variable names and values as
                                  Tcl scriptlets that would set those variables
                                  to their values.
                               </para>
                            </listitem>
                           </itemizedlist>
                           <para>
                            <parameter>theStrings</parameter> contains the
                            strings to put in the payload section of the body.
                           </para>
                           <para>
                            Timing information in the bodiesof this ring item type
                            are initialized as follows:  The run offset time is zero,
                            The clock timestamp is the creation time of the
                            object and the offset divisor is <literal>1</literal>.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual CRingTextItem* </type>
                           <methodname>makeTextItem</methodname>
                           <methodparam>
                               <type>    uint16_t </type><parameter>type</parameter>
                           </methodparam>
                           <methodparam>
                               <type>std::vector&lt;std::string&gt; </type><parameter>theStrings</parameter>
                           </methodparam>
                           <methodparam>
                               <type>uint32_t </type><parameter>offsetTime</parameter>
                           </methodparam>
                           <methodparam>
                               <type>time_t</type><parameter>timestamp</parameter>
                           </methodparam>
                           <methodparam>
                               <type>uint32_t </type><parameter>divisor</parameter>
                               <initializer>1</initializer>
                           </methodparam>
                            
                           
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Creates an item with a list of text strings encapsulates it
                            in a <classname>CRingTextItem</classname> and returns a
                            pointer to the resulting item.  As before,
                            <parameter>type</parameter> is the ring item type
                            and <parameter>theStrings</parameter> are the
                            text strings to store in the ring item.
                           </para>
                           <para>
                            Additional parameters provide time information.
                            <parameter>offsetTime </parameter> is the offset into the
                            run while <parameter>divisor</parameter> is the number
                            of counts in <parameter>offsetTime</parameter> per second.
                            <parameter>timestamp</parameter> is the clock time that will
                            tag the item.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual CRingTextItem* </type>
                           <methodname>makeTextItem</methodname>
                           <methodparam>
                               <type>const CRingItem&amp;</type><parameter> rhs</parameter>
                           </methodparam>
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Given that <parameter>rhs</parameter> encapsulates a
                            ring text item, this method creates a new
                            <parameter>CRingTextItem</parameter>, copies the raw
                            ring item encapsulated by <parameter>rhs</parameter>
                            and returns a pointer to that new
                            <classname>CRingTextItem</classname>.
                           </para>
                           <para>
                            If the ring item type of <parameter>rhs</parameter>
                            makes it clear that this is not a valid text item, a
                            <classname>std::bad_cast</classname> will be thrown.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual CUnknownFragment* </type>
                           <methodname>makeUnknownFragment</methodname>
                           <methodparam>
                               <type>uint64_t </type><parameter>timestamp</parameter>
                           </methodparam>
                           <methodparam>
                               <type>uint32_t </type><parameter>sourceid</parameter>
                           </methodparam>
                           <methodparam>
                               <type>uint32_t</type><parameter> barrier</parameter>
                           </methodparam>
                           <methodparam>
                               <type>uint32_t </type><parameter>size</parameter>
                           </methodparam>
                           <methodparam>
                               <type>void* </type><parameter>pPayload</parameter>
                           </methodparam>
                            
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            This method is the same as <methodname>makeRingFragmentItem</methodname>
                            but the payload is not assumed to be a ring item.
                            While ring fragment items have type
                            <literal>EVB_FRAGMENT</literal>,  these have type
                            <literal>EVB_UNKNOWN_PAYLOAD</literal>
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual CUnknownFragment* </type>
                           <methodname>makeUnknownFragment</methodname>
                           <methodparam>
                               <type>const CRingItem&amp; </type><parameter>rhs</parameter>
                           </methodparam>
                            
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Again see <methodname>makeRingFragmentItem</methodname>.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual CRingStateChangeItem* </type>
                           <methodname>makeStateChangeItem</methodname>
                           <methodparam>
                               <type>uint32_t </type><parameter>itemType</parameter>
                           </methodparam>
                           <methodparam>
                               <type>uint32_t</type><parameter> runNumber</parameter>
                           </methodparam>
                           <methodparam>
                               <type>uint32_t</type><parameter>timeOffset</parameter>
                           </methodparam>
                           <methodparam>
                               <type>time_t </type><parameter>timestamp</parameter>
                           </methodparam>
                           <methodparam>
                               <type>std::string </type><parameter>title</parameter>
                           </methodparam>
                            
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Creates a new state change ring item wrapping it in a
                            <classname>CRingStateChangeItem</classname> and returning a
                            pointer to the new object.
                           </para>
                           <para>
                            The <parameter>itemType</parameter> parameter provides
                            the exact state change reason.  Its possible values are
                            defined in <filename>DataFormat.h</filename> and are:
                            <literal>BEGIN_RUN</literal>, <literal>PAUSE_RUN</literal>,
                            <literal>RESUME_RUN</literal>, and <literal>END_RUN</literal>
                            with obvious (I hope) meanings.
                           </para>
                           <para>
                            <parameter>runNumber</parameter> provides the run number
                            of the run having the transition, and <parameter>title</parameter>
                            its title string.  <parameter>timeOffset</parameter>
                            provides the time offset into the run while
                            <parameter>timestamp</parameter> is intended
                            to provide an absolute clock time at which the
                            transtion occured.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual CRingStateChangeItem* </type>
                           <methodname>makeStateChangeItem</methodname>
                           <methodparam>
                               <type>const CRingItem&amp;</type><parameter> rhs</parameter>
                           </methodparam>
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            If <parameter>rhs</parameter> is a <classname>CRingItem</classname>
                            that is wrapping a state change raw ring item, this
                            method creates a new <classname>CRingStateChangeItem</classname>,
                            wraps a copy of the raw ring item in <parameter>rhs</parameter>
                            and returns a pointer to the new item to the caller.
                            If <parameter>rhs</parameter> is not a valid
                            state change item, <classname>std::bad_cast</classname>
                            is thrown.
                           </para>
                        </listitem>
                    </varlistentry>                
                </variablelist>
                             
            </refsect1>
        </refentry>
        
        <refentry>
           <refmeta>
              <refentrytitle>CRingItem (abstract)</refentrytitle>
              <manvolnum>3format</manvolnum>
           </refmeta>
           <refnamediv>
              <refname>CRingItem</refname>
              <refpurpose>Ultimate ring item base class</refpurpose>
            </refnamediv>
            <refsynopsisdiv>
                <programlisting>
#include &lt;CRingItem.h&lt;

class CRingItem {

public:
      CRingItem(uint16_t type, size_t maxBody = CRingItemStaticBufferSize - 10);

      CRingItem(const CRingItem&amp; rhs);
      CRingItem(pRingItem pItem);
      virtual ~CRingItem();
      virtual size_t getStorageSize() const;
      virtual size_t getBodySize()    const;
      virtual const void*  getBodyPointer() const;
      virtual void* getBodyPointer();
      void*  getBodyCursor();
      pRingItem  getItemPointer();
      const RingItem*  getItemPointer() const;
      uint32_t type() const;
      uint32_t size() const;
      virtual bool mustSwap() const;
      virtual bool hasBodyHeader() const;
      virtual void* getBodyHeader() const = 0;
      virtual uint64_t getEventTimestamp() const;
      virtual uint32_t getSourceId() const;
      virtual uint32_t getBarrierType() const;
      virtual void setBodyHeader(uint64_t timestamp, uint32_t sourceId,
                         uint32_t barrierType = 0) = 0;
      virtual void setBodyCursor(void* pNewCursor);
      virtual void updateSize();          
      virtual std::string typeName() const; 
      virtual std::string toString() const; 
      virtual void* appendBodyData(const void* pSrc, uint32_t nBytes);


};
                </programlisting>
            </refsynopsisdiv>
            <refsect1>
                     <title>DESCRIPTION</title>
                  <para>
                    This is the ultimate base class for all ring item format classes.
                    It lives in the global namespace.  It provides interfaces
                    and services used by other derived classes.
                  </para>
                  <para>
                    While most of the virtual methods have default implementations,
                    if you are building a new formatting class hierarchy, you should
                    not count on those doing what you want if they require
                    knowledge of the format of the ring item format.
                  </para>
            </refsect1>
            <refsect1>
                <title>METHODS</title>
                <variablelist>
                    <varlistentry>
                       <term>
                        <constructorsynopsis>
                            <methodname>CRingItem</methodname>
                            <methodparam>
                                <type>uint16_t</type><parameter>type</parameter>
                            </methodparam>
                            <methodparam>
                                <type>size_t </type><parameter>maxBody</parameter>
                                <initializer>CRingItemStaticBufferSize - 10</initializer>
                            </methodparam>
                        </constructorsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Constructor.  <parameter>type</parameter> will be stored
                            in the ring item header's type field.  Note that
                            the header form is common for all formats.
                            The <parameter>type</parameter> is 16 bit wide because in
                            the original design it was also used to determine the
                            byte order of the originator.  Specifically, if the
                            'low order' 16 bits of a type field were zero, the
                            byte order of the originator was the opposite of the
                            consumer.  Now that little-endianess has won the
                            byte order wars and big-endinaness only appears
                            vestigially in network byte ordering,  We define
                            the byte ordering of Ring items to be little-endian.
                           </para>
                           <para>
                            <parameter>maxBody</parameter> determines the maximum
                            number of bytes the internal storage for the ring item
                            can hold in the body (the part following the header).
                            Note that the design of <classname>CRingItem</classname>
                            includes a decently sized static block of data.
                            If this value indicates the data will fit in that
                            block, no dynamic memory allocation is required and
                            that block is used.  If this value indicates that
                            the data won't fit, a block is dynamically allocated
                            and used.  The intent is to minimize the costly
                            set of dynamic memory allocations/deallocations
                            needed if all <classname>CRingItem</classname>
                            constructions dynamically allocated the needed
                            data.
                           </para>
                           <para>
                            The default value for <parameter>maxBody</parameter>
                            allows callers to use the static buffer and is
                            defined in <filename>CRingItem.h</filename>.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <constructorsynopsis>
                            <methodname>CRingItem</methodname>
                            <methodparam>
                                <type>pRingItem </type><parameter>pItem</parameter>
                            </methodparam>
                        </constructorsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Wraps a <classname>CRingItem</classname> object
                            around a raw ring item.  The type
                            <type>pRingItem</type> is defined in
                            <filename>DataFormat.h</filename>.
                           </para>
                           <para>
                            <parameter>pItem</parameter> is used to size
                            the ring item and copied into the data storage
                            region of the item.  The body cursor is set to point
                            after the ring item data.  This allows the
                            item to be mutated (via <methodname>getBodyPointer</methodname>)
                            and to be extended (via <methodname>getBodyCursor</methodname>,
                            <methodname>setBodyCursor</methodname>, and <methodname>updateSize</methodname>).
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual size_t </type>
                           <methodname>getStorageSize</methodname>
                           <void />
                           <modifier>const</modifier>
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Returns the capacity of the block of data that is being used
                            to store the ring item.   Can be used to determine
                            if sufficient storage has been allocated to
                            hold the desired ring item.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual size_t </type>
                           <methodname>getBodySize</methodname>
                           <void />
                           <modifier>const</modifier>
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Returns the current size, in bytes,
                            of the ring item body.
                            This computes the number of bytes between the
                            pointers returned by
                            <methodname>getBodyCursor</methodname> and the
                            <methodname>geBodyPointer</methodname>.  For it to be
                            accurate, <methodname>getBodyCursor</methodname>
                            must be updated (via <methodname>setBodyCursor</methodname>)
                            to point past the body of the ring item as it is
                            so far.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual const void*  </type>
                           <methodname>getBodyPointer</methodname>
                           <void /><modifier>const</modifier>
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Returns a pointer to the body of the item. Since
                            the pointer is const, this is intended to allow
                            read access.  Note that the concept of a ring item
                            <firstterm>body</firstterm> is not that straightforward.
                            In version 10, for example the body begins right after
                            the ring item header.  In v11, v12, which support body
                            headers the body may begin after the <type>uint32_t</type>
                            indicating there is no body header (which has different values
                            depending on version) or it may begin after the body
                            header if there is on.  Therefore, this is virtual
                            and implemented on a per version basis.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type> virtual void* </type>
                           <methodname>getBodyPointer</methodname>
                           <void />
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Same as above except that the pointer can be used
                            to modify the body contents.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>void*  </type>
                          <methodname>getBodyCursor</methodname>
                          <void />
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the body cursor of the item. When a ring item
                            is created, a pointer, called the body cursor is
                            created which points to the first free byte of memory
                            into which data can be appended to the ring item.
                            As data are appended to the ring item, the
                            object's body cursor should be reste with
                            <methodname>setBodyCursor</methodname>, at some point,
                            when the ring item has been completely built,
                            <methodname>updateSize</methodname> should be called
                            to compute the ring item's size and store it in the
                            size field of the ring item's header.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>pRingItem  </type>
                          <methodname>getItemPointer</methodname>
                          <void />
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns a pointer to the ring item as encapsulated
                            by this class.  Note that <type>pRingItem</type>
                            is defined in <filename>DataFormat.h</filename>.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>const RingItem*  </type>
                          <methodname>getItemPointer</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Same as above but the pointer only allows read access
                            to the contents of the ring item.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>uint32_t </type>
                          <methodname>type</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the full 32 bit type field of the
                            ring item.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>uint32_t </type>
                          <methodname>size</methodname>
                          <void /> <modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the size field of the header. Note that unless
                            <methodname>updateSize</methodname> has been called,
                            this value is not a reliable measure of the number
                            of bytes that make up the ring item.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual bool </type>
                          <methodname>mustSwap</methodname>
                          <void /> <modifier> const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns <literal>false</literal>.  All data is
                            now specified be little endian as are all computing
                            systems processing that data.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual bool </type>
                          <methodname>hasBodyHeader</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns <literal>true</literal> if the ring item
                            has a body header.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void* </type>
                          <methodname>getBodyHeader</methodname>
                          <void /> <modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns a pointer to the body header of the item
                            if it has one.  If it does not returns a
                            <literal>nullptr</literal>. 
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual uint64_t </type>
                           <methodname>getEventTimestamp</methodname>
                           <void /> <modifier>const</modifier>
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Returns the event/fragment timestamp stored
                            in the body header of the ring item.  If the ring
                            item has no body header,
                            <classname>std::logic_error</classname> is thrown.
                            You can use e.g. <methodname>hasBodyHeader</methodname>
                            to test for the presence of a body header in the
                            item.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual uint32_t </type>
                          <methodname>getSourceId</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Retrieves the source id from the ring item's body header.
                            If the ring item does not have a body header,
                            <classname>std::logic_error</classname> is throw
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual uint32_t </type>
                          <methodname>getBarrierType</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the barrier type field from the item's
                            body header.   If the ring item does not have a body
                            header, <classname>std::logic_error</classname>
                            is thrown.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        (pure virtual)
                        <methodsynopsis>
                          <type>virtual void </type>
                          <methodname>setBodyHeader</methodname>
                          <methodparam>
                              <type>uint64_t </type><parameter>timestamp</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t </type><parameter>sourceId</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t </type><parameter>barrierType</parameter>
                              <initializer>0</initializer>
                          </methodparam>
                       </methodsynopsis>
                       
                       </term>
                       <listitem>
                           <para>
                            If the format supports body headers a body header is
                            added to the item (if it does not already have one) or
                            the body header is modified as described by the method's
                            parameters.  If the format does not support body headers,
                            this should be implemented as a no-op.
                           </para>
                           <para>
                            Note that body data must never be overwritten.
                            If an item has a non-empty body but no body header,
                            then that body must be moved to make space for the
                            body header which is then put in the appropriate
                            place (after the ring item header in currently
                            supported formats).
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void </type>
                          <methodname>setBodyCursor</methodname>
                          <methodparam>
                              <type>void* </type><parameter>pNewCursor</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Updates the internal body cursor of the object
                            with <parameter>pNewCursor</parameter>.  If coupled
                            with a call to <methodname>updateSize</methodname>,
                            this causes the size field of the ring item header
                            to be computed and updated.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void</type>
                          <methodname>updateSize</methodname>
                          <void />
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Treating the current body cursor value as a pointer
                            to the byte following the current contents of the
                            ring item, the size of the ring item is computed
                            and stored in the size field of the ring item
                            header.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual std::string </type>
                          <methodname>typeName</methodname>
                          <void /> <modifier>() const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            The base class returns the string:
                            <literal>Unknown</literal> followed by the parenthesized
                            numeric
                            type from the ring item header in hexadecimal.
                            Derived classes are
                            expected to return a text string which indicates the
                            type of the ring item. 
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual std::string </type>
                          <methodname>toString</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns a human readable stringified dump
                            of the body of the item.  In this case this is just
                            a byte by byte dump.  Derived classes are expected
                            to return something a bit more meaningful.  The
                            NSCLDAQ dumper, e.g. uses this string to
                            dump items it encounters.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void* </type>
                          <methodname>appendBodyData</methodname>
                          <methodparam>
                              <type>const void* </type><parameter>pSrc</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t </type><parameter>nBytes
                              </parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Appends the <parameter>nBytes</parameter> bytes
                            of data pointed to by <parameter>pSrc</parameter>
                            to the ring item.  The data are placed where
                            the current body cursor is pointing.  The body cursor
                            is updated and the size recomputed.
                           </para>
                           <para>
                            This is equivalent to the following code fragment:
                           </para>
                           <informalexample>
                            <programlisting>
  uint8_t* p = reinterpret_cast&lt;uint8_t*&gt;(getBodyCursor());
  memcpy(p, pSrc, nBytes);
  p += nBytes;
  setBodyCursor(p);
  updateSize();
  return p;

                            </programlisting>
                           </informalexample>
                           <para>
                            The ring item object must have the capacity for the
                            additional bytes of data.
                           </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </refsect1>
        </refentry>
        <refentry>
           <refmeta>
              <refentrytitle>CAbnormalEndItem (abstract)</refentrytitle>
              <manvolnum>3format</manvolnum>
           </refmeta>
           <refnamediv>
              <refname>CAnbormaleEndItem (abstract)</refname>
              <refpurpose>Support ring items that flag abnormally ended runs.</refpurpose>
            </refnamediv>
            <refsynopsisdiv>
                <programlisting>
#include &lt;CAbnormalEndItem.h&gt;

class CAbnormalEndItem : public CRingItem
{
public:
    CAbnormalEndItem();
    virtual ~CAbnormalEndItem();

    virtual void* getBodyHeader() const;
    virtual void  setBodyHeader(uint64_t timestamp, uint32_t sourceId,
                         uint32_t barrierType = 0);

    virtual std::string typeName() const;
    virtual std::string toString() const;
};

                </programlisting>
            </refsynopsisdiv>
            <refsect1>
                     <title>DESCRIPTION</title>
                  <para>
                    In the event a data taking run ends abnormally,
                    Abnormal end run items can be emittted.  One purpose of
                    these is to inform event loggers that the event file they have
                    open can be closed. 
                  </para>
                  <para>
                    Normally an abnormal end run item is an indication of a
                    DAQ state transition from active or paused to not ready.
                  </para>
                  <para>
                    Abnormal end items were introduced into NSCLDAQ in version
                    11.  In version 11 and 12, they are simply ring item headers
                    with no body but the type <literal>ABNORMAL_ENDRUN</literal>.
                  </para>
            </refsect1>
            <refsect1>
                <title>METHODS</title>
                <para>
                    The methods below are normally implemented in version
                    specific implementation of <classname>CAbnormalEndRun</classname>
                </para>
                <variablelist>
                    <varlistentry>
                       <term><constructorsynopsis>
                           <methodname>CAbnormalEndItem</methodname>
                        <void />
                       </constructorsynopsis></term>
                       <listitem>
                           <para>
                            Constructs the item.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void* </type>
                          <methodname>getBodyHeader</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Normally returns <literal>nullptr</literal>
                            since these items don't have body headers.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void  </type>
                          <methodname>setBodyHeader</methodname>
                          <methodparam>
                              <type>uint64_t </type><parameter>timestamp</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t </type><parameter>sourceId</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t </type><parameter>barrierType</parameter>
                              <initializer>0</initializer>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Since the <classname>CAbnormalEndItem</classname>
                            never has a body header, this is a no-op.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual std::string </type>
                          <methodname>typeName</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the string
                            <literal>Abnormal End</literal>
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual std::string </type>
                          <methodname>toString</methodname>
                          <void /> <modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the string
                            <literal>Abnormal End\n</literal> where the
                            <literal>\n</literal> should be interpreted to mean
                            a new line.
                           </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </refsect1>
        </refentry>
        <refentry>
           <refmeta>
              <refentrytitle>CDataFormatItem (abstract)</refentrytitle>
              <manvolnum>3format</manvolnum>
           </refmeta>
           <refnamediv>
              <refname>CDataFormatItem (abstract)</refname>
              <refpurpose>Ring item that describes format version</refpurpose>
            </refnamediv>
            <refsynopsisdiv>
                <programlisting>
#include &lt;CDataFormatItem.h&gt;

class CDataFormatItem : public CRingItem
{
public:
    CDataFormatItem();
    virtual ~CDataFormatItem();

    CDataFormatItem(const CDataFormatItem&amp; rhs);
    CDataFormatItem(const CRingItem&amp; rhs) ;


    virtual uint16_t getMajor() const;
    virtual uint16_t getMinor() const;


    virtual std::string typeName() const;
    virtual std::string toString() const;

    virtual void* getBodyHeader() const;
    virtual void setBodyHeader(uint64_t timestamp, uint32_t sourceId,
                         uint32_t barrierType = 0);

};

                </programlisting>
            </refsynopsisdiv>
            <refsect1>
                     <title>DESCRIPTION</title>
                  <para>
                    THe data format ring item was introduced beginning in
                    NSCLDAQ-11.  It provides information about the version
                    (and therefore the  format) of NSCLDAQ that
                    generated the stream of ring items that follow.
                  </para>
            </refsect1>
            <refsect1>
                <title>METHODS</title>
                <variablelist>
                   <varlistentry>
                      <term><constructorsynopsis>
                          <methodname>CDataFormatItem</methodname>
                        <void />
                      </constructorsynopsis></term>
                      <listitem>
                          <para>
                            The constructor fills in the item with the
                            major and minor vesions that define the data
                            format.
                       </para>
                    </listitem>
                   </varlistentry>
                   <varlistentry>
                      <term><methodsynopsis>
                         <type>virtual uint16_t </type>
                         <methodname>getMajor </methodname>
                         <void /><modifier>const</modifier>
                      </methodsynopsis></term>
                      <listitem>
                          <para>
                            Returns the major version of the data format.  In
                            practice, this is sufficient to establish the data
                            format.
                       </para>
                    </listitem>
                   </varlistentry>
                   <varlistentry>
                      <term><methodsynopsis>
                         <type>virtual uint16_t </type>
                         <methodname>getMinor</methodname>
                         <void /><modifier>const</modifier>
                      </methodsynopsis></term>
                      <listitem>
                          <para>
                            Returns the minor version of the data format.  In practice
                            this is seldom necessary.
                       </para>
                    </listitem>
                   </varlistentry>
                   <varlistentry>
                      <term><methodsynopsis>
                         <type>virtual std::string </type>
                         <methodname>typeName</methodname>
                         <void /><modifier>const</modifier>
                      </methodsynopsis></term>
                      <listitem>
                          <para>
                            Return the string:
                            <literal>Ring Item format version</literal>
                       </para>
                    </listitem>
                   </varlistentry>
                   <varlistentry>
                      <term><methodsynopsis>
                         <type>virtual std::string </type>
                         <methodname>toString</methodname>
                         <void /> <modifier>const</modifier>
                      </methodsynopsis></term>
                      <listitem>
                          <para>
                            Returns a human readable string that describes the
                            contents of the ring item.
                       </para>
                    </listitem>
                   </varlistentry>
                   <varlistentry>
                      <term><methodsynopsis>
                         <type>virtual void* </type>
                         <methodname>getBodyHeader</methodname>
                         <void /><modifier>const</modifier>
                      </methodsynopsis></term>
                      <listitem>
                          <para>
                            Returns <literal>nullptr</literal> since these items
                            never have a body header.
                       </para>
                    </listitem>
                   </varlistentry>
                   <varlistentry>
                      <term><methodsynopsis>
                         <type>virtual void </type>
                         <methodname>setBodyHeader</methodname>
                         <methodparam>
                             <type>uint64_t </type><parameter>timestamp</parameter>
                         </methodparam>
                         <methodparam>
                             <type>uint32_t </type><parameter>sourceId</parameter>
                         </methodparam>
                         <methodparam>
                             <type>uint32_t </type><parameter>barrierType </parameter>
                             <initializer>0</initializer>
                         </methodparam>
                      </methodsynopsis></term>
                      <listitem>
                          <para>
                            No-op since these items don't have body headers.
                       </para>
                    </listitem>
                   </varlistentry>                    
                </variablelist>
            </refsect1>
        </refentry>
        <refentry>
           <refmeta>
              <refentrytitle>CGlomParameters (abstract)</refentrytitle>
              <manvolnum>3format</manvolnum>
           </refmeta>
           <refnamediv>
              <refname>CGlomParameters (abstract)</refname>
              <refpurpose>Document event building parameters</refpurpose>
            </refnamediv>
            <refsynopsisdiv>
                <programlisting>
#include &lt;CGlomParameters.h&gt;

class CGlomParameters : public CRingItem
{
public:
    
    typedef enum _TimestampPolicy {
        first = 0, last = 1, average = 2
    } TimestampPolicy;
    
public:
    CGlomParameters(uint64_t interval, bool isBuilding, TimestampPolicy policy);
    
    virtual uint64_t coincidenceTicks() const;
    virtual bool     isBuilding() const;
    virtual TimestampPolicy timestampPolicy() const;

    virtual std::string typeName() const;  
    virtual std::string toString() const;
        
    virtual void* getBodyHeader() const;
    virtual void setBodyHeader(uint64_t timestamp, uint32_t sourceId,
                         uint32_t barrierType = 0);
    

};

                </programlisting>
            </refsynopsisdiv>
            <refsect1>
                     <title>DESCRIPTION</title>
                  <para>
                    NSCLDAQ versions that support event building use this ring item
                    type to allow the event builder to document its event builder
                    settings.  The most important of these is the actual event
                    building coincidence interval.
                  </para>
            </refsect1>
            <refsect1>
                <title>METHODS</title>
                <para>
                    The following public methods are provided.
                </para>
                <variablelist>
                    <varlistentry>
                       <term><constructorsynopsis>
                           <methodname>CGlomParameters</methodname>
                        <methodparam>
                            <type>uint64_t </type><parameter>interval</parameter>
                        </methodparam>
                        <methodparam>
                            <type>bool </type><parameter>isBuilding</parameter>
                        </methodparam>
                        <methodparam>
                            <type>TimestampPolicy </type><parameter>policy</parameter>
                        </methodparam>
                       </constructorsynopsis></term>
                       <listitem>
                           <para>
                            Fully parameterized construction.  <parameter>interval</parameter>
                            is the coincidence interval used to build events from
                            the sorted fragments.  If <parameter>isBuilding</parameter>
                            is false, the output stream is just a stream of single
                            fragment events, regardless of the coincidence interval.
                            This is intended for use in testing only.
                            <parameter>>policy</parameter> is the policy used to derive
                            timestamps of the output event stream from the
                            fragments that compose them.
                            See <literal>DATA TYPES and CONSTANTS</literal>
                            for valid values and their meanings.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual uint64_t </type>
                          <methodname>coincidenceTicks</methodname>
                          <void /> <modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the coincidence interval stored in the object.
                            The units of this value are timestamp ticks.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual bool     </type>
                          <methodname>isBuilding</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the state of the object's building flag.
                            If true, the data are event built. If not the
                            event builder was run in a test mode where
                            each event output consists of a single fragment.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual TimestampPolicy </type>
                          <methodname>timestampPolicy</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the timestamp policy used to derive the
                            timestamp of output events.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual std::string </type>
                          <methodname>typeName</methodname>
                          <void /> <modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns a string that identifies the ring item type:
                            <literal>Glom Parameters</literal>.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual std::string </type>
                          <methodname>toString</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns a stringified representation of the object.
                            Intended for use in e.g. <command>dumper</command>.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void* </type>
                          <methodname>getBodyHeader</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns a pointer to the object's body header.
                            Since glom parameter items dont, at present,
                            have body headers, expect a
                            <literal>nullptr</literal> to be returned.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void </type>
                          <methodname>setBodyHeader</methodname>
                          <methodparam>
                              <type>uint64_t </type><parameter>timestamp</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t sourceId</type><parameter></parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t </type><parameter>barrierType</parameter>
                              <initializer>0</initializer>
                          </methodparam>
                       </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Sets/adds a body header to the item.  Since
                            glom parameter items don't have a body header,
                            this is a no-op.
                           </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </refsect1>
            <refsect1>
                <title>DATA TYPES and CONSTANTS</title>
                <para>
                    The <classname>CGlomParameters</classname> class provides
                    a single data type:  <type>TimestampPolicy</type>.  THe
                    event builder in NSCLDAQ supports hierarchical event building.
                    This means that the output of an event builder can be input
                    for a subsequent event builder in the data acquisition
                    data flow.
                </para>
                <para>
                    This allows detector systems which require an event builder
                    of their own to be run together with other detector systems
                    by simply providing a second level event builder to glue together
                    events from each detector subsystem into coincident events.
                </para>
                <para>
                    This ability for hierarchical event building requires that
                    output events are also given a timestamp.  The
                    <type>TimestampPolicy</type> data type provides a type that
                    specifies how this output timestamp is determined.  It
                    can have the following values:
                </para>
                <variablelist>
                    <varlistentry>
                       <term><literal>first</literal></term>
                       <listitem>
                           <para>
                            The output timestamp is taken from the earliest (first)
                            fragment's timestamp.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><literal>last</literal></term>
                       <listitem>
                           <para>
                            The output timestamp is taken from the latest (last)
                            fragment's timestamp.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><literal>average</literal></term>
                       <listitem>
                           <para>
                            The output timestamp is the average of all timestamps
                            of the fragments that make up the event.
                           </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </refsect1>
        </refentry>
        <refentry>
           <refmeta>
              <refentrytitle>CPhysicsEventItem (abstract)</refentrytitle>
              <manvolnum>3format</manvolnum>
           </refmeta>
           <refnamediv>
              <refname>CPhysicsEventItem (abstract)</refname>
              <refpurpose>Encapsulate the data from a physics trigger.</refpurpose>
            </refnamediv>
            <refsynopsisdiv>
                <programlisting>
#include &lt;CPHysicsEventItem.h&gt;

class CPhysicsEventItem : public CRingItem
{
public:
    CPhysicsEventItem(size_t maxBody=8192);
  
    virtual std::string typeName() const;	// Textual type of item.
    virtual std::string toString() const; // Provide string dump of the item.
    
    virtual void* getBodyHeader() const;
    virtual void setBodyHeader(uint64_t timestamp, uint32_t sourceId,
                         uint32_t barrierType = 0);
  
};
                </programlisting>
            </refsynopsisdiv>
            <refsect1>
                     <title>DESCRIPTION</title>
                  <para>
                    <classname>CPHysicsEventItem</classname> is a ring item that
                    encapsulates data from a physics trigger.  As such, the body
                    of the ring item has no defined format but can be in whatever
                    format best suits the data from the trigger.
                  </para>
                  <para>
                    Note that event built data has a defined format that
                    describes how fragments appear in the event however, again,
                    the fragment payloads do not have a defined format.
                  </para>
            </refsect1>
            <refsect1>
                <title>METHODS</title>
                <variablelist>
                    <varlistentry>
                       <term><constructorsynopsis>
                           <methodname>CPhysicsEventItem</methodname>
                        <methodparam>
                            <type>size_t </type><parameter>maxBody</parameter>
                            <initializer>8192</initializer>
                        </methodparam>
                       </constructorsynopsis></term>
                       <listitem>
                           <para>
                            Constructs an item for a single physics trigger.
                            Note that the storage size is statically allocated
                            with <parameter>maxBody</parameter> bytes of payload
                            data.  The ring item header type field is initialized
                            to <literal>PHYSICS_EVENT</literal>.
                           </para>
                           <para>
                            Upon creating the item normally, if a body header
                            is required, <methodname>setBodyHeader</methodname>
                            is invoked.  <methodname>getBodyCursor</methodname>
                            is then used get a pointer into the object at where
                            the physics data should be put.  After incrementing
                            this pointer by an appopriate amount,
                            calls to <methodname>setBodyCursor</methodname>,
                            folowed by <methodname>updateSize</methodname>
                            are required to set the size field of the
                            ring item header.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual std::string </type>
                          <methodname>typeName</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns a string that represents the ring item type:
                            <literal>Event</literal>
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual std::string </type>
                          <methodname>toString</methodname>
                          <void /> <modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns a string that represents the contents of the
                            event.  This is used, e.g., by the
                            <command>dumper</command> command to render human
                            readable data.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void*</type>
                          <methodname>getBodyHeader</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns a pointer to the body header for the event.
                            If the event has no body header,
                            <literal>nullptr</literal> is returned. Note that
                            the base class <methodname>hasBodyHeader</methodname>
                            can be called to determine if the ring item type has
                            a body header.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void </type>
                          <methodname>setBodyHeader</methodname>
                          <methodparam>
                              <type>uint64_t </type><parameter>timestamp</parameter>
                          </methodparam>
                          <methodparam>
                              <type> uint32_t </type><parameter>sourceId</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t </type><parameter>barrierType </parameter>
                              <initializer>0</initializer>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Inserts a new or modifies an existing body header of the event.
                           </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </refsect1>
        </refentry>
        <refentry>
           <refmeta>
              <refentrytitle>CRingFragmentItem (abstract)</refentrytitle>
              <manvolnum>3format</manvolnum>
           </refmeta>
           <refnamediv>
              <refname>CRingFragmentItem (abstract)</refname>
              <refpurpose>Ring item to encapsulate event builder fragments.</refpurpose>
            </refnamediv>
            <refsynopsisdiv>
                <programlisting>
#include &lt;CRingFragmentItem.h&gt;

class CRingFragmentItem : public CRingItem
{
 

public:
  CRingFragmentItem(uint64_t timestamp, 
		    uint32_t source, 
		    uint32_t payloadSize, 
		    const void* pBody,
		    uint32_t barrier=0);

  virtual uint64_t     timestamp() const;
  virtual uint32_t     source() const;
  virtual size_t       payloadSize() const;
  virtual void*        payloadPointer();
  virtual uint32_t     barrierType() const;

  virtual std::string typeName() const;
  virtual std::string toString() const;
  
  virtual void setBodyHeader(uint64_t timestamp, uint32_t sourceId,
                         uint32_t barrierType = 0) ;
  
  virtual void* getBodyHeader() const;
  virtual bool hasBodyHeader() const;


};
                </programlisting>
            </refsynopsisdiv>
            <refsect1>
                     <title>DESCRIPTION</title>
                  <para>
                    The event builder sort stage can output a set of fragments
                    encapsulated in a ring item. The fragments look like
                    a ringitem header, a body header and an arbitrary payload.
                    The <classname>CRingFragmentItem</classname> represents
                    the items where the payload are established to be ring items
                    (note that the sort stage of the event builder is format
                    agnositic).
                  </para>
            </refsect1>
            <refsect1>
                <title>METHODS</title>
                <variablelist>
                    <varlistentry>
                       <term><constructorsynopsis>
                           <methodname>CRingFragmentItem</methodname>
                        <methodparam>
                            <type>uint64_t </type><parameter>timestamp</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint32_t </type><parameter>source</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint32_t </type><parameter>payloadSize</parameter>
                        </methodparam>
                        <methodparam>
                            <type>const void* </type><parameter>pBody</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint32_t </type><parameter>barrier</parameter>
                            <initializer>0</initializer>
                        </methodparam>
                       </constructorsynopsis></term>
                       <listitem>
                           <para>
                            Constructs the item.  The <parameter>timestamp</parameter>,
                            <parameter>sourcde</parameter> and optional
                            <parameter>barrier</parameter> parameters fill in
                            the body header.  The default value of 0
                            for the <parameter>barrier</parameter> represents a
                            non-barrier event.
                           </para>
                           <para>
                            The payload of the fragment is <parameter>payloadSize</parameter>
                            bytes taken from the data pointed to by <parameter>pBody</parameter>.
                           </para>
                           <para>
                            For this item, type, <parameter>pBody</parameter>
                            is expected to point to a ring item whose
                            header size field is the same as the
                            <parameter>payloadSize</parameter> parameter.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual uint64_t     </type>
                          <methodname>timestamp</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the timestamp from the item's body header.
                            Note that by definition, fragment items have
                            a body header.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual uint32_t     </type>
                          <methodname>source</methodname>
                          <void /><modifier> const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the source id from the item's body header.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual size_t  </type>
                          <methodname>payloadSize</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the size of the payload. Note that it is
                            acceptable, and normal for this to be computed by the
                            implementation from the ring item size and the body
                            header size
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void*        </type>
                          <methodname>payloadPointer</methodname>
                          <void />
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns a pointer to the payload data.  The pointer
                            allows the data to be edited as well as simply
                            inspected.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual uint32_t     </type>
                          <methodname>barrierType</methodname>
                          <void />
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the item's body header barrier type field.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual std::string </type>
                          <methodname>typeName</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns a string that describes the type of the
                            ring item: <literal>Event fragment</literal>
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual std::string </type>
                          <methodname>toString</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns a string representation of the  contents of
                            the ring item. This is used e.g. by
                            <command>dumper</command>
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void </type>
                          <methodname>setBodyHeader</methodname>
                          <methodparam>
                              <type>uint64_t </type><parameter>timestamp</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t </type><parameter>sourceId</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t </type><parameter>barrierType </parameter>
                              <initializer>0</initializer>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Modifies the contents of the item's body header
                            (this type always has  a body header).
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void* </type>
                          <methodname>getBodyHeader</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns a pointer to the object's body header.
                            Note that the actual shape of the body header
                            depends on the actual data format version.  Normally
                            each data version has an associated
                            <filename>DataFormat.h</filename> header which, among other
                            things defines a <type>BodyHeader</type> type
                            within a namespace specific to the format.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual bool</type>
                          <methodname> hasBodyHeader</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns <literal>true</literal> as this type of ring item
                            always has a body header.
                           </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
                
            </refsect1>
        </refentry>
        <refentry>
           <refmeta>
              <refentrytitle>CRingPhysicsEventCountItem (abstract)</refentrytitle>
              <manvolnum>3format</manvolnum>
           </refmeta>
           <refnamediv>
              <refname>CRingPhysicsEventCountItem (abstract)</refname>
              <refpurpose>Ring Item with trigger counts.</refpurpose>
            </refnamediv>
            <refsynopsisdiv>
                <programlisting>
#include &lt;CRingPhysicsEventCount.h&gt;

class CRingPhysicsEventCountItem : public CRingItem
{

public:
  CRingPhysicsEventCountItem();
  CRingPhysicsEventCountItem(uint64_t count,
			     uint32_t timeOffset, unsigned divisor = 1);
  CRingPhysicsEventCountItem(uint64_t count, 
			     uint32_t timeoffset, 
			     time_t stamp, uint32_t sid, unsigned divisor = 1);

  virtual uint32_t getTimeOffset() const;
  virtual void     setTimeOffset(uint32_t offset);
  virtual float    computeElapsedTime() const;
  virtual uint32_t getTimeDivisor() const;

  virtual time_t   getTimestamp() const;
  virtual void     setTimestamp(time_t stamp);

  virtual uint64_t getEventCount() const;
  virtual void     setEventCount(uint64_t count);
  
  virtual uint32_t getOriginalSourceId() const;

  virtual void setBodyHeader(uint64_t timestamp, uint32_t sourceId,
                         uint32_t barrierType = 0);
  virtual void* getBodyHeader() const; 

  virtual std::string typeName() const;	// Textual type of item.
  virtual std::string toString() const; // Provide string dump of the item.

};
                </programlisting>
            </refsynopsisdiv>
            <refsect1>
                     <title>DESCRIPTION</title>
                  <para>
                    Online analysis software often samples data in order to
                    avoid being the throughput bottleneck. It is useful for such
                    software to be able to compute the fraction of the actual
                    data it has analyzed.  This ring item provides the number
                    of physics triggers (<classname>CPHysicsEventItem</classname>
                    objects) that have been emitted by a readout (or the event builder)
                    at some point in time. By counting the number of physics
                    triggers processe and dividing by the number of actual
                    triggers, the fraction of data analyzed  can be computed.
                  </para>
            </refsect1>
            <refsect1>
                <title>METHODS</title>
                <variablelist>
                    <varlistentry>
                       <term><constructorsynopsis>
                           <methodname>CRingPhysicsEventCountItem</methodname>
                        <void />
                       </constructorsynopsis></term>
                       <listitem>
                           <para>
                            Constructs an event count item with a count of zero,
                            run time offset of zero and timestamp of the time
                            the constructor was invoked.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><constructorsynopsis>
                           <methodname>CRingPhysicsEventCountItem</methodname>
                        <methodparam>
                            <type>uint64_t </type><parameter>count</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint32_t </type><parameter>timeOffset</parameter>
                        </methodparam>
                        <methodparam>
                            <type>unsigned </type><parameter>divisor</parameter>
                        </methodparam>
                       </constructorsynopsis></term>
                       <listitem>
                           <para>
                            Creates an event count item where the trigger
                            count is initialized to <parameter>count</parameter>.
                            The run offset is given by <parameter>timeOffset</parameter>
                            with <parameter>divisor</parameter> ticks per second.
                            The clock time is set to the construction time of
                            the object.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><constructorsynopsis>
                           <methodname>CRingPhysicsEventCountItem</methodname>
                        <methodparam>
                            <type>uint64_t </type><parameter>count</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint32_t </type><parameter>timeoffset</parameter>
                        </methodparam>
                        <methodparam>
                            <type>time_t </type><parameter>stamp</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint32_t </type><parameter>sid</parameter>
                        </methodparam>
                        <methodparam>
                            <type> unsigned </type><parameter>divisor</parameter>
                            <initializer>1</initializer>
                        </methodparam>
                       </constructorsynopsis></term>
                       <listitem>
                           <para>
                            Full construction of a physics event count item
                            with a prototypical body header.  The additional
                            parameter from the previous constructor are
                            <parameter>stamp</parameter>, which provides
                            the clock time at which the item was constructed and
                            <parameter>sid</parameter> which provides the source
                            id for the original source id field (if any) of the
                            item.  
                           </para>
                           <para>
                            The original source id allows analysis programs to
                            track the originating data source for this item.
                            Note that the constructor does not produce a
                            body  header but one can be added with
                            <methodname>setBodyHeader</methodname>.
                            
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual uint32_t </type>
                          <methodname>getTimeOffset</methodname>
                          <void /> <modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the raw time offset into the run at which
                            this item was created.  Note that
                            <methodname>computeElapsedTime</methodname> is the
                            preferred method to get the elapsed run time.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void     </type>
                          <methodname>setTimeOffset</methodname>
                          <methodparam>
                              <type>uint32_t</type><parameter> offset</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Sets the object's raw run time offset.  This
                            offset is uncorrected by the offset divisor.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual float    </type>
                          <methodname>computeElapsedTime</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Computes the elapsed time in the run at which this
                            was emitted from the raw offset and the divisor.
                            Units are seconds.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual uint32_t </type>
                          <methodname>getTimeDivisor</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the number of ticks in a second in the
                            elapsed time raw value.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type> virtual time_t   </type>
                          <methodname>getTimestamp</methodname>
                          <void />
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Return the clock time associated with the item.
                           </para>
                        </listitem>
                    </varlistentry>
                   <varlistentry>
                      <term><methodsynopsis>
                         <type>virtual void     </type>
                         <methodname>setTimestamp</methodname>
                         <methodparam>
                             <type>time_t </type><parameter>stamp</parameter>
                         </methodparam>
                      </methodsynopsis></term>
                      <listitem>
                          <para>
                            Sets the clock time associated with the item.
                       </para>
                    </listitem>
                   </varlistentry>
                   <varlistentry>
                      <term><methodsynopsis>
                         <type>virtual uint64_t </type>
                         <methodname>getEventCount</methodname>
                         <void /><modifier>const</modifier>
                      </methodsynopsis></term>
                      <listitem>
                          <para>
                            Return the number of triggers documented by this
                            item.
                       </para>
                    </listitem>
                   </varlistentry>
                   <varlistentry>
                      <term><methodsynopsis>
                         <type>virtual void     </type>
                         <methodname>setEventCount</methodname>
                         <methodparam>
                             <type>uint64_t </type><parameter>count</parameter>
                         </methodparam>
                      </methodsynopsis></term>
                      <listitem>
                          <para>
                            sets the item's trigger count.
                       </para>
                    </listitem>
                   </varlistentry>
                   <varlistentry>
                      <term><methodsynopsis>
                         <type>virtual uint32_t </type>
                         <methodname>getOriginalSourceId</methodname>
                         <void /><modifier> const</modifier>
                      </methodsynopsis></term>
                      <listitem>
                          <para>
                            Returns the source id of the data source that emitted
                            this object.
                       </para>
                    </listitem>
                   </varlistentry>
                   <varlistentry>
                      <term>
                        <methodsynopsis>
                           <type>virtual std::string </type>
                           <methodname>typeName</methodname>
                           <void /><modifier>const</modifier>
                        </methodsynopsis>
                      </term>
                      <listitem>
                          <para>
                            Returns a string indicating the type of ring item
                            this object is:  <literal>Trigger count</literal>
                       </para>
                    </listitem>
                   </varlistentry>
                   <varlistentry>
                      <term><methodsynopsis>
                         <type>virtual std::string </type>
                         <methodname>toString</methodname>
                         <void /><modifier>const</modifier>
                      </methodsynopsis></term>
                      <listitem>
                          <para>
                            Return  a string that describes the contents of the
                            item.  This is used by, e.g. <command>dumper</command>
                       </para>
                    </listitem>
                   </varlistentry>
                   <varlistentry>
                      <term><methodsynopsis>
                         <type>virtual void </type>
                         <methodname>setBodyHeader</methodname>
                         <methodparam>
                             <type>uint64_t </type><parameter>timestamp</parameter>
                         </methodparam>
                         <methodparam>
                             <type>uint32_t </type><parameter>sourceId</parameter>
                         </methodparam>
                         <methodparam>
                             <type>uint32_t </type><parameter>barrierType </parameter>
                             <initializer>0</initializer>
                         </methodparam>
                      </methodsynopsis></term>
                      <listitem>
                          <para>
                            Adds a new body header or modifies the contents of the
                            existing body header.
                       </para>
                    </listitem>
                   </varlistentry>
                   <varlistentry>
                      <term><methodsynopsis>
                         <type>virtual void* </type>
                         <methodname>getBodyHeader</methodname>
                         <void /><modifier>const</modifier>
                      </methodsynopsis></term>
                      <listitem>
                          <para>
                            Returns a pointer to the body header or
                            <literal>nullptr</literal> if the object has no
                            body header.
                       </para>
                    </listitem>
                   </varlistentry>
                </variablelist>
            </refsect1>
            
        </refentry>
        <refentry>
           <refmeta>
              <refentrytitle>CRingScalerItem (abstract)</refentrytitle>
              <manvolnum>3format</manvolnum>
           </refmeta>
           <refnamediv>
              <refname>CRingScalerItem (abstract)</refname>
              <refpurpose>Encapsulate periodic scaler readouts.</refpurpose>
            </refnamediv>
            <refsynopsisdiv>
                <programlisting>
#include &lt;CRingScalerItem.h&gt;

class CRingScalerItem : public CRingItem
{
public:
  static uint32_t m_ScalerFormatMask;

public:
  CRingScalerItem(size_t numScalers);
  CRingScalerItem(uint32_t startTime,
		  uint32_t stopTime,
		  time_t   timestamp,
		  std::vector&lt;uint32_t&gt; scalers,
                  bool                  isIncremental = true,
                  uint32_t              sid = 0,
                  uint32_t              timeOffsetDivisor = 1);


  virtual void     setStartTime(uint32_t startTime);
  virtual uint32_t getStartTime() const;
  virtual float    computeStartTime() const;
  
  virtual void     setEndTime(uint32_t endTime);
  virtual uint32_t getEndTime() const;
  virtual float    computeEndTime() const;

  virtual uint32_t getTimeDivisor() const;

  virtual void     setTimestamp(time_t stamp);
  virtual time_t   getTimestamp() const;
  
  virtual bool isIncremental() const;

  virtual void     setScaler(uint32_t channel, uint32_t value) ;
  virtual uint32_t getScaler(uint32_t channel) const ;
  virtual std::vector&lt;uint32_t&gt; getScalers() const;

  virtual uint32_t getScalerCount() const;
  virtual uint32_t getOriginalSourceId() const;

  virtual void* getBodyHeader() const;
  virtual void setBodyHeader(
      uint64_t timestamp, uint32_t sourceId,
      uint32_t barrierType = 0
  );
  virtual std::string typeName() const;
  virtual std::string toString() const;

};
   


                </programlisting>
            </refsynopsisdiv>
            <refsect1>
                     <title>DESCRIPTION</title>
                  <para>
                    Most NSCLDAQ readout frameworks have the ability to periodically
                    read a set of counters or <firstterm>scalers</firstterm>.
                    These counters are passed up the data flow as
                    <classname>CRingScalerItem</classname> objects.
                  </para>
                  <para>
                    In version 10, there were a pair of underlying ring item types,
                    one for incremental and a second for non-incremental, high
                    time resolution items.  In versino 11+, these were
                    combined into a single periodic scaler item.
                  </para>
                  <para>
                    The <classname>CRingScalerItem</classname> class, provides
                    interfaces that can front-end any of the underlying scaler
                    ring items.
                  </para>
                  <para>
                    A complication for older readouts that use CAMAC scalers are
                    devices that readout 24 bits of data but whose controllers
                    set information in the top bits.   The
                    <varname>m_scalerFormatMask</varname> provides a mask
                    that is bit-wise anded with scaler values before those
                    values are returned to the user.  This mask is initialized
                    by all constructors
                    to <literal>0xffffffff</literal>, suitable for 32bit
                    scalers.  This member value is public and therefore can be
                    set to e.g.<literal>0xffffff</literal> in the event the scalers
                    are actually 24 bits wide.
                  </para>
            </refsect1>
            <refsect1>
                <title>METHODS</title>
                <variablelist>
                    <varlistentry>
                       <term><constructorsynopsis>
                           <methodname>CRingScalerItem</methodname>
                        <methodparam>
                            <type>size_t </type><parameter>numScalers</parameter>
                        </methodparam>
                       </constructorsynopsis></term>
                       <listitem>
                           <para>
                            Constructs a scaler item large enough to hold
                            <parameter>numScalers</parameter> 32 bit scaler counters.
                            The start/stop time offsets are both set to
                            <literal>0</literal> as are the scaler values.
                            The time divisor is initialized to <literal>1</literal>
                            and the clock time is set to the time at which
                            the item was constructed.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><constructorsynopsis>
                           <methodname>CRingScalerItem</methodname>
                        <methodparam>
                            <type>uint32_t </type><parameter>startTime</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint32_t </type><parameter>stopTime,</parameter>
                        </methodparam>
                        <methodparam>
                            <type>time_t   </type><parameter>timestamp</parameter>
                        </methodparam>
                        <methodparam>
                            <type>std::vector&lt;uint32_t&gt; </type><parameter>scalers,</parameter>
                        </methodparam>
                        <methodparam>
                            <type>bool </type><parameter>isIncremental</parameter>
                            <initializer>true</initializer>
                        </methodparam>
                        <methodparam>
                            <type>uint32_t </type><parameter>sid</parameter>
                            <initializer>0</initializer>
                        </methodparam>
                        <methodparam>
                            <type>uint32_t  </type><parameter>timeOffsetDivisor</parameter>
                            <initializer>1</initializer>
                        </methodparam>
                       </constructorsynopsis></term>
                       <listitem>
                           <para>
                            Fully constructs a scaler item.  The scaler values
                            are passed in via the <parameter>scalers</parameter>
                            parameter.  The size of that vector determines
                            the number of scalers the item will hold.
                           </para>
                           <para>
                            The interval start and stop offsets are given
                            by <parameter>startTime</parameter> and
                            <parameter>stopTime</parameter> respecively.
                            The optional <parameter>timeOffsetDivisor</parameter>
                            parameter provides the number of ticks in these
                            offset values per second providing support for
                            sub-second time resolution.
                           </para>
                           <para>
                            THe clock time is provided by
                            <parameter>timestamp</parameter>.
                           </para>
                           <para>
                            If <parameter>isIncremental</parameter> is false,
                            the counts are assumed to accumulate for the length
                            of the run.  Otherwise the counts in the scalers are
                            assumed to represent the counts over the interval
                            defined by <parameter>startTime</parameter>
                            through <parameter>stopTime</parameter>.
                           </para>
                           <para>
                            Beginning with the 12.0 data format, the
                            scaler bodies contain a field to retain the source id
                            of the data source the originally created the item.
                            This is important because event builders overwrite
                            the source id of scaler items.  This field is
                            initialized with the value of the
                            <parameter>sid</parameter> parameter.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void     </type>
                          <methodname>setStartTime</methodname>
                          <methodparam>
                              <type>uint32_t </type><parameter>startTime</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Sets the offset into the run at which the scaler counting
                            interval began.
        
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual uint32_t</type>
                          <methodname> getStartTime() </methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the offset into the run at which the
                            scaler counting began.  See next method, however.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual float    </type>
                          <methodname>computeStartTime</methodname>
                          <void />
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Uses the scaler interval start offset and the
                            counting divisor to compute the start time offset
                            in seconds.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void     </type>
                          <methodname>setEndTime</methodname>
                          <methodparam>
                              <type>uint32_t </type><parameter>endTime</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Sets the offset into the run of the end of the
                            scaler counting interval
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual uint32_t </type>
                          <methodname>getEndTime</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the offset into the run at which the scaler
                            counting interval ended.  See, however the next
                            method.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual float    </type>
                          <methodname>computeEndTime</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Using the end offset and the offset divisor computes
                            and returns the number of seconds into the run at
                            which the scaler counting interval ended.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual uint32_t </type>
                          <methodname>getTimeDivisor</methodname>
                          <void /> <modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the number of ticks in the start and end
                            time offsets that correspond to a second.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void     </type>
                          <methodname>setTimestamp</methodname>
                          <methodparam>
                              <type>time_t </type><parameter>stamp</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Sets the clock time associated with the item
                            to be <parameter>stamp</parameter>.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual time_t   </type>
                          <methodname>getTimestamp</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the clock time associated with the item.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual bool </type>
                          <methodname>isIncremental</methodname>
                          <void />
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            If the scalers are cleared after each read, this
                            returns <literal>true</literal>, if they are allowed
                            to accumulate across counting intervals, this returns
                            <literal>false</literal>
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void     </type>
                          <methodname>setScaler</methodname>
                          <methodparam>
                              <type>uint32_t </type><parameter>channel</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t </type><parameter>value</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Sets the counts for the scaler  selected by
                            <parameter>channel</parameter> to
                            <parameter>value</parameter>. If <parameter>channel</parameter>
                            is out of range an <classname>std::out_of_range</classname>
                            exception is thrown.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual uint32_t </type>
                          <methodname>getScaler</methodname>
                          <methodparam>
                              <type>uint32_t </type><parameter>channel</parameter>
                          </methodparam>
                          <modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returs the value of the scaler selected by
                            <parameter>channel</parameter>.  If
                            <parameter>channel</parameter> is out of range a
                            <classname>std::out_of_range</classname>
                            exception is thrown.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual std::vector&lt;uint32_t&gt; </type>
                          <methodname>getScalers</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns a vector containing the values of the scaler
                            counts in the item.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual uint32_t </type>
                          <methodname>getScalerCount</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the number of scalers in the item.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type> virtual uint32_t </type>
                          <methodname>getOriginalSourceId</methodname>
                          <void /><modifier> const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the original source id field from the item.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void* </type>
                          <methodname>getBodyHeader</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns a pointer to the item's body header
                            or <literal>nullptr</literal> if it does not have one.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void </type>
                          <methodname>setBodyHeader</methodname>
                          <methodparam>
                              <type>   uint64_t </type><parameter>timestamp</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t </type><parameter>sourceId</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t </type><parameter>barrierType</parameter>
                              <initializer>0</initializer>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Sets new values for the body header of the item
                            if it already has one or creates a new one if it does not.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual std::string </type>
                          <methodname>typeName</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns a string that identifies the type of the item:
                            <literal>Scaler</literal>
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual std::string </type>
                          <methodname>toString</methodname>
                          <void /> <modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns a string that details the contents of the
                            item.  This is used by e.g. <command>dumper</command>
                            to produce a formated dump of a stream of ring items.
                           </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </refsect1>
        </refentry>
        <refentry>
           <refmeta>
              <refentrytitle>CRingStateChangeItem (abstract)</refentrytitle>
              <manvolnum>3format</manvolnum>
           </refmeta>
           <refnamediv>
              <refname>CRingStateChangeItem (abstract)</refname>
              <refpurpose>Encapsulate run state change items.</refpurpose>
            </refnamediv>
            <refsynopsisdiv>
                <programlisting>
#include &lt;CRingStateChangeItem.h&gt;

class CRingStateChangeItem : public CRingItem
{


public:
  CRingStateChangeItem(uint16_t reason = BEGIN_RUN);
  CRingStateChangeItem(uint16_t reason,
		       uint32_t runNumber,
		       uint32_t timeOffset,
		       time_t   timestamp,
		       std::string title) ;
  

  virtual void setRunNumber(uint32_t run);
  virtual uint32_t getRunNumber() const;

  virtual void setElapsedTime(uint32_t offset);
  virtual uint32_t getElapsedTime() const;
  virtual uint32_t getTimeDivisor() const;
  virtual float    computeElapsedTime() const;

  virtual void setTitle(std::string title) ;
  virtual std::string getTitle() const;

  virtual void setTimestamp(time_t stamp);
  virtual time_t getTimestamp() const;
  virtual uint32_t getOriginalSourceId() const;

  virtual void* getBodyHeader() const;
  virtual void setBodyHeader(uint64_t timestamp, uint32_t sourceId,
                         uint32_t barrierType = 0);
  virtual std::string typeName() const;
  virtual std::string toString() const;

};

                </programlisting>
            </refsynopsisdiv>
            <refsect1>
                     <title>DESCRIPTION</title>
                  <para>
                    When the data acquisition system changes state, in a way that
                    can affect data taking, readers produce a state change item
                    so that this information can be documented in the data flow
                    and recorded to disk in the associated event file.
                  </para>
                  <para>
                    Thd <classname>CRingStateChange</classname> item encapsulates
                    such ring items.  Note that as of NSCLDAQ version 12, there
                    are four possible state change items, <literal>BEGIN_RUN</literal>,
                    <literal>PAUSE_RUN</literal>, <literal>RESUME_RUN</literal>
                    and <literal>END_RUN</literal>.  Note that not all readers
                    support pausing a run and the paused state will likely be
                    deprecated and phased out.
                  </para>
                  <para>
                    The definitions for these ring items types are in the
                    <filename>DataFormat.h</filename> header for the appropriate
                    data format or the abstract version of this file.  These
                    defintions should be considered stable.
                  </para>
            </refsect1>
            <refsect1>
                <title>METHODS</title>
                <variablelist>
                    <varlistentry>
                       <term><constructorsynopsis>
                           <methodname>CRingStateChangeItem</methodname>
                        <methodparam>
                            <type>uint16_t </type><parameter>reason </parameter>
                            <initializer>BEGIN_RUN</initializer>
                        </methodparam>
                       </constructorsynopsis></term>
                       <listitem>
                           <para>
                            Creates a state change item for the specified state
                            change type.  The offset time is set to zero, which is
                            appropriate for a begin run, the clock time stamp is
                            set to the current time.  The run number is also set
                            to zero.  The title is set to an empty string.
                            Other version specific initialization may occur.
                           </para>
                           <para>
                            If the format supports body headers and they are optionsal,
                            this construction will create an item without a body
                            header.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><constructorsynopsis>
                           <methodname> CRingStateChangeItem</methodname>
                        <methodparam>
                            <type>uint16_t </type><parameter>reason</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint32_t </type><parameter>runNumber</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint32_t timeOffset</type><parameter></parameter>
                        </methodparam>
                        <methodparam>
                            <type>time_t   </type><parameter>timestamp</parameter>
                        </methodparam>
                        <methodparam>
                            <type>std::string </type><parameter>title</parameter>
                        </methodparam>
                       </constructorsynopsis></term>
                       <listitem>
                           <para>
                            Full construction of a state change item.  The
                            <parameter>reason</parameter> is the type of state change
                            item as listed in <literal>DESCRIPTION</literal>.
                            <parameter>runNumber</parameter> us the number of the
                            run undergoing the transition.  <parameter>timeOffset</parameter>
                            is the offset into the run at which the transition occured.
                            This should always be <literal>0</literal> for
                            <literal>BEGIN_RUN</literal> transitions.
                            
                           </para>
                           <para>
                            <parameter>timestamp</parameter> is the clock time
                            at which the transition occured.   This is the output
                            of the unix <function>time</function> function.
                           </para>
                           <para>
                            Finally, <parameter>title</parameter> is the run's title.
                            This should be the same string for all transitions
                            within a run.   Note that there is a maximum
                            length to titles defined in
                            <filename>DataFormat.h</filename> with the symble
                            <literal>TITLE_MAXSIZE</literal>. Title strings longer
                            than that should be silently truncated by the
                            version's implementation.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void </type>
                          <methodname>setRunNumber</methodname>
                          <methodparam>
                              <type>uint32_t</type><parameter> run</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Modifies the item's run number.   This is most often
                            used when the minimal constructor is used to
                            create the item.  In that case, various methods
                            are used to fill in actual values of the fields.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual uint32_t </type>
                          <methodname>getRunNumber</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Return the run number from the state change ring item
                            encapsulated in the object.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void </type>
                          <methodname>setElapsedTime</methodname>
                          <methodparam>
                              <type>uint32_t </type><parameter>offset</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Sets the raw time offset of the state change item.
                            The offset says when in the timespan of the run
                            the state change occured.  It is zero at the beginning
                            of the run.  No attempt is made to synchronize this time
                            offset between several data sources.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual uint32_t </type>
                          <methodname>getElapsedTime</methodname>
                          <void />
                          <modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the raw time offset stored in the event.  This
                            is the time offset in to the run at which the state change
                            occured. Note that the time divisor (see below) represents
                            the numbver of ticks in the offset in a second.
                           </para>
                           <para>
                            It's usually preferrable to get the offset in seconds
                            using <methodname>computeElapedTime</methodname>.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual uint32_t </type>
                          <methodname>getTimeDivisor</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the time divisor.  This value represents the
                            number of ticks of time offset in a second.
                            Note that at present, all constructors initialize
                            this to <literal>1</literal> and there is no mechanism
                            to modify the divisor.  Later releases may provide
                            such a mechanism.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual float </type>
                          <methodname>computeElapsedTime</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Computes the time offset stored in the item in
                            seconds.  This is the preferred method to get the
                            time offset in the presence of the capability
                            for divisors that are greater than 1.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void </type>
                          <methodname>setTitle</methodname>
                          <methodparam>
                              <type>std::string </type><parameter>title</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Sets the title of the run for the state transition
                            item.  The state transition items that belong to the
                            same run should have the same title.  Note that
                            there is a maximum title length and implementations
                            should silently truncate any title longer than that.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual std::string </type>
                          <methodname>getTitle</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the value of the title string for the
                            transition object.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void </type>
                          <methodname>setTimestamp</methodname>
                          <methodparam>
                              <type>time_t </type><parameter>stamp</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Sets a clock times associted with the item.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual time_t </type>
                          <methodname>getTimestamp</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Return the clock time associated with the
                            item.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                            <methodsynopsis>
                               <type>virtual uint32_t</type>
                               <methodname> getOriginalSourceId</methodname>
                               <void /><modifier>const</modifier>
                            </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Returns the original source id of the item.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void* </type>
                          <methodname>getBodyHeader</methodname>
                          <void /> <modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns a pointer to the object's body header.
                            If the object has no body header
                            <literal>nullptr</literal> is returned.  The
                            actual format of the body header
                            <emphasis>may</emphasis> vary from version to version.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void </type>
                          <methodname>setBodyHeader</methodname>
                          <methodparam>
                              <type>uint64_t </type><parameter>timestamp</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t </type><parameter>sourceId</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t </type><parameter>barrierType </parameter>
                              <initializer>0</initializer>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            IF the version supports it, either add or modify an
                            existing body header in the object.  If the version
                            does not support body headers, the method should do
                            nothing.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual std::string </type>
                          <methodname>typeName</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns a string that identifies the type of the object.
                            Note that the type is a fine grained concept.
                            For examle, if the type is
                            <literal>BEGIN_RUN</literal>,
                            this method returns <literal>Begin Run</literal>.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual std::string</type>
                          <methodname>toString</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns a string that describes the contents of the
                            item.  This is used by e.g.
                            <command>dumper</command> to emit formatted
                            ring items.
                           </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </refsect1>
        </refentry>
        <refentry>
           <refmeta>
              <refentrytitle>CRingTextItem (abstract)</refentrytitle>
              <manvolnum>3format</manvolnum>
           </refmeta>
           <refnamediv>
              <refname>CRingTextItem (abstract)</refname>
              <refpurpose>Encapsulate a ring item of text strings</refpurpose>
            </refnamediv>
            <refsynopsisdiv>
                <programlisting>
#include &lt;CRingTextItem.h&gt;


class CRingTextItem : public CRingItem
{
public:

  CRingTextItem(uint16_t type, size_t maxsize);
  CRingTextItem(uint16_t type,
		std::vector&lt;std::string&gt; theStrings);
  CRingTextItem(uint16_t type,
		std::vector&lt;std::string&gt; theStrings,
		uint32_t                 offsetTime,
		time_t                   timestamp, uint32_t divisor=1) ;
  
  virtual std::vector&lt;std::string&gt;  getStrings() const;

  virtual void     setTimeOffset(uint32_t offset);
  virtual uint32_t getTimeOffset() const;
  virtual float    computeElapsedTime() const;
  virtual uint32_t getTimeDivisor() const;

  virtual void     setTimestamp(time_t stamp);
  virtual time_t   getTimestamp() const;
  virtual uint32_t getOriginalSourceId() const;
  
  virtual void* getBodyHeader() const;
  virtual void setBodyHeader(
        uint64_t timestamp, uint32_t sid, uint32_t barrierType= 0
  );
  virtual std::string typeName() const;
  virtual std::string toString() const;
  
};

                </programlisting>
            </refsynopsisdiv>
            <refsect1>
                     <title>DESCRIPTION</title>
                  <para>
                    Several types of ring items contain lists of strings.
                    The strings are stored as a block of null terminated strings.
                    A field in the ring item contains the number of strings.k
                  </para>
                  <para>
                    The following item types (defined in <filename>DataFormat.h</filename>)
                    are valid text item types:
                 </para>
                  <variablelist>
                    <varlistentry>
                       <term><literal>PACKET_TYPES</literal></term>
                       <listitem>
                           <para>
                            The SBS readout framework can use this to provide
                            a dictionary of packet types that can be seen
                            within a <literal>PHYSICS_EVENT</literal>
                            item body.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><literal>MOINTORED_VARIABLES</literal></term>
                       <listitem>
                           <para>
                            The readout frameworks based on the Tcl command
                            language support monitoring a set of internal
                            variables.  This coupled with an EPICS client
                            provides the means to incorporate EPICS data in
                            event files.  Other possible uses for this
                            can be conceived.
                           </para>
                           <para>
                            The strings in this case are a set of script commands
                            that, when run, restore the Tcl variables monitored to
                            their values at that time in the run.
                           </para>
                        </listitem>
                    </varlistentry>
                  </variablelist>
            </refsect1>
            <refsect1>
                <title>METHODS</title>
                <variablelist>
                    <varlistentry>
                       <term><constructorsynopsis>
                           <methodname>CRingTextItem</methodname>
                        <methodparam>
                            <type>uint16_t </type><parameter>type</parameter>
                        </methodparam>
                        <methodparam>
                            <type>size_t </type><parameter>maxsize</parameter>
                        </methodparam>
                       </constructorsynopsis></term>
                       <listitem>
                           <para>
                            Constructor.  <parameter>type</parameter> is the item
                            type and <parameter>maxsize</parameter> sets a
                            limit on the ring item size.  Note that if you
                            already know the set of strings to put in the item,
                            it's better to use a constructor that takes them
                             as a parameter as then the actual maximum size
                             can be computed.
                           </para>
                           <para>
                            The string count for the item is initialized to zero.
                            The run offset is also initialized to zero as is the
                            original source id.  The clock time is initialized to the
                            current time.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><constructorsynopsis>
                           <methodname> CRingTextItem(</methodname>
                        <methodparam>
                            <type>uint16_t </type><parameter>type</parameter>
                        </methodparam>
                        <methodparam>
                            <type>std::vector&lt;std::string&gt; </type><parameter>theStrings</parameter>
                        </methodparam>
                       </constructorsynopsis></term>
                       <listitem>
                           <para>
                            In this constructor, <parameter>theStrings</parameter>
                            is used to compute the required item size.  The
                            strings are set into the item's string pool
                            as null terminated strings and the string count
                            is set to <literal>theStrings.size()</literal>.
                            The offset, original source id, and clock time are
                            initialized as in the previous constructor.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><constructorsynopsis>
                           <methodname>CRingTextItem</methodname>
                        <methodparam>
                            <type>uint16_t </type><parameter>type</parameter>
                        </methodparam>
                        <methodparam>
                            <type>std::vector&lt;std::string&gt;</type><parameter> theStrings</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint32_t  </type><parameter>offsetTime</parameter>
                        </methodparam>
                        <methodparam>
                            <type>time_t </type><parameter>timestamp</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint32_t </type><parameter>divisor</parameter>
                            <initializer>1</initializer>
                        </methodparam>
                       </constructorsynopsis></term>
                       <listitem>
                           <para>
                            Fully parameterized constructor.  This constructor
                            adds <parameter>offsetTime</parameter> to set the
                            time  offset in the run at which the item was emitted,
                            <parameter>timestamp</parameter> which allows the
                            clock time the item was emitted to be expclicitly
                            specified and <parameter>divisor</parameter>
                            (optional, defaults to 1) which indicates the number
                            of ticks of <parameter>offsetTime</parameter> in
                            a second.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual std::vector&lt;std::string&gt;</type>
                          <methodname> getStrings</methodname>
                          <void /><modifier> const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns a vector that contains the text strings in the
                            object's payload.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void     </type>
                          <methodname>setTimeOffset</methodname>
                          <methodparam>
                              <type>uint32_t </type><parameter>offset</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Set the offset into the run at which this object was
                            emitted.  Note that this, together with the time divisor
                            determine the number of seconds into the run the
                            object was emitted.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual uint32_t </type>
                          <methodname>getTimeOffset</methodname>
                          <void /> <modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the raw time offset. Note that calling
                            <methodname>computeElapsedTime</methodname>
                            is the perferred method to call to get the run time
                            offset in seconds.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual float</type>
                          <methodname>computeElapsedTime</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Return the elapsed time in the run at which this
                            item was emitted, in seconds.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual uint32_t </type>
                          <methodname>getTimeDivisor</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Return the number of offset ticks per second.  
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void </type>
                          <methodname>setTimestamp</methodname>
                          <methodparam>
                              <type>time_t </type><parameter>stamp</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Sets the clock time at which the item was emitted.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual time_t  </type>
                          <methodname> getTimestamp</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the clock time associated with the item.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual uint32_t </type>
                          <methodname>getOriginalSourceId</methodname>
                          <void /><modifier> const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            return the item's original source id.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void* </type>
                          <methodname>getBodyHeader</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            If the item has a body header, this returns a pointer
                            to it.  Otherwise, <literal>nullptr</literal>
                            is returned.  Note that the structure of the body
                            header depends on the format version.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void </type>
                          <methodname>setBodyHeader</methodname>
                          <methodparam>
                              <type>uint64_t </type><parameter>timestamp</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t </type><parameter>sid</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t </type><parameter>barrierType</parameter>
                              <initializer>0</initializer>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            If the item has a body header it is modified as indicated
                            by the parameters.  IF not, one is created and filled in
                            as indicated by the parameters.  If the data format
                            does not support body headers, this method should
                            be a no-op.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type> virtual std::string </type>
                          <methodname>typeName</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns a string that identifies the item type.  This
                            will be one of <literal>Packet types</literal> or
                            <literal>Monitored Variables</literal>
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual std::string </type>
                          <methodname>toString</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns a string that describes the contents of
                            the item in human readable form.
                           </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </refsect1>
        </refentry>
        <refentry>
           <refmeta>
              <refentrytitle>CUnknownFragment (abstract)</refentrytitle>
              <manvolnum>3format</manvolnum>
           </refmeta>
           <refnamediv>
              <refname>CUnknownFragment (abstract)</refname>
              <refpurpose></refpurpose>
            </refnamediv>
            <refsynopsisdiv>
                <programlisting>
#include &lt;CUnknownFragment.h&gt;

class CUnknownFragment : public CRingFragmentItem
{
    
public:
    CUnknownFragment(uint64_t timestamp, uint32_t sourceid, uint32_t barrier,
                     uint32_t size, void* pPayload);

    std::string typeName() const;
    
};
                </programlisting>
            </refsynopsisdiv>
            <refsect1>
                     <title>DESCRIPTION</title>
                  <para>
                       This is identical to <classname>CRingFragmentItem</classname>
                       however the payload is known not to be a ring item.
                       The type is <literal>EVB_UNKNOWN_PAYLOAD</literal>
                  </para>
            </refsect1>
        </refentry>
       </section>
       <section>
        <title>NSCLDAQ version 10 format</title>
        <para>
            Version 10 of NSCLDAQ is the earliest version of NSCLDAQ that used
            ringbuffers and ring items for data flow.  As  such, its data
            format is the most primitive.  Version 10 does not support body headers.
            Event building in NSCLDAQ 10  motivated the addition of body headers
            in later versions.  
        </para>
        <para>
            The version 10 headers are in the v10 subdirectory of the installation
            headers.  Furthermore all classes and definitions live in the
            <literal>v10</literal> namespace.  The <filename>v10/DataFormat.h</filename>
            header provides formatting data and structs for the NSCLDAQ version
            10 internals.
        </para>
        <refentry>
           <refmeta>
              <refentrytitle>RingItemFactory (version 10)</refentrytitle>
              <manvolnum>3format</manvolnum>
           </refmeta>
           <refnamediv>
              <refname>RingItemFactory (verson 10)</refname>
              <refpurpose>Generate v10 ring item objects.</refpurpose>
            </refnamediv>
            <refsynopsisdiv>
                <programlisting>
#include &lt;v10/RingItemFactory.h&gt;

namespace v10 {
    
    class RingItemFactory : public RingItemFactoryBase {
    public:
        
        ::CRingItem* makeRingItem(uint16_t type, size_t maxBody);
        ::CRingItem* makeRingItem(uint16_t type, uint64_t timestamp, uint32_t sourceId,
                size_t maxBody, uint32_t barrierType = 0 );
        ::CRingItem* makeRingItem(const ::CRingItem&amp; rhs);
        ::CRingItem* makeRingItem(const RingItem* pRawRing);
        
        virtual CRingItem* getRingItem(CRingBuffer&amp; ringbuf) ;
        virtual CRingItem* getRingItem(int fd) ;
        virtual CRingItem* getRingItem(std::istream&amp; in);
        
        virtual std::ostream&amp; putRingItem(const CRingItem* pItem, std::ostream&amp; out) ;
        virtual void putRingItem(const CRingItem* pItem, int fd) ;
        virtual void putRingItem(const CRingItem* pItem, CRingBuffer&amp; ringbuf) ;
        
        
        virtual CAbnormalEndItem* makeAbnormalEndItem() ;
        virtual CAbnormalEndItem* makeAbnormalEndItem(const CRingItem&amp; rhs) ;
        
    
        virtual CDataFormatItem* makeDataFormatItem() ;
        virtual CDataFormatItem* makeDataFormatItem(const CRingItem&amp; rhs);
        
        
        virtual CGlomParameters* makeGlomParameters(
            uint64_t interval, bool isBuilding, uint16_t policy
        );
        virtual CGlomParameters* makeGlomParameters(const CRingItem&amp; rhs) ;
        
        
        virtual CPhysicsEventItem* makePhysicsEventItem(size_t maxBody) ;
        virtual CPhysicsEventItem* makePhysicsEventItem(
            uint64_t timestamp, uint32_t source, uint32_t barrier,
            size_t maxBody
        ) ;
        virtual CPhysicsEventItem* makePhysicsEventItem(const CRingItem&amp; rhs) ;
        
        
        virtual CRingFragmentItem* makeRingFragmentItem(
            uint64_t timestamp, uint32_t source, uint32_t payloadSize,
            const void* payload, uint32_t barrier=0
        ) ;
        virtual CRingFragmentItem* makeRingFragmentItem(const CRingItem&amp; rhs) ;
    
        
        virtual CRingPhysicsEventCountItem* makePhysicsEventCountItem(
            uint64_t count, uint32_t timeoffset, time_t stamp,
            int divisor=1
        );
        virtual CRingPhysicsEventCountItem* makePhysicsEventCountItem(const CRingItem&amp; rhs);
        
        
        virtual CRingScalerItem* makeScalerItem(size_t numScalers);
        virtual CRingScalerItem* makeScalerItem(
            uint32_t startTime,
            uint32_t stopTime,
            time_t   timestamp,
            std::vector&lt;uint32_t&gt; scalers,
            bool                  isIncremental = true,
            uint32_t              sid = 0,
            uint32_t              timeOffsetDivisor = 1
        );
        virtual CRingScalerItem* makeScalerItem(const CRingItem&amp; rhs);
        
        
        virtual CRingTextItem* makeTextItem(
            uint16_t type,
            std::vector&lt;std::string&gt; theStrings
        );
        virtual CRingTextItem* makeTextItem(
            uint16_t type,
            std::vector&lt;std::string&gt; theStrings,
            uint32_t                 offsetTime,
            time_t                   timestamp, uint32_t divisor=1
        );
        virtual CRingTextItem* makeTextItem(const CRingItem&amp; rhs);
        
        
        virtual CUnknownFragment* makeUnknownFragment(
            uint64_t timestamp, uint32_t sourceid, uint32_t barrier,
            uint32_t size, void* pPayload
        );
        virtual CUnknownFragment* makeUnknownFragment(const CRingItem&amp; rhs);
        
        virtual CRingStateChangeItem* makeStateChangeItem(
            uint32_t itemType, uint32_t runNumber,
            uint32_t timeOffset,
            time_t   timestamp,
            std::string title
        );
        virtual CRingStateChangeItem* makeStateChangeItem(const CRingItem&amp; rhs);
    };
        

}             
                </programlisting>
            </refsynopsisdiv>
            <refsect1>
                     <title>DESCRIPTION</title>
                  <para>
                    <classname>v10::RingItemFactory</classname> is a factory class
                    that creates ring items for NSCLDAQ version 10.  The classes
                    in this format class hierarchy are all in the
                    <literal>v10</literal> namespace.   They derive directly
                    from the corresponding classes in the abstract format items
                    described in the previous section.
                  </para>
                  <para>
                    Note that this allows return values to be pointer to those
                    classes.
                  </para>
                  <para>
                    Since all items are dynamically created via <function>new</function>,
                    we recommend that you use these factory methods to initialize
                    smart pointers.  For example, if you read a ring item
                    from an event file you might have a code fragment that looks
                    like the following
                  </para>
                  <example>
                    <title>Using smart pointers with the v10 factory object</title>
                    <programlisting>
#include &lt;v10/RingItemFactory.h&gt;
#include &lt;v10/DataFormat.h&gt;
#include &lt;CRingItem.h&gt;                 <co id='v10fact.includes' />
#include &lt;CRingScalerItem.h&gt;
#include &lt;memory&gt;
#include &lt;fstream&gt;

...
std::ifstream in("run-0012-00.evt", ios::in | ios::binary); <co id='v10fact.open' />
...

v10::RingItemFactory fact;
std::unique_ptr&lt;CRingItem&gt; item(fact.getRingItem(in));  <co id='v10fact.read' />

if (item->type() == v10::INCREMENTAL_SCALERS ||
    item->type() == v10::TIMESTAMPED_NONINCR_SCALERS)) {
    std::unique_ptr&lt;CRingScalerItem&gt; scaler(fact.makeScalerItem(*item)); <co id='v10fact.make' />
    processScalers(scaler);                                <co id='v10fact.procscaler' />
}

...

                    </programlisting>
                  </example>
                  <calloutlist>
                    <callout arearefs='v10fact.includes' >
                        <para>
                            The headers we need include the data format header
                            which supplies the ring item types, the
                            factory the base <classname>CRingItem</classname>
                            and <classname>CRingScalerItem</classname>
                            definitions so that the compiler knows the
                            virtual method interfaces.
                        </para>
                        <para>
                            The file stream header and memory header are needed
                            to get data from the stream and to store pointers
                            into a smart pointer object to ensure the objects
                            we create get destroyed.
                        </para>
                    </callout>
                    <callout arearefs='v10fact.open' >
                        <para>
                            When opening a stream on an event file we must not only
                            specify we're going to read it but that we'll also
                            want the stream opened in binary mode to prevent any
                            character based translations that  otherwise might occur.
                        </para>
                    </callout>
                    <callout arearefs='v10fact.read' >
                        <para>
                            The factories provide a method to read a ring item
                            from a stream and wrap it with a <classname>CRingItem</classname>
                            base class.  This line does that and stores the pointer
                            to the resulting, dynamically created object in a
                            <classname>std::unique_ptr</classname> so that we don't
                            have to worry about deallocating the object later in
                            the code.
                        </para>
                    </callout>
                    <callout arearefs='v10fact.make' >
                        <para>
                            After determining that <varname>item</varname>
                            'points' to a scaler item, we use the
                            <methodname>makeScalerItem</methodname> factory
                            method to take a copy of the data and wrap it in a
                            version 10 scaler item.  The pointer to this is
                            also stored in a <classname>std::unique_ptr</classname>
                            object.
                        </para>
                    </callout>
                    <callout arearefs='v10fact.procscaler' >
                        <para>
                            The <function>processScaler</function> call just
                            represents some arbitrary processing.  While
                            <varname>item</varname> is valid after the
                            if block exits, the <classname>scaler</classname>
                            object is freed when that block exits so all
                            processing of the scaler must be done prior
                            to exiting that block.
                        </para>

                    </callout>
                  </calloutlist>
            </refsect1>
            <refsect1>
                <title>METHODS</title>
                <variablelist>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>::CRingItem* </type>
                          <methodname>makeRingItem</methodname>
                          <methodparam>
                              <type>uint16_t </type><parameter>type</parameter>
                          </methodparam>
                          <methodparam>
                              <type>size_t </type><parameter>maxBody</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Creates a new ring item that is undifferentiated,
                            that is it implements no type specific methods.
                            <parameter>type</parameter> is put in the ring item
                            header's type field.  Storage capacity sufficient for
                            a body of up to <parameter>maxBody</parameter>
                            bytes of data are reserved though you'll need to
                            communicate the size of the item (normally via
                            the object's <methodname>setBodyCursor</methodname>
                            and <methodname>updateSize</methodname> methods) to
                            actually fill in the header's size field.
                           </para>
                           <para>
                            The returned value is a pointer to a
                            <classname>v10::CRingItem</classname> object
                            (cast to <classname>::CRingItem</classname>).
                            The caller is responsible for deleting the object
                            when it is no longer needed (e.g. by initializing a smart
                            pointer object with it).
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>::CRingItem* </type>
                          <methodname>makeRingItem</methodname>
                          <methodparam>
                              <type>uint16_t </type><parameter>type</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint64_t </type><parameter>timestamp</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t </type><parameter>sourceId</parameter>
                          </methodparam>
                          <methodparam>
                              <type>size_t </type><parameter>maxBody</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t</type><parameter> barrierType</parameter>
                              <initializer>0</initializer>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Creates an undifferentiateded ring item that is parameterized
                            for a body header.  Since version 10 does not support
                            body headers, the remaining parameters are silently
                            ignored.  This method, however allows the V10 factory
                            to be treated interchangeably with e.g. the V11
                            factory once it has been created.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>::CRingItem* </type>
                          <methodname>makeRingItem</methodname>
                          <methodparam>
                              <type>const ::CRingItem&amp; </type><parameter>rhs</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Makes a ring item by copying the contents of another
                            ring item.  Note that the results are not well defined
                            if the <parameter>rhs</parameter> item comes from
                            a different ring item format than this factory
                            (e.g. is a version 12 ring item).
                           </para>
                           <para>
                            In practice this is not a problem unless you are writing
                            a format converter.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>::CRingItem* </type>
                          <methodname>makeRingItem</methodname>
                          <methodparam>
                              <type>const RingItem* </type><parameter>pRawRing</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Wraps a raw ring item in a <classname>v10::CRingItem</classname>
                            object and returns a pointer to that object.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual CRingItem* </type>
                          <methodname>getRingItem</methodname>
                          <methodparam>
                              <type>CRingBuffer&amp;</type><parameter>ringbuf</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Reads a ring item from the ringbuffer
                            <parameter>ringbuf</parameter> and wraps it in a new
                            <type>v10::CRingBuffer</type>.
                           </para>
                           <para>
                            <parameter>ringbuf</parameter> must be attached to
                            the ring buffer in consumer mode.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual CRingItem* </type>
                          <methodname>getRingItem</methodname>
                          <methodparam>
                              <type>int</type><parameter> fd</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Reads a ring item from the entity open on the linux
                            file descriptor <parameter>fd</parameter> and wraps it
                            into a new <type>v10::CRingBuffer</type>.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual CRingItem* </type>
                          <methodname>getRingItem</methodname>
                          <methodparam>
                              <type>std::istream&amp; </type><parameter>in</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Reads a ring item from the C++ <classname>istream</classname>
                            referenced by <parameter>in</parameter> and wraps it in a
                            <classname>v10::CRingItem</classname>.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual std::ostream&amp;</type>
                          <methodname> putRingItem</methodname>
                          <methodparam>
                              <type>const CRingItem*</type><parameter> pItem</parameter>
                          </methodparam>
                          <methodparam>
                              <type>std::ostream&amp; </type><parameter>out</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Puts the wrapped ring item pointed to by <parameter>pItem</parameter>
                            in the <classname>std::ostream</classname> referenced by <parameter>out</parameter>.
                            The raw binary of the ring item is output which allows it to be read in using
                             <methodname>getRingItem</methodname> at some later date.
                           </para>
                           <para>
                            The <parameter>out</parameter> stream must be open
                            for write and in binary mode.  Note any actual ring item
                            type can be used for the <parameter>pItem</parameter>
                            since they all ultimately descend from
                            <classname>::CRingItem</classname>.
                           </para>
                           <para>
                            The method, like most C++ stream I/O methods, returns
                            a reference to <parameter>out</parameter> following the
                            put.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void </type>
                          <methodname>putRingItem</methodname>
                          <methodparam>
                              <type>const ::CRingItem*</type><parameter> pItem</parameter>
                          </methodparam>
                          <methodparam>
                              <type>int </type><parameter>fd</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Writes the ring item pointed to by
                            <parameter>pItem</parameter> to the file descriptor
                            <parameter>fd</parameter>
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void </type>
                          <methodname>putRingItem</methodname>
                          <methodparam>
                              <type>const ::CRingItem* </type><parameter>pItem</parameter>
                          </methodparam>
                          <methodparam>
                              <type>CRingBuffer&amp;</type><parameter>ringbuf</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Writes the ring item pointed to by
                            <parameter>pItem</parameter> to the ringbuffer
                            referenced by <parameter>ringbuf</parameter>.
                            <parameter>ringbuf</parameter> must be attached
                            to the ring buffer in producer mode.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type> virtual ::CAbnormalEndItem* </type>
                          <methodname>makeAbnormalEndItem</methodname>
                          <void />
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Creates a new abnormal end run item.  Note that this item
                            type was added to the NSCLDAQ ring item set
                            <emphasis>after</emphasis> version 10. This method
                            therefore always returns a <literal>nullptr</literal>
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual ::CAbnormalEndItem* </type>
                          <methodname>makeAbnormalEndItem</methodname>
                          <methodparam>
                              <type>const CRingItem&amp;</type><parameter>rhs</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Normally, if <parameter>rhs</parameter> references
                            an abnormal end item, this will create a new copy
                            of that item with the specific type, a pointer
                            to <classname>v10::CAbnormalEndItem</classname>.
                            However, since the abnormal end ring item type
                            was introduced <emphasis>after</emphasis> version 10,
                            this always throws <classname>std::bad_cast</classname>.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual ::CDataFormatItem* </type>
                          <methodname>makeDataFormatItem</methodname>
                          <void />
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Normally, this creates  a new data format item.
                            This ring item type, however was introduced
                            <emphasis>after</emphasis> NSCLDAQ version 10.
                            This method therefore returns a
                            <literal>nullptr</literal>
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual ::CDataFormatItem* </type>
                          <methodname>makeDataFormatItem</methodname>
                          <methodparam>
                              <type>const CRingItem&amp;</type><parameter>rhs</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Normally, if <parameter>rhs</parameter>
                            references a data format item, this method will
                            produce a duplicate item and return a pointer to it.
                            However, since the data format ring item type
                            was introduced <emphasis>after</emphasis> version 10,
                            this method always throws a
                            <classname>std::bad_cast</classname>.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual ::CGlomParameters*</type>
                          <methodname> makeGlomParameters</methodname>
                          <methodparam>
                              <type>uint64_t </type><parameter>interval</parameter>
                          </methodparam>
                          <methodparam>
                              <type>bool </type><parameter>isBuilding</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint16_t </type><parameter>policy</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Normally this would produce an event builder (glom)
                            parameter documentation ring item. However, since
                            this item type was introduced <emphasis>after</emphasis>
                            version 10, this will always return <literal>nullptr</literal>.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                          <term><methodsynopsis>
                             <type>::CGlomParameters*</type>
                             <methodname>makeGlomParameters</methodname>
                             <methodparam>
                                 <type>const ::CRingItem&amp; </type><parameter>rhs</parameter>
                             </methodparam>
                          </methodsynopsis></term>
                          <listitem>
                              <para>
                                Normally creates a glom parameters item from
                                the contents of <parameter>rhs</parameter>, if it
                                is a glom parameters item. However, since the
                                glom parameters item type was introduced
                                <emphasis>after</emphasis> version 10, this
                                always throws <classname>std::bad_cast</classname>.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual ::CPhysicsEventItem* </type>
                          <methodname>makePhysicsEventItem</methodname>
                          <methodparam>
                              <type>size_t </type><parameter>maxBody</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Creates and returns a pointer to a physics event item
                            (<classname>v10::CPhysicsEventItem</classname>). The
                            capacity of the item will be sufficient for the item
                            to have a body of <parameter>maxBody</parameter>.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type> virtual ::CPhysicsEventItem* </type>
                          <methodname>makePhysicsEventItem</methodname>
                          <methodparam>
                              <type>uint64_t </type><parameter>timestamp</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t </type><parameter>source</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t </type><parameter>barrier</parameter>
                          </methodparam>
                          <methodparam>
                              <type>size_t </type><parameter>maxBody</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Makes a physics event with a body header filled in
                            from the additional parameters.  Note,  however that
                            since body headers were introduced in format versions
                            later than 10; the additional parameters are
                            silently ignored and a physics item is made in
                            version 10 format.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type> virtual ::CPhysicsEventItem* </type>
                          <methodname>makePhysicsEventItem</methodname>
                          <methodparam>
                              <type>const ::CRingItem&amp;</type><parameter>rhs</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Given an undifferentiated ring item that
                            encapsulates a physics event item in <parameter>rhs</parameter>,
                            constructs an actual <classname>v10::CPhysicsEventItem</classname>
                            returning a pointer to the constructed item.
                            If the type of the item is not <literal>v10::PHYSICS_EVENT</literal>
                            a <classname>std::bad_cast</classname> exception is thrown.
                           </para>
                           <para>
                            Note that if the item is from a different version of
                            NSCLDAQ, the behavior of the resulting item
                            is not welll defined.  Consider for example, if
                            <parameter>rhs</parameter> is v11 ring item with
                            a body header.  The resulting
                            <classname>v10::CPhysicsEventItem</classname> object
                            will think the body begins where the body header lives
                            and will continue to claim the object has no body
                            header and act accordingly.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual ::CRingFragmentItem* </type>
                          <methodname>makeRingFragmentItem</methodname>
                          <methodparam>
                              <type>uint64_t </type><parameter>timestamp</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t</type><parameter> source</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t </type><parameter>payloadSize</parameter>
                          </methodparam>
                          <methodparam>
                              <type>const void* </type><parameter>payload</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t</type><parameter> barrier</parameter>
                              <initializer>0</initializer>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns a ring fragment item with the timestamp,
                            source id and barrier as described by the
                            <parameter>timestamp</parameter>,
                            <parameter>source</parameter>, and
                            <parameter>barrier</parameter> parameters.
                            The payload size and contents are as in
                            <parameter>payloadSize</parameter> and
                            <parameter>payload</parameter>.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual ::CRingFragmentItem*</type>
                          <methodname> makeRingFragmentItem</methodname>
                          <methodparam>
                              <type>const ::CRingItem&amp;</type><parameter> rhs</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            If <parameter>rhs</parameter> is a ring fragment item returns a fragment
                            item that is functionally equivalent to <parameter>rhs</parameter>.
                            If <parameter>rhs</parameter> is not a fragment item,
                            throws a <classname>std::bad_cast</classname>
                            exception.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual ::CRingPhysicsEventCountItem* </type>
                          <methodname>makePhysicsEventCountItem</methodname>
                            <methodparam>
                                <type>uint64_t</type><parameter>count</parameter>
                            </methodparam>
                            <methodparam>
                                <type>uint32_t </type><parameter>timeoffset</parameter>
                            </methodparam>
                            <methodparam>
                                <type>time_t </type><parameter>stamp</parameter>
                            </methodparam>
                            <methodparam>
                                <type>int </type><parameter>divisor</parameter>
                                <initializer>1</initializer>
                            </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Makes a physics event count item in version 10 format.
                            <parameter>count</parameter> must be the number
                            of triggers handled by the readout system at
                            <parameter>timeoffset</parameter> into the run.
                            <parameter>divisor</parameter> is the number of
                            ticks of <parameter>timeoffset</parameter> in one second.
                           </para>
                           <para>
                            <parameter>stamp</parameter> is the clock time at which
                            the item is being created (should be during the run not
                            during analysis).  It can be generated by a call
                            to the unix <function>time</function> service.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual ::CRingPhysicsEventCountItem* </type>
                          <methodname>makePhysicsEventCountItem</methodname>
                          <methodparam>
                            <type>const ::CRingItem&amp; </type><parameter>rhs</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            If <parameter>rhs</parameter> is an undifferentiated
                            ring item that wraps a physics event count item,
                            this method creates a new
                            <classname>v10::CRingPhysicsEventCountItem</classname>
                            that contains the same information as
                            <parameter>rhs</parameter>.  
                           </para>
                           <para>
                            Note that if
                            <parameter>rhs</parameter> is not a
                            <literal>v10::PHYSICS_EVENT_COUNT</literal> ring
                            item, a <classname>std::bad_cast</classname>
                            exception is thrown.   The behavior of this
                            generator method is not well defined if the
                            ring item comes from another version of NSCLDAQ.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual ::CRingScalerItem* </type>
                          <methodname>makeScalerItem</methodname>
                          <methodparam>
                              <type>size_t </type><parameter>numScalers</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Create a scaler item for V10 that has storage reserved
                            for <parameter>numScalers</parameter> scalers.
                            The interval start and end time must be set
                            at a later time. The scaler storage is initialized
                            to zero and the clock time stamp is initialized to the
                            time this method is called.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual ::CRingScalerItem*</type>
                          <methodname> makeScalerItem</methodname>
                          <methodparam>
                              <type>uint32_t </type><parameter>startTime</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t</type><parameter> stopTime</parameter>
                          </methodparam>
                          <methodparam>
                              <type>time_t</type><parameter>timestamp</parameter>
                          </methodparam>
                          <methodparam>
                              <type>std::vector&lt;uint32_t&gt; </type><parameter>scalers</parameter>
                          </methodparam>
                          <methodparam>
                              <type>bool  </type><parameter>isIncremental </parameter>
                              <initializer>true</initializer>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t </type><parameter> sid </parameter>
                              <initializer>0</initializer>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t</type><parameter>timeOffsetDivisor</parameter>
                              <initializer>1</initializer>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Creates a version 10  scaler item that is fully
                            populated.  There are two types of version 10 scaler
                            raw ring items.  The actual type produced depends
                            on the <parameter>isincremental</parameter> value.
                            If  <literal>true</literal>, an incremental
                            scaler item is produced.  Otherwise a non incremental
                            high resolution time scaler item is produced
                            (see <filename>v10/DataFormat.h</filename>).
                           </para>
                           <para>
                            The scaler counting interval is between
                            <parameter>startTime</parameter> and <parameter>stopTime</parameter>.
                            If <parameter>incremental</parameter> is true these
                            must be in units of seconds.  If <parameter>incremental</parameter>
                            is <literal>true</literal>, the number of ticks in
                            a second is given by <parameter>timeOffsetDivisor</parameter>.
                           </para>
                           <para>
                            The <parameter>scalers</parameter> vector provides
                            the counter values. <parameter>timestamp</parameter>
                            provides the clock time at which the scalers
                            were read.
                           </para>
                           <para>
                            Since v10 ring items have no concept of a
                            source id, the <parameter>sid</parameter> parameter
                            is ignored.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual ::CRingScalerItem* </type>
                          <methodname>makeScalerItem</methodname>
                          <methodparam>
                              <type>const CRingItem&amp;</type><parameter> rhs</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            If <parameter>rhs</parameter> is a scaler item
                            a new <classname>v10::CRingScalerItem</classname> is
                            made from the data in <parameter>rhs</parameter>.
                            If <parameter>rhs</parameter> is not of type
                            <literal>v10::INCREMENTAL_SCALERS</literal>, or
                            <literal>v10::TIMESTAMPED_NONINCR_SCALERS</literal>
                            a <classname>std::bad_cast</classname> exception
                            is thrown.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual CRingTextItem* </type>
                          <methodname>makeTextItem</methodname>
                          <methodparam>
                              <type>uint16_t </type><parameter>type</parameter>
                          </methodparam>
                          <methodparam>
                              <type>std::vector&lt;std::string&gt; </type><parameter>theStrings</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Creates an item that contains text strings.
                            <parameter>type</parameter> is the ring item
                            type and must be one of <literal>v10::PACKET_TYPES</literal>
                            or <literal>v10::MONITORED_VARIABLES</literal>.
                            The strings themselves are taken from the vector
                            <parameter>theStrings</parameter>.
                           </para>
                           <para>
                            The clock time is filled in from the time at which this
                            method is called and the run time offset is
                            initialized to <literal>0</literal>
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual CRingTextItem* </type>
                          <methodname>makeTextItem</methodname>
                          <methodparam>
                              <type>uint16_t </type><parameter>type</parameter>
                          </methodparam>
                          <methodparam>
                              <type>std::vector&lt;std::string&gt;</type><parameter> theStrings</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t   </type><parameter>offsetTime</parameter>
                          </methodparam>
                          <methodparam>
                              <type>time_t  </type><parameter>timestamp</parameter>
                          </methodparam>
                            <methodparam>
                            <type>uint32_t </type><parameter>divisor</parameter>
                            <initializer>1</initializer>
                        </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Same as the previous methods however the additional
                            parameters serve to initialize other bits otf the
                            ring item: <parameter>offsetTime</parameter>  and
                            <parameter>divisor</parameter> descdribe the offset into
                            the run at which the item was emitted, however the
                            divisor is ignored in v10 and <parameter>offsetTime</parameter>
                            must be in units of seconds.  <parameter>timestamp</parameter>
                            is the clock time to associated with the item.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual CRingTextItem*</type>
                          <methodname> makeTextItem</methodname>
                          <methodparam>
                              <type>const CRingItem&amp;</type><parameter> rhs</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Given an undifferentiated ring item; <parameter>rhs</parameter>
                            that encpasulates a valid text item creats a new
                            <classname>v10::CRingTextItem</classname> from the
                            data in <parameter>rhs</parameter>.  If the item is not
                             a valid v10 text item,
                             a <classname>std::bad_cast</classname>
                             exception is thrown.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual CUnknownFragment* </type>
                          <methodname>makeUnknownFragment</methodname>
                          <methodparam>
                              <type>uint64_t </type><parameter>timestamp</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t </type><parameter>sourceid</parameter>
                          </methodparam>
                          <methodparam>
                            <type>uint32_t </type><parameter>barrier</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t </type><parameter>size</parameter>
                          </methodparam>
                          <methodparam>
                              <type>void*</type><parameter> pPayload</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns <literal>nullptr</literal> because
                            the unknown fragment ring item type was only
                            introduced after version 10.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual CUnknownFragment* </type>
                          <methodname>makeUnknownFragment</methodname>
                          <methodparam>
                              <type>const CRingItem&amp;</type><parameter>rhs</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Throws a <classname>std::bad_cast</classname>
                            exception because the unknown fragment ring item type
                            was not introduced until after version 10.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual CRingStateChangeItem* </type>
                          <methodname>makeStateChangeItem</methodname>
                          <methodparam>
                              <type>uint32_t </type><parameter>itemType</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t </type><parameter>runNumber</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t</type><parameter> timeOffset</parameter>
                          </methodparam>
                          <methodparam>
                              <type>time_t </type><parameter>timestamp</parameter>
                          </methodparam>
                          <methodparam>
                              <type>std::string </type><parameter>title</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Creates a new run state change item formatted for
                            version 10.  The <parameter>itemType</parameter>
                            defines the new run state and must be one of
                            <literal>v10::BEGIN_RUN</literal>,
                            <literal>v10::PAUSE_RUN</literal>,
                            <literal>v10::RESUME_RUN</literal>,
                            or <literal>v10::END_RUN</literal>.  If it is none of those,
                            a <classname>std::bad_cast</classname> exception is
                            thrown.
                           </para>
                           <para>
                            The remaining parameters define parameters of the run:
                            <parameter>runNumber</parameter> is the unique number
                            of the run.  <parameter>timeOffset</parameter> is
                            the offset into the run at which the state change
                            occurerd.  In v10, this must be in units of seconds.
                            <parameter>timestamp</parameter> is the clock time
                            at which the state transition happened.
                            Finally, <parameter>title</parameter> is the
                            title string associated with the run. 
                           </para>
                           <para>
                            Note that
                            all state change items associated with the same
                            run should have the same title and run number.
                            This is not enforced.  The <parameter>timeOffset</parameter>
                            for a <literal>v10::BEGIN_RUN</literal> item should
                            always be <literal>0</literal>, but this too is not
                            enforced.  Finally, the <parameter>timestamp</parameter>
                            parameter can be the output of a call to the
                            unix <function>time</function> function.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual CRingStateChangeItem* </type>
                          <methodname>makeStateChangeItem</methodname>
                          <methodparam>
                              <type>const CRingItem&amp;</type><parameter> rhs</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            If <parameter>rhs</parameter> is an undifferentiated
                            ring item that encapsualtes a valid v10 run state
                            transition ring object, a new
                            <classname>v10::CRingStateChangeItem</classname>
                            is created encapsulating the same information.
                            If <parameter>rhs</parameter> is not a valid
                            v10 run state transition item,
                            a <classname>std::bad_cast</classname> exception
                            is thrown.
                           </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
                
            </refsect1>
        </refentry>
        <refentry>
           <refmeta>
              <refentrytitle>CRingItem (version 10)</refentrytitle>
              <manvolnum>3format</manvolnum>
           </refmeta>
           <refnamediv>
              <refname>CRingItem (version 10)</refname>
              <refpurpose>Version 10 ring item class.</refpurpose>
            </refnamediv>
            <refsynopsisdiv>
                <programlisting>
#include &lt;v10/CRingItem.h&gt;


namespace v10 {

    class CRingItem  : public ::CRingItem{
    
    public:
      CRingItem(uint16_t type, size_t maxBody = 8192);
    
      virtual size_t getBodySize() const;
      virtual void*  getBodyPointer();
      virtual const void* getBodyPointer() const;
    
      virtual void* getBodyHeader() const;
      virtual void setBodyHeader(
        uint64_t timestamp, uint32_t sourceId, uint32_t barrierType = 0
      );
      virtual std::string typeName() const;	// Textual type of item.
      virtual std::string toString() const; // Provide string dump of the item.
      
    };
}
                </programlisting>
            </refsynopsisdiv>
            <refsect1>
                     <title>DESCRIPTION</title>
                  <para>
                    This class is derived from the abstract
                    <classname>::CRingItem</classname>.  It provides
                    essential services for V10 formatted ring items.
                  </para>
            </refsect1>
            <refsect1>
                <title>METHODS</title>
                <variablelist>
                    <varlistentry>
                       <term><constructorsynopsis>
                           <methodname>CRingItem</methodname>
                        <methodparam>
                            <type>uint16_t </type><parameter>type</parameter>
                        </methodparam>
                        <methodparam>
                            <type>size_t</type><parameter> maxBody</parameter>
                            <initializer>8192</initializer>
                        </methodparam>
                       </constructorsynopsis></term>
                       <listitem>
                           <para>
                            Creates a new encapsulating object for a ring item in
                            version 10 format.  <parameter>type</parameter> specifies
                            a ring item type and, normally, comes from the
                            types in <filename>v10/DataFormat.h</filename>.
                            <parameter>maxBody</parameter> defines the capacity
                            of the internally managed storage needed for the
                            item.  If the default or smaller are used, a
                            statically allocated internal buffer is used, negating
                            the need for additional dynamic memory management.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual size_t </type>
                          <methodname>getBodySize</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Computes the size of the body (payload) section
                            of the encapsulated ring item. In version 10, this is
                            just the ring item size (as defined by the last
                            call to <methodname>setBodyCursor</methodname>)
                            minus the size of a <type>v10::RingItemHeader</type>
                            (defined in <filename>/v10/DataFormat.h</filename>)
                           </para>
                           <para>
                            Normally you will fill in the contents of the ring item
                             using <methodname>getBodyCursor</methodname> to obtain
                             a pointer to the next available byte of the payload,
                             and <methodname>setBodyCursor</methodname> to inform
                             the object if that changes followed by
                             <methodname>updateSize</methodname> to recompute
                             the header size field based on the value of
                             the body cursor.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void*  </type>
                          <methodname>getBodyPointer</methodname>
                          <void />
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns a mutable pointer to the body of the
                            object.  In the case of version 10, this will always
                            point past the ring item header.  In later formats,
                            with optional body headers, this will not be the
                            case.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual const void* </type>
                          <methodname>getBodyPointer</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns an immutable pointer to the object's body.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void* </type>
                          <methodname>getBodyHeader </methodname>
                          <void /> <modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Always returns a <literal>nullptr</literal>
                            since version 10 does not support body headers.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void </type>
                          <methodname>setBodyHeader</methodname>
                          <methodparam>
                              <type>uint64_t </type><parameter>timestamp</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t </type><parameter>sourceId</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t </type><parameter>barrierType</parameter>
                              <initializer>0</initializer>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Since version 10 does not support body headers,
                            this method silently does nothing.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual std::string </type>
                          <methodname>typeName</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns a string that indicates the item
                            is of an unknown type.  This is because
                            <classname>v10::CRingItem</classname> is
                            an undifferentiated ring item capsule. If the
                            <classname>RingItemFactory</classname> is used
                            to set the actual ring item type, the resulting
                            class will return a more useful result.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual std::string </type>
                          <methodname>toString</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns a string that describes the contents of the
                            ring item.
                           </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </refsect1>
        </refentry>
        <refentry>
           <refmeta>
              <refentrytitle>CRingFragmentItem (version 10)</refentrytitle>
              <manvolnum>3format</manvolnum>
           </refmeta>
           <refnamediv>
              <refname>CRingFragmentItem (version 10)</refname>
              <refpurpose>Event builder fragment</refpurpose>
            </refnamediv>
            <refsynopsisdiv>
                <programlisting>
#include &lt;v10/CRingFragmentItem.h&gt;

namespace v10 {


    class CRingFragmentItem : public ::CRingFragmentItem
    {
     
      // Implemented canonical items:
    
    public:
      CRingFragmentItem(uint64_t timestamp, 
                uint32_t source, 
                uint32_t payloadSize, 
                const void* pBody,
                uint32_t barrier=0);
      
      virtual uint64_t     timestamp() const;
      virtual uint32_t     source() const;
      virtual size_t       payloadSize()   const;
      virtual void*  payloadPointer();
      virtual uint32_t     barrierType() const;
 
      virtual bool hasBodyHeader() const;
      virtual void* getBodyHeader() const;
      virtual void setBodyHeader(uint64_t timestamp, uint32_t sourceId,
                             uint32_t barrierType = 0) ;
      
      virtual std::string typeName() const;
      virtual std::string toString() const;
 
    };
}

                </programlisting>
            </refsynopsisdiv>
            <refsect1>
                     <title>DESCRIPTION</title>
                  <para>
                    Ring fragment items are event builder fragments wrapped in
                    a ring item.  Event builder fragments have a header that contains
                    the timestamp, source id and barrier type from the fragment
                    and the fragment data itself.  The fragment data is referred
                    to in the class documentation as the <firstterm>payload</firstterm>.
                  </para>
                  <para>
                    The payload  is assumed to be a ring item for items with this
                    item type by default.  If one edits the item type to be
                    <literal>v10::EVB_UNKNOWN_PAYLOAD</literal>, no such
                    assumption can be made.
                  </para>
            </refsect1>
            <refsect1>
                <title>METHODS</title>
                <variablelist>
                    <varlistentry>
                       <term><constructorsynopsis>
                           <methodname>CRingFragmentItem</methodname>
                            <methodparam>
                                <type>uint64_t </type><parameter>timestamp</parameter>
                            </methodparam>
                            <methodparam>
                                <type>uint32_t </type><parameter>source</parameter>
                            </methodparam>
                            <methodparam>
                                <type>uint32_t </type><parameter>payloadSize</parameter>
                            </methodparam>
                            <methodparam>
                                <type>const void*</type><parameter> pBody</parameter>
                            </methodparam>
                            <methodparam>
                                <type>uint32_t </type><parameter>barrier</parameter>
                                <initializer>0</initializer>
                            </methodparam>
                       </constructorsynopsis></term>
                       <listitem>
                           <para>
                            <parameter>timestamp</parameter> is the fragment
                            timestamp that will be put in the header.
                            <parameter>source</parameter> is the source id of the
                            fragment that also will be put in the header.
                           </para>
                           <para>
                            <parameter>payloadSize</parameter> and <parameter>pBody</parameter>
                            specify the number of bytes of payload and the source
                            of the data that will be put in the payload part of the
                            ring item.
                           </para>
                           <para>
                            If the optional <parameter>barrier</parameter>
                            parameter is specified it provides a barrier type to
                            be put in the header.  Otherwise a barrier type of
                            zero is used which is no barrier.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual uint64_t     </type>
                          <methodname>timestamp</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the timestamp from the item's body header.
                            Note that by definition, fragment items have
                            a body header.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual uint32_t     </type>
                          <methodname>source</methodname>
                          <void /><modifier> const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the source id from the item's body header.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual size_t  </type>
                          <methodname>payloadSize</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the size of the payload. Note that it is
                            acceptable, and normal for this to be computed by the
                            implementation from the ring item size and the body
                            header size
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void*        </type>
                          <methodname>payloadPointer</methodname>
                          <void />
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns a pointer to the payload data.  The pointer
                            allows the data to be edited as well as simply
                            inspected.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual uint32_t     </type>
                          <methodname>barrierType</methodname>
                          <void />
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the item's body header barrier type field.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual std::string </type>
                          <methodname>typeName</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns a string that describes the type of the
                            ring item: <literal>Event fragment</literal>
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual std::string </type>
                          <methodname>toString</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns a string representation of the  contents of
                            the ring item. This is used e.g. by
                            <command>dumper</command>
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void </type>
                          <methodname>setBodyHeader</methodname>
                          <methodparam>
                              <type>uint64_t </type><parameter>timestamp</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t </type><parameter>sourceId</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t </type><parameter>barrierType </parameter>
                              <initializer>0</initializer>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                           Does nothing.  V10 ring items never have a body header.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void* </type>
                          <methodname>getBodyHeader</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns a <literal>nullptr</literal>.
                            V10 ring items never have a body header.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual bool</type>
                          <methodname> hasBodyHeader</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns <literal>false</literal>.  v10 Ring items
                            never have a body header.
                           </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </refsect1>
        </refentry>
        <refentry>
           <refmeta>
              <refentrytitle>CRingPhysicsEventCountItem (v10)</refentrytitle>
              <manvolnum>3format</manvolnum>
           </refmeta>
           <refnamediv>
              <refname>CRingPhysicsEventCountItem (v10)</refname>
              <refpurpose>Encapsulate trigger count ring item.</refpurpose>
            </refnamediv>
            <refsynopsisdiv>
                <programlisting>
#include &lt;v10/RingPhysicsEventCountItem.h&gt;

namespace v10 {

class CRingPhysicsEventCountItem : public ::CRingPhysicsEventCountItem
{
public:
  CRingPhysicsEventCountItem();
  CRingPhysicsEventCountItem(uint64_t count,
			     uint32_t timeOffset);
  CRingPhysicsEventCountItem(uint64_t count, 
			     uint32_t timeoffset, 
			     time_t stamp);
  
  virtual uint32_t getTimeOffset() const;
  virtual void     setTimeOffset(uint32_t offset);
  virtual float    computeElapsedTime() const;
  virtual uint32_t getTimeDivisor() const;
  

  virtual time_t   getTimestamp() const;
  virtual void     setTimestamp(time_t stamp);

  virtual uint64_t getEventCount() const;
  virtual void     setEventCount(uint64_t count);

  virtual void setBodyHeader(uint64_t timestamp, uint32_t sourceId,
                         uint32_t barrierType = 0);
  virtual void* getBodyHeader() const; 

  virtual std::string typeName() const;	// Textual type of item.
  virtual std::string toString() const; // Provide string dump of the item.

};

}
                </programlisting>
            </refsynopsisdiv>
            <refsect1>
                     <title>DESCRIPTION</title>
                  <para>
                    NSCLDAQ uses event count items to encapsulate the
                    number of triggers that have been processed to date in a run.
                    This can be used by sampling on-line analysis programs to
                    determine the fraction of data actually analyzed.
                    Specifically, the number of items processed by the analysis program
                    divided by the number of triggers is the fraction of data.
                  </para>
                  <para>
                    Note that the glom stage of the event builder emits event
                    count items that treat each built event as a trigger.
                    Those items have a body header that provides the source id
                    the event builder has been told to emit.
                  </para>
            </refsect1>
            <refsect1>
                <title>METHODS</title>
                <variablelist>
                    <varlistentry>
                       <term><constructorsynopsis>
                           <methodname>CRingPhysicsEventCountItem</methodname>
                        <void />
                       </constructorsynopsis></term>
                       <listitem>
                           <para>
                            Constructs an event count item with a count of zero,
                            run time offset of zero and timestamp of the time
                            the constructor was invoked.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><constructorsynopsis>
                           <methodname>CRingPhysicsEventCountItem</methodname>
                        <methodparam>
                            <type>uint64_t </type><parameter>count</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint32_t </type><parameter>timeOffset</parameter>
                        </methodparam>
                        
                       </constructorsynopsis></term>
                       <listitem>
                           <para>
                            Creates an event count item where the trigger
                            count is initialized to <parameter>count</parameter>.
                            The run offset is given by <parameter>timeOffset</parameter>.
                            Version 10 does not have the concept of a timestamp
                            divisor. Therefore, <parameter>timeOffset</parameter>
                            must be in units of seconds.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><constructorsynopsis>
                           <methodname>CRingPhysicsEventCountItem</methodname>
                        <methodparam>
                            <type>uint64_t </type><parameter>count</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint32_t </type><parameter>timeoffset</parameter>
                        </methodparam>
                        <methodparam>
                            <type>time_t </type><parameter>stamp</parameter>
                        </methodparam>
                        
                       </constructorsynopsis></term>
                       <listitem>
                           <para>
                            Full construction of a physics event count item
                            with a prototypical body header.  The additional
                            parameter from the previous constructor are
                            <parameter>stamp</parameter>, which provides
                            the clock time at which the item was constructed.
                           </para>
                           <para>
                            In comparing this constructor with those from
                            other versions, note that v10 does not support
                            body headers.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual uint32_t </type>
                          <methodname>getTimeOffset</methodname>
                          <void /> <modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the raw time offset into the run at which
                            this item was created.  Note that
                            <methodname>computeElapsedTime</methodname> is the
                            preferred method to get the elapsed run time.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void     </type>
                          <methodname>setTimeOffset</methodname>
                          <methodparam>
                              <type>uint32_t</type><parameter> offset</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Sets the object's raw run time offset.  This
                            offset is uncorrected by the offset divisor.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual float    </type>
                          <methodname>computeElapsedTime</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Computes the elapsed time in the run at which this
                            was emitted from the raw offset and the divisor.
                            Units are seconds.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual uint32_t </type>
                          <methodname>getTimeDivisor</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the number of ticks in a second in the
                            elapsed time raw value.  For version 10, this will
                            always return <literal>1</literal>
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type> virtual time_t   </type>
                          <methodname>getTimestamp</methodname>
                          <void />
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Return the clock time associated with the item.
                           </para>
                        </listitem>
                    </varlistentry>
                   <varlistentry>
                      <term><methodsynopsis>
                         <type>virtual void     </type>
                         <methodname>setTimestamp</methodname>
                         <methodparam>
                             <type>time_t </type><parameter>stamp</parameter>
                         </methodparam>
                      </methodsynopsis></term>
                      <listitem>
                          <para>
                            Sets the clock time associated with the item.
                       </para>
                    </listitem>
                   </varlistentry>
                   <varlistentry>
                      <term><methodsynopsis>
                         <type>virtual uint64_t </type>
                         <methodname>getEventCount</methodname>
                         <void /><modifier>const</modifier>
                      </methodsynopsis></term>
                      <listitem>
                          <para>
                            Return the number of triggers documented by this
                            item.
                       </para>
                    </listitem>
                   </varlistentry>
                   <varlistentry>
                      <term><methodsynopsis>
                         <type>virtual void     </type>
                         <methodname>setEventCount</methodname>
                         <methodparam>
                             <type>uint64_t </type><parameter>count</parameter>
                         </methodparam>
                      </methodsynopsis></term>
                      <listitem>
                          <para>
                            sets the item's trigger count.
                       </para>
                    </listitem>
                   </varlistentry>
                   
                   <varlistentry>
                      <term>
                        <methodsynopsis>
                           <type>virtual std::string </type>
                           <methodname>typeName</methodname>
                           <void /><modifier>const</modifier>
                        </methodsynopsis>
                      </term>
                      <listitem>
                          <para>
                            Returns a string indicating the type of ring item
                            this object is:  <literal>Trigger count</literal>
                       </para>
                    </listitem>
                   </varlistentry>
                   <varlistentry>
                      <term><methodsynopsis>
                         <type>virtual std::string </type>
                         <methodname>toString</methodname>
                         <void /><modifier>const</modifier>
                      </methodsynopsis></term>
                      <listitem>
                          <para>
                            Return  a string that describes the contents of the
                            item.  This is used by, e.g. <command>dumper</command>
                       </para>
                    </listitem>
                   </varlistentry>
                   <varlistentry>
                      <term><methodsynopsis>
                         <type>virtual void </type>
                         <methodname>setBodyHeader</methodname>
                         <methodparam>
                             <type>uint64_t </type><parameter>timestamp</parameter>
                         </methodparam>
                         <methodparam>
                             <type>uint32_t </type><parameter>sourceId</parameter>
                         </methodparam>
                         <methodparam>
                             <type>uint32_t </type><parameter>barrierType </parameter>
                             <initializer>0</initializer>
                         </methodparam>
                      </methodsynopsis></term>
                      <listitem>
                          <para>
                            This is a no-op for version 10 as that format
                            does not suport body headers.
                          </para>
                    </listitem>
                   </varlistentry>
                   <varlistentry>
                      <term><methodsynopsis>
                         <type>virtual void* </type>
                         <methodname>getBodyHeader</methodname>
                         <void /><modifier>const</modifier>
                      </methodsynopsis></term>
                      <listitem>
                          <para>
                            Returns 
                            <literal>nullptr</literal> as version 10 does not
                            support body headers.
                       </para>
                    </listitem>
                   </varlistentry>
                </variablelist>
            </refsect1>
        </refentry>
        <refentry>
           <refmeta>
              <refentrytitle>CRingScalerItem (v10)</refentrytitle>
              <manvolnum>3format</manvolnum>
           </refmeta>
           <refnamediv>
              <refname>CRingScalerItem</refname>
              <refpurpose>Encapsulate a scaler counts ring item.</refpurpose>
            </refnamediv>
            <refsynopsisdiv>
                <programlisting>
#include &lt;v10/CRingScalerItem.h&gt;

namespace v10 {
class CRingScalerItem : public ::CRingScalerItem
{

public:
  CRingScalerItem(size_t numScalers);
  CRingScalerItem(uint32_t startTime,
		  uint32_t stopTime,
		  time_t   timestamp,
		  std::vector&lt;uint32_t&gt; scalers,
      bool                  isIncremental = true,
      uint32_t              sid = 0,
      uint32_t              timeOffsetDivisor = 1);
  
  
  virtual void     setStartTime(uint32_t startTime);
  virtual uint32_t getStartTime() const;
  virtual float    computeStartTime() const;

  virtual void     setEndTime(uint32_t endTime);
  virtual uint32_t getEndTime() const;
  virtual float    computeEndTime() const;

  virtual uint32_t getTimeDivisor() const;


  virtual void     setTimestamp(time_t stamp);
  virtual time_t   getTimestamp() const;
  virtual bool isIncremental() const;
  
  virtual void     setScaler(uint32_t channel, uint32_t value);
  virtual uint32_t getScaler(uint32_t channel) const;
  virtual std::vector&lt;uint32_t&gt; getScalers() const;

  virtual uint32_t getScalerCount() const;
  virtual uint32_t getOriginalSourceId() const;


  virtual void* getBodyHeader() const;
  virtual void setBodyHeader(
      uint64_t timestamp, uint32_t sourceId,
      uint32_t barrierType = 0
  );
  virtual std::string typeName() const;
  virtual std::string toString() const;

};
   
}

                </programlisting>
            </refsynopsisdiv>
            <refsect1>
                     <title>DESCRIPTION</title>
                  <para>
                    This encapsulates a scaler ring item.  Scaler ring items contain
                    periodically read scalers.   In V10, there are two types of
                    underlying scaler ring items that, in V11 are coalesced into
                    a single type.
                  </para>
                  <para>
                    Scaler items of type <literal>v10::INCREMENTAL_SCALERS</literal>
                    are scalers that have a run offset resolution of one second
                    and are cleared as they are read.  Thus each scaler counter
                    represents the new counts since the last read.
                  </para>
                  <para>
                  <literal>v10::</literal>>
                    In the original S800 readout system, it was necessary
                    to introduce a second type: <literal>v10::TIMESTAMPED_NONINCR_SCALERS</literal>.
                    These scalers are read cumulatively and therefore analysis software
                    must be prepared to handle rollovers.  In addition,
                    subsecond time resolution was possible and therefore,
                    these items have a time offset divisor.
                  </para>
                  <para>
                    The constructors of <classname>v10::CRingScalerItem</classname>
                    use the <parameter>isIncremental</parameter>  flag in the
                    full constructor to determine which underlying item type
                    is desired.  Simple constructors always construct a
                    <literal>v10::INCREMENTAL_SCALERS</literal> item.
                  </para>
            </refsect1>
            <refsect1>
                <title>
                    METHODS
                </title>
                <variablelist>
                    <varlistentry>
                       <term><constructorsynopsis>
                           <methodname>CRingScalerItem</methodname>
                        <methodparam>
                            <type>size_t </type><parameter>numScalers</parameter>
                        </methodparam>
                       </constructorsynopsis></term>
                       <listitem>
                           <para>
                            Constructs a scaler item large enough to hold
                            <parameter>numScalers</parameter> 32 bit scaler counters.
                            The start/stop time offsets are both set to
                            <literal>0</literal> as are the scaler values.
                            This constructor unconditionally  produces a
                            <literal>v10::INCREMENTAL_SCALERS</literal> which
                            has no time offset divisor.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><constructorsynopsis>
                           <methodname>CRingScalerItem</methodname>
                        <methodparam>
                            <type>uint32_t </type><parameter>startTime</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint32_t </type><parameter>stopTime,</parameter>
                        </methodparam>
                        <methodparam>
                            <type>time_t   </type><parameter>timestamp</parameter>
                        </methodparam>
                        <methodparam>
                            <type>std::vector&lt;uint32_t&gt; </type><parameter>scalers,</parameter>
                        </methodparam>
                        <methodparam>
                            <type>bool </type><parameter>isIncremental</parameter>
                            <initializer>true</initializer>
                        </methodparam>
                        <methodparam>
                            <type>uint32_t </type><parameter>sid</parameter>
                            <initializer>0</initializer>
                        </methodparam>
                        <methodparam>
                            <type>uint32_t  </type><parameter>timeOffsetDivisor</parameter>
                            <initializer>1</initializer>
                        </methodparam>
                       </constructorsynopsis></term>
                       <listitem>
                           <para>
                            Fully constructs a scaler item.  The scaler values
                            are passed in via the <parameter>scalers</parameter>
                            parameter.  The size of that vector determines
                            the number of scalers the item will hold.
                           </para>
                           <para>
                            The interval start and stop offsets are given
                            by <parameter>startTime</parameter> and
                            <parameter>stopTime</parameter> respecively.
                            The optional <parameter>timeOffsetDivisor</parameter>
                            parameter provides the number of ticks in these
                            offset values per second providing support for
                            sub-second time resolution.  This is only used
                            if the scalers are non-incremental.  If scalers
                            are incremental, the time offsets must always be
                            in seconds.
                           </para>
                           <para>
                            THe clock time is provided by
                            <parameter>timestamp</parameter>.
                           </para>
                           <para>
                            If <parameter>isIncremental</parameter> is false,
                            the counts are assumed to accumulate for the length
                            of the run.  Otherwise the counts in the scalers are
                            assumed to represent the counts over the interval
                            defined by <parameter>startTime</parameter>
                            through <parameter>stopTime</parameter>.
                            This parameter determines the scaler item type.
                            If <literal>true</literal>, a
                            <literal>v10::INCREMENTAL_SCALERS</literal>
                            item is created.
                            If <literal>false</literal>, a
                            <literal>v10::TIMESTAMPED_NONINCR_SCALERS</literal>
                            item is created.
                           </para>
                           <para>
                            The
                            <parameter>sid</parameter> parameter is ignored
                            as source ids only were not yet introduced in any
                            of the v10 ring items.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void     </type>
                          <methodname>setStartTime</methodname>
                          <methodparam>
                              <type>uint32_t </type><parameter>startTime</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Sets the offset into the run at which the scaler counting
                            interval began.
        
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual uint32_t</type>
                          <methodname> getStartTime() </methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the offset into the run at which the
                            scaler counting began.  See next method, however.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual float    </type>
                          <methodname>computeStartTime</methodname>
                          <void />
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Uses the scaler interval start offset and the
                            counting divisor to compute the start time offset
                            in seconds.  Note that for
                            <literal>v10::INCREMENTAL_SCALERS</literal>
                            items the divisor is always treated as
                            <literal>1</literal>.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void     </type>
                          <methodname>setEndTime</methodname>
                          <methodparam>
                              <type>uint32_t </type><parameter>endTime</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Sets the offset into the run of the end of the
                            scaler counting interval
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual uint32_t </type>
                          <methodname>getEndTime</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the offset into the run at which the scaler
                            counting interval ended.  See, however the next
                            method.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual float    </type>
                          <methodname>computeEndTime</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Using the end offset and the offset divisor computes
                            and returns the number of seconds into the run at
                            which the scaler counting interval ended.
                            Note that for <literal>v10::INCREMENTAL_SCALERS</literal>
                            the divisor is always treated as <literal>1</literal>
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual uint32_t </type>
                          <methodname>getTimeDivisor</methodname>
                          <void /> <modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the number of ticks in the start and end
                            time offsets that correspond to a second.
                            For <literal>v10::INCREMENTAL_SCALERS</literal>
                            items, this is always <literal>1</literal>.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void     </type>
                          <methodname>setTimestamp</methodname>
                          <methodparam>
                              <type>time_t </type><parameter>stamp</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Sets the clock time associated with the item
                            to be <parameter>stamp</parameter>.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual time_t   </type>
                          <methodname>getTimestamp</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the clock time associated with the item.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual bool </type>
                          <methodname>isIncremental</methodname>
                          <void />
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            If the scalers are cleared after each read, this
                            returns <literal>true</literal>, if they are allowed
                            to accumulate across counting intervals, this returns
                            <literal>false</literal>
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void     </type>
                          <methodname>setScaler</methodname>
                          <methodparam>
                              <type>uint32_t </type><parameter>channel</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t </type><parameter>value</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Sets the counts for the scaler  selected by
                            <parameter>channel</parameter> to
                            <parameter>value</parameter>. If <parameter>channel</parameter>
                            is out of range an <classname>std::out_of_range</classname>
                            exception is thrown.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual uint32_t </type>
                          <methodname>getScaler</methodname>
                          <methodparam>
                              <type>uint32_t </type><parameter>channel</parameter>
                          </methodparam>
                          <modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returs the value of the scaler selected by
                            <parameter>channel</parameter>.  If
                            <parameter>channel</parameter> is out of range a
                            <classname>std::out_of_range</classname>
                            exception is thrown.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual std::vector&lt;uint32_t&gt; </type>
                          <methodname>getScalers</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns a vector containing the values of the scaler
                            counts in the item.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual uint32_t </type>
                          <methodname>getScalerCount</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the number of scalers in the item.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type> virtual uint32_t </type>
                          <methodname>getOriginalSourceId</methodname>
                          <void /><modifier> const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the original source id field from the item.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void* </type>
                          <methodname>getBodyHeader</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns  <literal>nullptr</literal> since the
                            v10 ring items don't have body headers.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void </type>
                          <methodname>setBodyHeader</methodname>
                          <methodparam>
                              <type>   uint64_t </type><parameter>timestamp</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t </type><parameter>sourceId</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t </type><parameter>barrierType</parameter>
                              <initializer>0</initializer>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Does nothing as the v10 ring items don't have body
                            headers.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual std::string </type>
                          <methodname>typeName</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns a string that identifies the type of the item:
                            <literal>Scaler</literal>
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual std::string </type>
                          <methodname>toString</methodname>
                          <void /> <modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns a string that details the contents of the
                            item.  This is used by e.g. <command>dumper</command>
                            to produce a formated dump of a stream of ring items.
                           </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </refsect1>
        </refentry>
        <refentry>
           <refmeta>
              <refentrytitle>CRingStateChangeItem (v10)</refentrytitle>
              <manvolnum>3format</manvolnum>
           </refmeta>
           <refnamediv>
              <refname>CRingStateChangeItem</refname>
              <refpurpose>Encapsulate run state change ring items.</refpurpose>
            </refnamediv>
            <refsynopsisdiv>
                <programlisting>
#include &lt;v10/CRingStateChangeItem.h&gt;

namespace v10 {

class CRingStateChangeItem : public ::CRingStateChangeItem
{
public:
  CRingStateChangeItem(uint16_t reason = BEGIN_RUN);
  CRingStateChangeItem(uint16_t reason,
		       uint32_t runNumber,
		       uint32_t timeOffset,
		       time_t   timestamp,
		       std::string title) ;
  
  virtual void setRunNumber(uint32_t run);
  virtual uint32_t getRunNumber() const;

  virtual void setElapsedTime(uint32_t offset);
  virtual uint32_t getElapsedTime() const;
  virtual uint32_t getTimeDivisor() const;   
  virtual float    computeElapsedTime() const;

  virtual void setTitle(std::string title);
  virtual std::string getTitle() const;

  virtual void setTimestamp(time_t stamp);
  virtual time_t getTimestamp() const;
  virtual uint32_t getOriginalSourceId() const;    

  // Virtual method overrides.

  virtual void* getBodyHeader() const;    // new
  virtual void setBodyHeader(uint64_t timestamp, uint32_t sourceId,
                         uint32_t barrierType = 0);  
  virtual std::string typeName() const;
  virtual std::string toString() const;
  

};
}

                </programlisting>
            </refsynopsisdiv>
            <refsect1>
                     <title>DESCRIPTION</title>
                  <para>
                    The NSCLDAQ readout frameworks inform programs that
                    participate in data flow of transitions in the run state
                    by emitting run state change ring items.
                    <classname>CRingStateChangeItem</classname> classes
                    encapsulate these items into objects that can
                    be manipulated without knowledge of the detailed
                    data format.
                  </para>
            </refsect1>
            <refsect1>
                <title>
                    METHODS
                </title>
                <variablelist>
                    <varlistentry>
                       <term><constructorsynopsis>
                           <methodname>CRingStateChangeItem</methodname>
                        <methodparam>
                            <type>uint16_t </type><parameter>reason </parameter>
                            <initializer>BEGIN_RUN</initializer>
                        </methodparam>
                       </constructorsynopsis></term>
                       <listitem>
                           <para>
                            Creates a state change item for the specified state
                            change type.  The offset time is set to zero, which is
                            appropriate for a begin run, the clock time stamp is
                            set to the current time.  The run number is also set
                            to zero.  The title is set to an empty string.
                            Other version specific initialization may occur.
                           </para>
                           
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><constructorsynopsis>
                           <methodname> CRingStateChangeItem</methodname>
                        <methodparam>
                            <type>uint16_t </type><parameter>reason</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint32_t </type><parameter>runNumber</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint32_t timeOffset</type><parameter></parameter>
                        </methodparam>
                        <methodparam>
                            <type>time_t   </type><parameter>timestamp</parameter>
                        </methodparam>
                        <methodparam>
                            <type>std::string </type><parameter>title</parameter>
                        </methodparam>
                       </constructorsynopsis></term>
                       <listitem>
                           <para>
                            Full construction of a state change item.  The
                            <parameter>reason</parameter> is the type of state change
                            item as listed in <literal>DESCRIPTION</literal>.
                            <parameter>runNumber</parameter> us the number of the
                            run undergoing the transition.  <parameter>timeOffset</parameter>
                            is the offset into the run at which the transition occured.
                            This should always be <literal>0</literal> for
                            <literal>BEGIN_RUN</literal> transitions.
                            
                           </para>
                           <para>
                            <parameter>timestamp</parameter> is the clock time
                            at which the transition occured.   This is the output
                            of the unix <function>time</function> function.
                           </para>
                           <para>
                            Finally, <parameter>title</parameter> is the run's title.
                            This should be the same string for all transitions
                            within a run.   Note that there is a maximum
                            length to titles defined in
                            <filename>DataFormat.h</filename> with the symble
                            <literal>TITLE_MAXSIZE</literal>. Title strings longer
                            than that should be silently truncated by the
                            version's implementation.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void </type>
                          <methodname>setRunNumber</methodname>
                          <methodparam>
                              <type>uint32_t</type><parameter> run</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Modifies the item's run number.   This is most often
                            used when the minimal constructor is used to
                            create the item.  In that case, various methods
                            are used to fill in actual values of the fields.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual uint32_t </type>
                          <methodname>getRunNumber</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Return the run number from the state change ring item
                            encapsulated in the object.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void </type>
                          <methodname>setElapsedTime</methodname>
                          <methodparam>
                              <type>uint32_t </type><parameter>offset</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Sets the raw time offset of the state change item.
                            The offset says when in the timespan of the run
                            the state change occured.  It is zero at the beginning
                            of the run.  No attempt is made to synchronize this time
                            offset between several data sources.
                           </para>
                           <para>
                            The units of this offset are seconds.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual uint32_t </type>
                          <methodname>getElapsedTime</methodname>
                          <void />
                          <modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the raw time offset stored in the event.  This
                            is the time offset in to the run at which the state change
                            occured. Note that the time divisor (see below) represents
                            the numbver of ticks in the offset in a second.
                           </para>
                           <para>
                            It's usually preferrable to get the offset in seconds
                            using <methodname>computeElapedTime</methodname>.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual uint32_t </type>
                          <methodname>getTimeDivisor</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Version 10 does not support time divisors so this
                            always returns <literal>1</literal>
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual float </type>
                          <methodname>computeElapsedTime</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the time offset.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void </type>
                          <methodname>setTitle</methodname>
                          <methodparam>
                              <type>std::string </type><parameter>title</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Sets the title of the run for the state transition
                            item.  The state transition items that belong to the
                            same run should have the same title.  Note that
                            there is a maximum title length and implementations
                            should silently truncate any title longer than that.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual std::string </type>
                          <methodname>getTitle</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the value of the title string for the
                            transition object.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void </type>
                          <methodname>setTimestamp</methodname>
                          <methodparam>
                              <type>time_t </type><parameter>stamp</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Sets a clock times associted with the item.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual time_t </type>
                          <methodname>getTimestamp</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Return the clock time associated with the
                            item.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                            <methodsynopsis>
                               <type>virtual uint32_t</type>
                               <methodname> getOriginalSourceId</methodname>
                               <void /><modifier>const</modifier>
                            </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Version 10 does not support source ids so this
                            method returns <literal>0</literal>
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void* </type>
                          <methodname>getBodyHeader</methodname>
                          <void /> <modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Version 10 does not support body headers, so this
                            returns a <literal>nullptr</literal>
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void </type>
                          <methodname>setBodyHeader</methodname>
                          <methodparam>
                              <type>uint64_t </type><parameter>timestamp</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t </type><parameter>sourceId</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t </type><parameter>barrierType </parameter>
                              <initializer>0</initializer>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Version 10 does not support body headers so this operation
                            does nothing.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual std::string </type>
                          <methodname>typeName</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns a string that identifies the type of the object.
                            Note that the type is a fine grained concept.
                            For examle, if the type is
                            <literal>BEGIN_RUN</literal>,
                            this method returns <literal>Begin Run</literal>.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual std::string</type>
                          <methodname>toString</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns a string that describes the contents of the
                            item.  This is used by e.g.
                            <command>dumper</command> to emit formatted
                            ring items.
                           </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </refsect1>
        </refentry>
        <refentry>
           <refmeta>
              <refentrytitle>CRingTextItem (v10)</refentrytitle>
              <manvolnum>3format</manvolnum>
           </refmeta>
           <refnamediv>
              <refname>CRingTextItem</refname>
              <refpurpose>Encapsulate a set of textual strings</refpurpose>
            </refnamediv>
            <refsynopsisdiv>
                <programlisting>
#include &lt;v10/CRingTextItem&gt;


namespace v10 {
class CRingTextItem : public ::CRingTextItem

public:
  // Constructors and other canonicals:

  CRingTextItem(uint16_t type,
		std::vector&lt;std::string&gt; theStrings);
  CRingTextItem(uint16_t type,
		std::vector&lt;std::string&gt; theStrings,
		uint32_t                 offsetTime,
		time_t                   timestamp, uint32_t divisor=1) ;
  
  virtual std::vector&lt;std::string&gt;  getStrings() const;

  virtual void     setTimeOffset(uint32_t offset);
  virtual uint32_t getTimeOffset() const;
  virtual float    computeElapsedTime() const;
  virtual uint32_t getTimeDivisor() const;

  virtual void     setTimestamp(time_t stamp);
  virtual time_t   getTimestamp() const;
  virtual uint32_t getOriginalSourceId() const;

  virtual void* getBodyHeader() const;
  virtual void setBodyHeader(
        uint64_t timestamp, uint32_t sid, uint32_t barrierType= 0
  );
  virtual std::string typeName() const;
  virtual std::string toString() const;
  
};

}                        // v10 namespace

                </programlisting>
            </refsynopsisdiv>
            <refsect1>
                     <title>DESCRIPTION</title>
                  <para>
                    There are two types of text ring items:
                  </para>
                  <itemizedlist>
                    <listitem>
                       <para>
                           <literal>v10::PACKET_TYPES</literal>, which, in the
                           SBS readout system document the types of packets
                           that may be seen in the event data.  A packet is defined
                           like a ring item - a size and type with a payload.
                           Packets exist to make decoding simpler and modular.
                       </para>
                    </listitem>
                    <listitem>
                       <para>
                          <literal>v10::MONITORED_VARIABLES</literal>, which
                          provide the values of Tcl variables in the main
                          readout program's intermpreter.  These are normally used
                          to feed external information into the event stream.
                          In the past this has included EPICS data, however with
                          the tightening of the EPICS control system security in FRIB it's
                          unlikely this is possible in the future.
                       </para>
                       <para>
                            One might, however push other information, e.g. detector
                            bias supply settings.
                       </para>
                    </listitem>
                  </itemizedlist>
                  <para>
                    As with all version 10 ring items, body headers are  not supported
                    and neither are offset time divisors.
                  </para>
            </refsect1>
            <refsect1>
                <title>METHODS</title>
                <variablelist>
                    
                    <varlistentry>
                       <term><constructorsynopsis>
                           <methodname> CRingTextItem(</methodname>
                        <methodparam>
                            <type>uint16_t </type><parameter>type</parameter>
                        </methodparam>
                        <methodparam>
                            <type>std::vector&lt;std::string&gt; </type><parameter>theStrings</parameter>
                        </methodparam>
                       </constructorsynopsis></term>
                       <listitem>
                           <para>
                            In this constructor, <parameter>theStrings</parameter>
                            is used to compute the required item size.  The
                            strings are set into the item's string pool
                            as null terminated strings and the string count
                            is set to <literal>theStrings.size()</literal>.
                            The offset, original source id, and clock time are
                            initialized as in the previous constructor.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><constructorsynopsis>
                           <methodname>CRingTextItem</methodname>
                        <methodparam>
                            <type>uint16_t </type><parameter>type</parameter>
                        </methodparam>
                        <methodparam>
                            <type>std::vector&lt;std::string&gt;</type><parameter> theStrings</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint32_t  </type><parameter>offsetTime</parameter>
                        </methodparam>
                        <methodparam>
                            <type>time_t </type><parameter>timestamp</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint32_t </type><parameter>divisor</parameter>
                            <initializer>1</initializer>
                        </methodparam>
                       </constructorsynopsis></term>
                       <listitem>
                           <para>
                            Fully parameterized constructor.  This constructor
                            adds <parameter>offsetTime</parameter> to set the
                            time  offset in the run at which the item was emitted,
                            <parameter>timestamp</parameter> which allows the
                            clock time the item was emitted to be expclicitly
                            specified.  Note that the <parameter>divisor</parameter>
                            parameter is provided for compatibility with other
                            formats but is ignored since version 10 items do not
                            support sub second run offset times.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual std::vector&lt;std::string&gt;</type>
                          <methodname> getStrings</methodname>
                          <void /><modifier> const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns a vector that contains the text strings in the
                            object's payload.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void     </type>
                          <methodname>setTimeOffset</methodname>
                          <methodparam>
                              <type>uint32_t </type><parameter>offset</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Set the offset into the run at which this object was
                            emitted.  Note that since v10 does not support sub
                            second run offsets (does not have divisors), the
                            units of <parameter>offset</parameter> must be seconds.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual uint32_t </type>
                          <methodname>getTimeOffset</methodname>
                          <void /> <modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the raw time offset. Note that calling
                            <methodname>computeElapsedTime</methodname>
                            is the perferred method to call to get the run time
                            offset in seconds.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual float</type>
                          <methodname>computeElapsedTime</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Return the elapsed time in the run at which this
                            item was emitted, in seconds.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual uint32_t </type>
                          <methodname>getTimeDivisor</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns <literal>1</literal> since version 10
                            does not support divisors.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void </type>
                          <methodname>setTimestamp</methodname>
                          <methodparam>
                              <type>time_t </type><parameter>stamp</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Sets the clock time at which the item was emitted.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual time_t  </type>
                          <methodname> getTimestamp</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the clock time associated with the item.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual uint32_t </type>
                          <methodname>getOriginalSourceId</methodname>
                          <void /><modifier> const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Since version 10 supports neither body headers nor
                            original source ids, this method always returns
                            <literal>0</literal>
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void* </type>
                          <methodname>getBodyHeader</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns <literal>nullptr</literal> since version 10
                            does not support body headers.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void </type>
                          <methodname>setBodyHeader</methodname>
                          <methodparam>
                              <type>uint64_t </type><parameter>timestamp</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t </type><parameter>sid</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t </type><parameter>barrierType</parameter>
                              <initializer>0</initializer>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Does nothing because version 10 does not support
                            body headers.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type> virtual std::string </type>
                          <methodname>typeName</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns a string that identifies the item type.  This
                            will be one of <literal>Packet types</literal> or
                            <literal>Monitored Variables</literal>
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual std::string </type>
                          <methodname>toString</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns a string that describes the contents of
                            the item in human readable form.
                           </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </refsect1>
        </refentry>
        
       </section>
       <section>
        <title>NSCLDAQ version 11 format</title>
        <para>
            This section contains reference information describing support for
            the version 11 format.  Version 11 introduced body headers to
            simplify event buiding.
        </para>
        <para>
            A body header is an optional part of a ring item that has the following
            fields:
            <variablelist>
                <varlistentry>
                   <term><type>uint32_t </type><structfield>s_size</structfield></term>
                   <listitem>
                       <para>
                        Contains the size of the body header.  Note that this
                        allows application specific data to be appended to the
                        body header as the formatting software uses this size
                        to determine both the presence of and size of this header.
                       </para>
                       <para>
                        If a <structfield>s_size</structfield> is larger than
                        <literal>sizeof(v11::BodyHeader)</literal> the body header
                        is said to have a <firstterm>Body Header Extension</firstterm>.
                       </para>
                       <para>
                        In version 11, if <structfield>s_size</structfield>
                        is <literal>0</literal>, the item has no body header.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term><type>uint64_t</type><structfield>s_timestamp</structfield></term>
                   <listitem>
                       <para>
                        The timestamp at which the item was produced. The units
                        of the timestamp are application defined, however
                        it is critical that all data sources have the same
                        timestamp units, the same source of timestamp increments,
                        and as close to the same zero time as electronically
                        possible.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term><type>uint32_t</type><structfield>s_sourceId</structfield></term>
                   <listitem>
                       <para>
                        The data source.  Each data source is assumed, by
                        the event builder, to be totally time ordered.
                        The process of event building is, therefore, oneo f
                        merging the times from all data sources to produce
                        a single totally time ordered stream of fragments
                        and then gluing (glomming) together fragments
                        whose timestamps are within a specified coincidence
                        window.
                       </para>
                       <para>
                        Data sources must be unique and often, but not always,
                        identify a readout program.  As a counter example to this,
                        a VME crate with CAEN DPP Modules is readout with each
                        module as a separate data source.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term><type>uint32_t</type><structfield>s_barrier</structfield></term>
                   <listitem>
                       <para>
                        NSCLDAQ's event builder provides for rough barrier synchronization
                        between data sources.  Barrier synchronization means that
                        no further data is emitted from a source within the event
                        builder until all sources have, a the head of their output
                        queues, a barrier item.
                       </para>
                       <para>
                        If <structfield>s_barrier</structfield>, is non-zero,
                        barrier synchronization is triggered.  The
                        <structfield>s_barrier</structfield> value may carry
                        additional information about why barrier synchronization
                        is underway.
                       </para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </para>
        <para>
            As with all format versions an item factory is defined
            implementing the interface described by the abstract factory.
            Individual ring item type classes are also defined which
            implement interfaces that are defined by the abstract
            ring item type classes.  The remainder of this section
            provides reference information for these classes.
        </para>
        <para>
            Note that all of the headers for the V11 format support
            are in the <filename>v11</filename> subdirectory of the
            installation directory's <filename>include</filename>
            subdirectory.
        </para>
        <refentry>
           <refmeta>
              <refentrytitle>RingItemFactory (v11)</refentrytitle>
              <manvolnum>3format</manvolnum>
           </refmeta>
           <refnamediv>
              <refname>RingItemFactory (v11)</refname>
              <refpurpose>Create ring items in version 11 format.</refpurpose>
            </refnamediv>
            <refsynopsisdiv>
                <programlisting>
#include &lt;v11/RingItemFactory.h&gt;

namespace v11 {
    

class RingItemFactory : public ::RingItemFactoryBase
{
public:
    virtual ::CRingItem* makeRingItem(uint16_t type, size_t maxBody) ;
    virtual ::CRingItem* makeRingItem(uint16_t type, uint64_t timestamp, uint32_t sourceId,
            size_t maxBody, uint32_t barrierType = 0 ) ;
    virtual ::CRingItem* makeRingItem(const ::CRingItem&amp; rhs) ;
    virtual ::CRingItem* makeRingItem(const ::RingItem* pRawRing) ;


    virtual ::CRingItem* getRingItem(CRingBuffer&amp; ringbuf) ;
    virtual ::CRingItem* getRingItem(int fd) ;
    virtual ::CRingItem* getRingItem(std::istream&amp; in) ;

    virtual std::ostream&amp; putRingItem(const ::CRingItem* pItem, std::ostream&amp; out) ;
    virtual void putRingItem(const ::CRingItem* pItem, int fd) ;
    virtual void putRingItem(const ::CRingItem* pItem, CRingBuffer&amp; ringbuf) ;

    virtual ::CAbnormalEndItem* makeAbnormalEndItem() ;
    virtual ::CAbnormalEndItem* makeAbnormalEndItem(const ::CRingItem&amp; rhs) ;

    virtual ::CDataFormatItem* makeDataFormatItem() ;
    virtual ::CDataFormatItem* makeDataFormatItem(const ::CRingItem&amp; rhs) ;

    virtual ::CGlomParameters* makeGlomParameters(
        uint64_t interval, bool isBuilding, uint16_t policy
    )  ;
    virtual ::CGlomParameters* makeGlomParameters(const ::CRingItem&amp; rhs) ;

    virtual ::CPhysicsEventItem* makePhysicsEventItem(size_t maxBody) ;
    virtual ::CPhysicsEventItem* makePhysicsEventItem(
        uint64_t timestamp, uint32_t source, uint32_t barrier, size_t maxBody
    ) ;
    virtual ::CPhysicsEventItem* makePhysicsEventItem(const ::CRingItem&amp; rhs) ;

    virtual ::CRingFragmentItem* makeRingFragmentItem(
        uint64_t timestamp, uint32_t source, uint32_t payloadSize,
        const void* payload, uint32_t barrier=0
    ) ;
    virtual ::CRingFragmentItem* makeRingFragmentItem(const ::CRingItem&amp; rhs) ;


    virtual ::CRingPhysicsEventCountItem* makePhysicsEventCountItem(
        uint64_t count, uint32_t timeoffset, time_t stamp,
    int divisor=1
    ) ;
    virtual ::CRingPhysicsEventCountItem* makePhysicsEventCountItem(const ::CRingItem&amp; rhs) ;

    virtual ::CRingScalerItem* makeScalerItem(size_t numScalers) ;
    virtual ::CRingScalerItem* makeScalerItem(
        uint32_t startTime,
        uint32_t stopTime,
        time_t   timestamp,
        std::vector&lt;uint32_t&gt; scalers,
        bool                  isIncremental = true,
        uint32_t              sid = 0,
        uint32_t              timeOffsetDivisor = 1
    ) ;
    virtual ::CRingScalerItem* makeScalerItem(const ::CRingItem&amp; rhs) ;

    virtual ::CRingTextItem* makeTextItem(
        uint16_t type,
                std::vector&lt;std::string&gt; theStrings
    ) ;
    virtual ::CRingTextItem* makeTextItem(
        uint16_t type,
        std::vector&lt;std::string&gt; theStrings,
        uint32_t                 offsetTime,
        time_t                   timestamp, uint32_t divisor=1
    ) ;
    virtual ::CRingTextItem* makeTextItem(const ::CRingItem&amp; rhs) ;

    virtual ::CUnknownFragment* makeUnknownFragment(
        uint64_t timestamp, uint32_t sourceid, uint32_t barrier,
        uint32_t size, void* pPayload
    ) ;
    virtual ::CUnknownFragment* makeUnknownFragment(const ::CRingItem&amp; rhs) ;

    virtual ::CRingStateChangeItem* makeStateChangeItem(
        uint32_t itemType, uint32_t runNumber,
        uint32_t timeOffset,
        time_t   timestamp,
        std::string title
    ) ;
    virtual ::CRingStateChangeItem* makeStateChangeItem(const ::CRingItem&amp; rhs) ;   
};
}

                </programlisting>
            </refsynopsisdiv>
            <refsect1>
                     <title>DESCRIPTION</title>
                  <para>
                    This class provides classes that can create ring items
                    in the the version 11 NSCLDAQ format.  The return values
                    are dynamically allocated pointers and therefore the
                    caller owns the objects and must delete them when
                    no longer used.
                  </para>
                  <para>
                    Good practice would be to use these pointers to initialize
                    one of the C++ standard library smart pointer objects
                    (e.g. <classname>std::unique_ptr</classname> or
                    <classname>std::shared_ptr</classname>).  Doing that
                    will help prevent memory leaks in your program.
                  </para>
            </refsect1>
            <refsect1>
                <title>METHODS</title>
                <variablelist>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>::CRingItem* </type>
                          <methodname>makeRingItem</methodname>
                          <methodparam>
                              <type>uint16_t </type><parameter>type</parameter>
                          </methodparam>
                          <methodparam>
                              <type>size_t </type><parameter>maxBody</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Creates a new ring item that is undifferentiated,
                            that is it implements no type specific methods.
                            <parameter>type</parameter> is put in the ring item
                            header's type field.  Storage capacity sufficient for
                            a body of up to <parameter>maxBody</parameter>
                            bytes of data are reserved though you'll need to
                            communicate the size of the item (normally via
                            the object's <methodname>setBodyCursor</methodname>
                            and <methodname>updateSize</methodname> methods) to
                            actually fill in the header's size field.
                           </para>
                           <para>
                            The returned value is a pointer to a
                            <classname>v11::CRingItem</classname> object
                            (cast to <classname>::CRingItem</classname>).
                            The caller is responsible for deleting the object
                            when it is no longer needed (e.g. by initializing a smart
                            pointer object with it).
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>::CRingItem* </type>
                          <methodname>makeRingItem</methodname>
                          <methodparam>
                              <type>uint16_t </type><parameter>type</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint64_t </type><parameter>timestamp</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t </type><parameter>sourceId</parameter>
                          </methodparam>
                          <methodparam>
                              <type>size_t </type><parameter>maxBody</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t</type><parameter> barrierType</parameter>
                              <initializer>0</initializer>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Creates an undifferentiateded ring item that is parameterized
                            for a body header.  The ring item will be created
                            with a body header whose fields will come
                            from the <parameter>timestamp</parameter>,
                            <parameter>sourceId</parameter> and
                            optional <parameter>barrierType</parameter>
                            arguments.  <parameter>barrierType</parameter>
                            defaults to <literal>0</literal> which means no
                            barrier is triggered.
                           </para>
                           <para>
                            For a user to add a body header extension, prior to
                            any actual body data being added, requires
                            that they first use <methodname>getBodyHeader</methodname>
                            to get a pointer to the body, then
                            <methodname>getBodyCursor</methodname> to obtain
                            a pointer past the end of the body cursor add
                            the data and then adust the size field of the
                            body header.
                           </para>
                           <para>
                            For example, suppose the application is to
                            add a body header extension that will contain
                            the experiment number which is stored in the
                            constant EXPERIMENT_NUMBER:
                           </para>
                           <example>
                            <title>Adding a body header extension</title>
                            <programlisting>
std::uinque_ptr&lt;::CRingItem&gt; p(factory.makeRingItem(...)) // make ring item with body header.

v11::pBodyHeader pH = reinterpret_cast&lt;v11::pBodyHeader&gt;(p-&gt;getBodyHeader());
uint32_t* pCursor = reinterpret_cast&lt;uint32_t*&gt;(p-&gt;getBodyCursor);
*pCursor = EXPERIMENT_NUMBER;
pH->s_size += sizeof(uint32_t);
p-&gt;setBodyCursor(pCursor);      // For whomever is filling the item body.

                            </programlisting>
                           </example>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>::CRingItem* </type>
                          <methodname>makeRingItem</methodname>
                          <methodparam>
                              <type>const ::CRingItem&amp; </type><parameter>rhs</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Makes a ring item by copying the contents of another
                            ring item.  Note that the results are not well defined
                            if the <parameter>rhs</parameter> item comes from
                            a different ring item format than this factory
                            (e.g. is a version 12 ring item).
                           </para>
                           <para>
                            In practice this is not a problem unless you are writing
                            a format converter.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>::CRingItem* </type>
                          <methodname>makeRingItem</methodname>
                          <methodparam>
                              <type>const RingItem* </type><parameter>pRawRing</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Wraps a raw ring item in a <classname>v11::CRingItem</classname>
                            object and returns a pointer to that object.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual CRingItem* </type>
                          <methodname>getRingItem</methodname>
                          <methodparam>
                              <type>CRingBuffer&amp;</type><parameter>ringbuf</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Reads a ring item from the ringbuffer
                            <parameter>ringbuf</parameter> and wraps it in a new
                            <type>v11::CRingItem</type>.
                           </para>
                           <para>
                            <parameter>ringbuf</parameter> must be attached to
                            the ring buffer in consumer mode.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual CRingItem* </type>
                          <methodname>getRingItem</methodname>
                          <methodparam>
                              <type>int</type><parameter> fd</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Reads a ring item from the entity open on the linux
                            file descriptor <parameter>fd</parameter> and wraps it
                            into a new <type>v11::CRingItem</type>.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual CRingItem* </type>
                          <methodname>getRingItem</methodname>
                          <methodparam>
                              <type>std::istream&amp; </type><parameter>in</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Reads a ring item from the C++ <classname>istream</classname>
                            referenced by <parameter>in</parameter> and wraps it in a
                            <classname>v11::CRingItem</classname>.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual std::ostream&amp;</type>
                          <methodname> putRingItem</methodname>
                          <methodparam>
                              <type>const CRingItem*</type><parameter> pItem</parameter>
                          </methodparam>
                          <methodparam>
                              <type>std::ostream&amp; </type><parameter>out</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Puts the wrapped ring item pointed to by <parameter>pItem</parameter>
                            in the <classname>std::ostream</classname> referenced by <parameter>out</parameter>.
                            The raw binary of the ring item is output which allows it to be read in using
                             <methodname>getRingItem</methodname> at some later date.
                           </para>
                           <para>
                            The <parameter>out</parameter> stream must be open
                            for write and in binary mode.  Note any actual ring item
                            type can be used for the <parameter>pItem</parameter>
                            since they all ultimately descend from
                            <classname>::CRingItem</classname>.
                           </para>
                           <para>
                            The method, like most C++ stream I/O methods, returns
                            a reference to <parameter>out</parameter> following the
                            put.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void </type>
                          <methodname>putRingItem</methodname>
                          <methodparam>
                              <type>const ::CRingItem*</type><parameter> pItem</parameter>
                          </methodparam>
                          <methodparam>
                              <type>int </type><parameter>fd</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Writes the ring item pointed to by
                            <parameter>pItem</parameter> to the file descriptor
                            <parameter>fd</parameter>
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void </type>
                          <methodname>putRingItem</methodname>
                          <methodparam>
                              <type>const ::CRingItem* </type><parameter>pItem</parameter>
                          </methodparam>
                          <methodparam>
                              <type>CRingBuffer&amp;</type><parameter>ringbuf</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Writes the ring item pointed to by
                            <parameter>pItem</parameter> to the ringbuffer
                            referenced by <parameter>ringbuf</parameter>.
                            <parameter>ringbuf</parameter> must be attached
                            to the ring buffer in producer mode.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type> virtual ::CAbnormalEndItem* </type>
                          <methodname>makeAbnormalEndItem</methodname>
                          <void />
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Creates a new abnormal end run item.  Abnormal
                            end run items flag event data taking that has
                            ended without a proper end run request/indication.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual ::CAbnormalEndItem* </type>
                          <methodname>makeAbnormalEndItem</methodname>
                          <methodparam>
                              <type>const CRingItem&amp;</type><parameter>rhs</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            If <parameter>rhs</parameter> references
                            an abnormal end item, this will create a new copy
                            of that item with the specific type, a pointer
                            to <classname>v11::CAbnormalEndItem</classname>.
                            If, however the type of
                            <parameter>rhs</parameter> is not
                            <literal>v11::ABNORMAL_ENDRUN</literal>
                            and the size of the ring item is not
                            <literal>sizeof(v11::AbnormalEndItem</literal>, a
                            <classname>std::bad_cast</classname>
                            exception is thrown.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual ::CDataFormatItem* </type>
                          <methodname>makeDataFormatItem</methodname>
                          <void />
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Creates  a new data format item.
                            
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual ::CDataFormatItem* </type>
                          <methodname>makeDataFormatItem</methodname>
                          <methodparam>
                              <type>const CRingItem&amp;</type><parameter>rhs</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            If <parameter>rhs</parameter>
                            references a data format item, this method will
                            produce a duplicate item and return a pointer to it.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual ::CGlomParameters*</type>
                          <methodname> makeGlomParameters</methodname>
                          <methodparam>
                              <type>uint64_t </type><parameter>interval</parameter>
                          </methodparam>
                          <methodparam>
                              <type>bool </type><parameter>isBuilding</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint16_t </type><parameter>policy</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Produces a pointer to a
                            <classname>v11::CGlomParameters</classname>.
                            This data type is used to encapsulate a informational
                            ring item emitted by the event builder's glom stage.
                            The ring item contains the coincidence interval:
                            <parameter>interval</parameter>,
                            The <parameter>policy</parameter> for assigning
                            timestamps to output events and a flag,
                            <parameter>isBuilding</parameter> which is true
                            if glom is actually building events and false if it
                            is just emitting single fragment events.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                          <term><methodsynopsis>
                             <type>::CGlomParameters*</type>
                             <methodname>makeGlomParameters</methodname>
                             <methodparam>
                                 <type>const ::CRingItem&amp; </type><parameter>rhs</parameter>
                             </methodparam>
                          </methodsynopsis></term>
                          <listitem>
                              <para>
                               If <parameter>rhs</parameter> is a v11
                               glom parameters ring item, duplicates it as
                               a <classname>v11::CGlomParameters</classname>
                               item and returns a  pointer to this item.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual ::CPhysicsEventItem* </type>
                          <methodname>makePhysicsEventItem</methodname>
                          <methodparam>
                              <type>size_t </type><parameter>maxBody</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Creates and returns a pointer to a physics event item
                            (<classname>v11::CPhysicsEventItem</classname>). The
                            capacity of the item will be sufficient for the item
                            to have a body of <parameter>maxBody</parameter>.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type> virtual ::CPhysicsEventItem* </type>
                          <methodname>makePhysicsEventItem</methodname>
                          <methodparam>
                              <type>uint64_t </type><parameter>timestamp</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t </type><parameter>source</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t </type><parameter>barrier</parameter>
                          </methodparam>
                          <methodparam>
                              <type>size_t </type><parameter>maxBody</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Makes a physics event with a body header filled in
                            from the additional parameters.
                            The body header timestamp is filled in from
                            <parameter>timestamp</parameter>,
                            the source id from <parameter>source</parameter>
                            and the barrier type from <parameter>barrier</parameter>.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type> virtual ::CPhysicsEventItem* </type>
                          <methodname>makePhysicsEventItem</methodname>
                          <methodparam>
                              <type>const ::CRingItem&amp;</type><parameter>rhs</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Given an undifferentiated ring item that
                            encapsulates a physics event item in <parameter>rhs</parameter>,
                            constructs an actual <classname>v11::CPhysicsEventItem</classname>
                            returning a pointer to the constructed item.
                            If the type of the item is not <literal>v11::PHYSICS_EVENT</literal>
                            a <classname>std::bad_cast</classname> exception is thrown.
                           </para>
                           <para>
                            Note that if the item is from a different version of
                            NSCLDAQ, the behavior of the resulting item
                            is not welll defined.  Consider for example, if
                            <parameter>rhs</parameter> is v10 ring item,
                            That item has no word indicating it has no body
                            header and therefore, the
                            <classname>v11::CPhysicsEventItem</classname>
                            class will misinterpret the shape of the underlying
                             ring item.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual ::CRingFragmentItem* </type>
                          <methodname>makeRingFragmentItem</methodname>
                          <methodparam>
                              <type>uint64_t </type><parameter>timestamp</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t</type><parameter> source</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t </type><parameter>payloadSize</parameter>
                          </methodparam>
                          <methodparam>
                              <type>const void* </type><parameter>payload</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t</type><parameter> barrier</parameter>
                              <initializer>0</initializer>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns a ring fragment item with the timestamp,
                            source id and barrier as described by the
                            <parameter>timestamp</parameter>,
                            <parameter>source</parameter>, and
                            <parameter>barrier</parameter> parameters.
                            The payload size and contents are as in
                            <parameter>payloadSize</parameter> and
                            <parameter>payload</parameter>.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual ::CRingFragmentItem*</type>
                          <methodname> makeRingFragmentItem</methodname>
                          <methodparam>
                              <type>const ::CRingItem&amp;</type><parameter> rhs</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            If <parameter>rhs</parameter> is a ring fragment item returns a fragment
                            item that is functionally equivalent to <parameter>rhs</parameter>.
                            If <parameter>rhs</parameter> is not a fragment item,
                            throws a <classname>std::bad_cast</classname>
                            exception.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual ::CRingPhysicsEventCountItem* </type>
                          <methodname>makePhysicsEventCountItem</methodname>
                            <methodparam>
                                <type>uint64_t</type><parameter>count</parameter>
                            </methodparam>
                            <methodparam>
                                <type>uint32_t </type><parameter>timeoffset</parameter>
                            </methodparam>
                            <methodparam>
                                <type>time_t </type><parameter>stamp</parameter>
                            </methodparam>
                            <methodparam>
                                <type>int </type><parameter>divisor</parameter>
                                <initializer>1</initializer>
                            </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Makes a physics event count item in version 11 format.
                            <parameter>count</parameter> must be the number
                            of triggers handled by the readout system at
                            <parameter>timeoffset</parameter> into the run.
                            <parameter>divisor</parameter> is the number of
                            ticks of <parameter>timeoffset</parameter> in one second.
                           </para>
                           <para>
                            <parameter>stamp</parameter> is the clock time at which
                            the item is being created (should be during the run not
                            during analysis).  It can be generated by a call
                            to the unix <function>time</function> service.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual ::CRingPhysicsEventCountItem* </type>
                          <methodname>makePhysicsEventCountItem</methodname>
                          <methodparam>
                            <type>const ::CRingItem&amp; </type><parameter>rhs</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            If <parameter>rhs</parameter> is an undifferentiated
                            ring item that wraps a physics event count item,
                            this method creates a new
                            <classname>v11::CRingPhysicsEventCountItem</classname>
                            that contains the same information as
                            <parameter>rhs</parameter>.  
                           </para>
                           <para>
                            Note that if
                            <parameter>rhs</parameter> is not a
                            <literal>v11::PHYSICS_EVENT_COUNT</literal> ring
                            item, a <classname>std::bad_cast</classname>
                            exception is thrown.   The behavior of this
                            generator method is not well defined if the
                            ring item comes from another version of NSCLDAQ.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual ::CRingScalerItem* </type>
                          <methodname>makeScalerItem</methodname>
                          <methodparam>
                              <type>size_t </type><parameter>numScalers</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Create a scaler item for V12 that has storage reserved
                            for <parameter>numScalers</parameter> scalers.
                            The interval start and end time must be set
                            at a later time. The scaler storage is initialized
                            to zero and the clock time stamp is initialized to the
                            time this method is called.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual ::CRingScalerItem*</type>
                          <methodname> makeScalerItem</methodname>
                          <methodparam>
                              <type>uint32_t </type><parameter>startTime</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t</type><parameter> stopTime</parameter>
                          </methodparam>
                          <methodparam>
                              <type>time_t</type><parameter>timestamp</parameter>
                          </methodparam>
                          <methodparam>
                              <type>std::vector&lt;uint32_t&gt; </type><parameter>scalers</parameter>
                          </methodparam>
                          <methodparam>
                              <type>bool  </type><parameter>isIncremental </parameter>
                              <initializer>true</initializer>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t </type><parameter> sid </parameter>
                              <initializer>0</initializer>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t</type><parameter>timeOffsetDivisor</parameter>
                              <initializer>1</initializer>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Creates a version 12  scaler item that is fully
                            populated.  <parameter>startTime</parameter> and
                            <parameter>stopTime</parameter> along with
                            <parameter>timeOffsetDivisor</parameter> describe
                            the time interval relative to the start of the run
                            over which the scaler counted.
                            <parameter>timeOffsetdivisor</parameter> specifies
                            the number of ticks in <parameter>startTime</parameter>
                            and <parameter>stopTime</parameter> in one second.
                            If omitted, it defaults to <literal>1</literal>
                            meaning that those parameters are in units of seconds.
                           </para>
                           <para>
                             <parameter>scalers</parameter> is a vector of
                             scaler values.  THe actual meaning of these values
                             depends on the state of  the
                             <parameter>isIncremental</parameter> flag.
                             If <parameter>isIncremental</parameter> is
                             <literal>true</literal>, the scalers represent
                             additional counts over the counting interval.
                             If <literal>false</literal>, the scalers
                             represent cummulative counts since the beginning
                             of the run.
                            </para>
                           <para>
                            The item is created with a body header
                            that has a special timestamp that requests the event
                            builder assign a timestamp from the last timestamped
                            item.  The source id is <parameter>sid</parameter>
                            and barrier type <parameter>0</parameter>.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual ::CRingScalerItem* </type>
                          <methodname>makeScalerItem</methodname>
                          <methodparam>
                              <type>const CRingItem&amp;</type><parameter> rhs</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            If <parameter>rhs</parameter> is a scaler item
                            a new <classname>v11::CRingScalerItem</classname> is
                            made from the data in <parameter>rhs</parameter>.
                            If <parameter>rhs</parameter> is not of type
                            <literal>v11::PERIODIC_SCALERS</literal>
                            a <classname>std::bad_cast</classname> exception
                            is thrown.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual CRingTextItem* </type>
                          <methodname>makeTextItem</methodname>
                          <methodparam>
                              <type>uint16_t </type><parameter>type</parameter>
                          </methodparam>
                          <methodparam>
                              <type>std::vector&lt;std::string&gt; </type><parameter>theStrings</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Creates an item that contains text strings.
                            <parameter>type</parameter> is the ring item
                            type and must be one of <literal>v11::PACKET_TYPES</literal>
                            or <literal>v11::MONITORED_VARIABLES</literal>.
                            The strings themselves are taken from the vector
                            <parameter>theStrings</parameter>.
                           </para>
                           <para>
                            The clock time is filled in from the time at which this
                            method is called and the run time offset is
                            initialized to <literal>0</literal>
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual CRingTextItem* </type>
                          <methodname>makeTextItem</methodname>
                          <methodparam>
                              <type>uint16_t </type><parameter>type</parameter>
                          </methodparam>
                          <methodparam>
                              <type>std::vector&lt;std::string&gt;</type><parameter> theStrings</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t   </type><parameter>offsetTime</parameter>
                          </methodparam>
                          <methodparam>
                              <type>time_t  </type><parameter>timestamp</parameter>
                          </methodparam>
                            <methodparam>
                            <type>uint32_t </type><parameter>divisor</parameter>
                            <initializer>1</initializer>
                        </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Same as the previous methods however the additional
                            parameters serve to initialize other bits otf the
                            ring item: <parameter>offsetTime</parameter>  and
                            <parameter>divisor</parameter> describe the offset into
                            the run at which the item was emitted.  The
                            <parameter>divisor</parameter> parameter provides
                            the number of <parameter>offsetTime</parameter> ticks
                             in a second.  If omitted it defaults to
                             <literal>1</literal> which means that
                             <parameter>offsetTime</parameter> is in units of
                             seconds.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual CRingTextItem*</type>
                          <methodname> makeTextItem</methodname>
                          <methodparam>
                              <type>const CRingItem&amp;</type><parameter> rhs</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Given an undifferentiated ring item; <parameter>rhs</parameter>
                            that encpasulates a valid text item creats a new
                            <classname>v11::CRingTextItem</classname> from the
                            data in <parameter>rhs</parameter>.  If the item is not
                             a valid v12 text item,
                             a <classname>std::bad_cast</classname>
                             exception is thrown.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual CUnknownFragment* </type>
                          <methodname>makeUnknownFragment</methodname>
                          <methodparam>
                              <type>uint64_t </type><parameter>timestamp</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t </type><parameter>sourceid</parameter>
                          </methodparam>
                          <methodparam>
                            <type>uint32_t </type><parameter>barrier</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t </type><parameter>size</parameter>
                          </methodparam>
                          <methodparam>
                              <type>void*</type><parameter> pPayload</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                            
                           <para>
                            Generates and returns a pointer to a
                            <classname>v11::CUnknownFragment</classname>
                            object.   The parameters provided are used to
                            initialize the object data:
                            <parameter>timestamp</parameter>, <parameter>sourceid</parameter>
                            and <parameter>barrier</parameter> provide the
                            header information.
                            <parameter>size</parameter> is the number of bytes
                            of payload pointed to by <parameter>pPayload</parameter>
                            that will be copied into the body of the item.
                           </para>
                           <para>
                            Note that <classname>CUnknownFragment</classname>
                            objects are <classname>CRingFragmentItem</classname>
                            objects with a type of <literal>v11::EVB_UNKNOWN_PAYLOAD</literal>
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual CUnknownFragment* </type>
                          <methodname>makeUnknownFragment</methodname>
                          <methodparam>
                              <type>const CRingItem&amp;</type><parameter>rhs</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            If <parameter>rhs</parameter> is an unknown fragment,
                            produces a copy of it and wraps that in a
                            <classname>v11::CUnknownFragment</classname>
                            object returing a pointer to the resulting object.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual CRingStateChangeItem* </type>
                          <methodname>makeStateChangeItem</methodname>
                          <methodparam>
                              <type>uint32_t </type><parameter>itemType</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t </type><parameter>runNumber</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t</type><parameter> timeOffset</parameter>
                          </methodparam>
                          <methodparam>
                              <type>time_t </type><parameter>timestamp</parameter>
                          </methodparam>
                          <methodparam>
                              <type>std::string </type><parameter>title</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Creates a new run state change item formatted for
                            version 12.  The <parameter>itemType</parameter>
                            defines the new run state and must be one of
                            <literal>v11::BEGIN_RUN</literal>,
                            <literal>v11::PAUSE_RUN</literal>,
                            <literal>v11::RESUME_RUN</literal>,
                            or <literal>v11::END_RUN</literal>.  If it is none of those,
                            a <classname>std::bad_cast</classname> exception is
                            thrown.
                           </para>
                           <para>
                            The remaining parameters define parameters of the run:
                            <parameter>runNumber</parameter> is the unique number
                            of the run.  <parameter>timeOffset</parameter> is
                            the offset into the run at which the state change
                            occurerd.  The units of this parameter must be seconds
                           </para>
                           <para>
                            Note that
                            all state change items associated with the same
                            run should have the same title and run number.
                            This is not enforced.  The <parameter>timeOffset</parameter>
                            for a <literal>v11::BEGIN_RUN</literal> item should
                            always be <literal>0</literal>, but this too is not
                            enforced.  Finally, the <parameter>timestamp</parameter>
                            parameter can be the output of a call to the
                            unix <function>time</function> function.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual CRingStateChangeItem* </type>
                          <methodname>makeStateChangeItem</methodname>
                          <methodparam>
                              <type>const CRingItem&amp;</type><parameter> rhs</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            If <parameter>rhs</parameter> is an undifferentiated
                            ring item that encapsualtes a valid v11 run state
                            transition ring object, a new
                            <classname>v11::CRingStateChangeItem</classname>
                            is created encapsulating the same information.
                            If <parameter>rhs</parameter> is not a valid
                            v10 run state transition item,
                            a <classname>std::bad_cast</classname> exception
                            is thrown.
                           </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </refsect1>
        </refentry>
        <refentry>
           <refmeta>
              <refentrytitle>CRingItem (v11)</refentrytitle>
              <manvolnum>3format</manvolnum>
           </refmeta>
           <refnamediv>
              <refname>CRingItem (v11)</refname>
              <refpurpose>Encapsulate version 11 ring items.</refpurpose>
            </refnamediv>
            <refsynopsisdiv>
                <programlisting>
#include &lt;v11/CRingItem.h&gt;


namespace v11 {

class CRingItem : public ::CRingItem
{
  
public:
  CRingItem(uint16_t type, size_t maxBody);
  CRingItem(uint16_t type, uint64_t timestamp, uint32_t sourceId,
            uint32_t barrierType, size_t maxBody );
 
public:
  
  virtual size_t getBodySize()    const;
  virtual const void*  getBodyPointer() const;
  virtual void* getBodyPointer();
  virtual bool hasBodyHeader() const;
  uint64_t getEventTimestamp() const;
  uint32_t getSourceId() const;
  uint32_t getBarrierType() const;
  virtual void setBodyHeader(uint64_t timestamp, uint32_t sourceId,
                     uint32_t barrierType = 0);
  virtual void* getBodyHeader() const;

  virtual std::string typeName() const;	// Textual type of item.
  virtual std::string toString() const; // Provide string dump of the item.

  std::string bodyHeaderToString() const;
  
};

}
                </programlisting>
            </refsynopsisdiv>
            <refsect1>
                     <title>DESCRIPTION</title>
                  <para>
                    <classname>v11::CRingItem</classname> encapsulates
                    an undifferentiated ring item.   By undifferentiated,
                    we mean that any ring item type can be encapsulated
                    by this ring item and that there are no ring item type
                    specific methods.
                  </para>
                  <para>
                    However <classname>v11::CRingItem</classname>
                    provides important services for ring item objects and
                    its data can be used to construct other, specific,
                    ring item classes via the ring item factory.
                  </para>
                  <para>
                    <classname>v11::CRingItem</classname> can have  a body header.
                  </para>
            </refsect1>
            <refsect1>
                <title>METHODS</title>
                <variablelist>
                    <varlistentry>
                       <term>
                        <constructorsynopsis>
                            <methodname>CRingItem</methodname>
                            <methodparam>
                                <type>uint16_t</type><parameter>type</parameter>
                            </methodparam>
                            <methodparam>
                                <type>size_t </type><parameter>maxBody</parameter>
                                <initializer>CRingItemStaticBufferSize - 10</initializer>
                            </methodparam>
                        </constructorsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Constructor.  <parameter>type</parameter> will be stored
                            in the ring item header's type field.  Note that
                            the header form is common for all formats.
                            The <parameter>type</parameter> is 16 bit wide because in
                            the original design it was also used to determine the
                            byte order of the originator.  Specifically, if the
                            'low order' 16 bits of a type field were zero, the
                            byte order of the originator was the opposite of the
                            consumer.  Now that little-endianess has won the
                            byte order wars and big-endinaness only appears
                            vestigially in network byte ordering,  We define
                            the byte ordering of Ring items to be little-endian.
                           </para>
                           <para>
                            <parameter>maxBody</parameter> determines the maximum
                            number of bytes the internal storage for the ring item
                            can hold in the body (the part following the header).
                            Note that the design of <classname>CRingItem</classname>
                            includes a decently sized static block of data.
                            If this value indicates the data will fit in that
                            block, no dynamic memory allocation is required and
                            that block is used.  If this value indicates that
                            the data won't fit, a block is dynamically allocated
                            and used.  The intent is to minimize the costly
                            set of dynamic memory allocations/deallocations
                            needed if all <classname>CRingItem</classname>
                            constructions dynamically allocated the needed
                            data.
                           </para>
                           <para>
                            The default value for <parameter>maxBody</parameter>
                            allows callers to use the static buffer and is
                            defined in <filename>CRingItem.h</filename>.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <constructorsynopsis>
                            <methodname>CRingItem</methodname>
                            <methodparam>
                                <type>v11::pRingItem </type><parameter>pItem</parameter>
                            </methodparam>
                        </constructorsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Wraps a <classname>CRingItem</classname> object
                            around a raw ring item.  The type
                            <type>pRingItem</type> is defined in
                            <filename>DataFormat.h</filename>.
                           </para>
                           <para>
                            <parameter>pItem</parameter> is used to size
                            the ring item and copied into the data storage
                            region of the item.  The body cursor is set to point
                            after the ring item data.  This allows the
                            item to be mutated (via <methodname>getBodyPointer</methodname>)
                            and to be extended (via <methodname>getBodyCursor</methodname>,
                            <methodname>setBodyCursor</methodname>, and <methodname>updateSize</methodname>).
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual size_t </type>
                           <methodname>getStorageSize</methodname>
                           <void />
                           <modifier>const</modifier>
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Returns the capacity of the block of data that is being used
                            to store the ring item.   Can be used to determine
                            if sufficient storage has been allocated to
                            hold the desired ring item.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual size_t </type>
                           <methodname>getBodySize</methodname>
                           <void />
                           <modifier>const</modifier>
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Returns the current size, in bytes,
                            of the ring item body.
                            This computes the number of bytes between the
                            pointers returned by
                            <methodname>getBodyCursor</methodname> and the
                            <methodname>geBodyPointer</methodname>.  For it to be
                            accurate, <methodname>getBodyCursor</methodname>
                            must be updated (via <methodname>setBodyCursor</methodname>)
                            to point past the body of the ring item as it is
                            so far.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual const void*  </type>
                           <methodname>getBodyPointer</methodname>
                           <void /><modifier>const</modifier>
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Returns a pointer to the body of the item. Since
                            the pointer is const, this is intended to allow
                            read access.  Note that the concept of a ring item
                            <firstterm>body</firstterm> is not that straightforward.
                            V11 support returns either a pointer after the items' body
                            header or after the word that indcates there
                            is no body header -- that is a pointer to the payload
                            section of the ring item data.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type> virtual void* </type>
                           <methodname>getBodyPointer</methodname>
                           <void />
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Same as above except that the pointer can be used
                            to modify the body contents.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>void*  </type>
                          <methodname>getBodyCursor</methodname>
                          <void />
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the body cursor of the item. When a ring item
                            is created, a pointer, called the body cursor is
                            created which points to the first free byte of memory
                            into which data can be appended to the ring item.
                            As data are appended to the ring item, the
                            object's body cursor should be reste with
                            <methodname>setBodyCursor</methodname>, at some point,
                            when the ring item has been completely built,
                            <methodname>updateSize</methodname> should be called
                            to compute the ring item's size and store it in the
                            size field of the ring item's header.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>pRingItem  </type>
                          <methodname>getItemPointer</methodname>
                          <void />
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns a pointer to the ring item as encapsulated
                            by this class.  Note that <type>pRingItem</type>
                            is defined in <filename>v11/DataFormat.h</filename>.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>const RingItem*  </type>
                          <methodname>getItemPointer</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Same as above but the pointer only allows read access
                            to the contents of the ring item.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>uint32_t </type>
                          <methodname>type</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the full 32 bit type field of the
                            ring item.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>uint32_t </type>
                          <methodname>size</methodname>
                          <void /> <modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the size field of the header. Note that unless
                            <methodname>updateSize</methodname> has been called,
                            this value is not a reliable measure of the number
                            of bytes that make up the ring item.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual bool </type>
                          <methodname>mustSwap</methodname>
                          <void /> <modifier> const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns <literal>false</literal>.  All data is
                            now specified be little endian as are all computing
                            systems processing that data.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual bool </type>
                          <methodname>hasBodyHeader</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns <literal>true</literal> if the ring item
                            has a body header.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void* </type>
                          <methodname>getBodyHeader</methodname>
                          <void /> <modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns a pointer to the body header of the item
                            if it has one.  If it does not returns a
                            <literal>nullptr</literal>. 
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual uint64_t </type>
                           <methodname>getEventTimestamp</methodname>
                           <void /> <modifier>const</modifier>
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Returns the event/fragment timestamp stored
                            in the body header of the ring item.  If the ring
                            item has no body header,
                            <classname>std::logic_error</classname> is thrown.
                            You can use e.g. <methodname>hasBodyHeader</methodname>
                            to test for the presence of a body header in the
                            item.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual uint32_t </type>
                          <methodname>getSourceId</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Retrieves the source id from the ring item's body header.
                            If the ring item does not have a body header,
                            <classname>std::logic_error</classname> is throw
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual uint32_t </type>
                          <methodname>getBarrierType</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the barrier type field from the item's
                            body header.   If the ring item does not have a body
                            header, <classname>std::logic_error</classname>
                            is thrown.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                          <type>virtual void </type>
                          <methodname>setBodyHeader</methodname>
                          <methodparam>
                              <type>uint64_t </type><parameter>timestamp</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t </type><parameter>sourceId</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t </type><parameter>barrierType</parameter>
                              <initializer>0</initializer>
                          </methodparam>
                       </methodsynopsis>
                       
                       </term>
                       <listitem>
                           <para>
                            If the item does not have a body header (yet),
                            data are moved to reserve space for it just following
                            the ring item header.  The body header is filled
                            in with data from the parameters
                            <parameter>timestamp</parameter>,
                            <parameter>sourceId</parameter> and
                            <parameter>barrierType</parameter>
                           </para>
                           <para>
                            If the item already has a body header, its contents
                            are modified in accordance with the parameters.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void </type>
                          <methodname>setBodyCursor</methodname>
                          <methodparam>
                              <type>void* </type><parameter>pNewCursor</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Updates the internal body cursor of the object
                            with <parameter>pNewCursor</parameter>.  If coupled
                            with a call to <methodname>updateSize</methodname>,
                            this causes the size field of the ring item header
                            to be computed and updated.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void</type>
                          <methodname>updateSize</methodname>
                          <void />
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Treating the current body cursor value as a pointer
                            to the byte following the current contents of the
                            ring item, the size of the ring item is computed
                            and stored in the size field of the ring item
                            header.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual std::string </type>
                          <methodname>typeName</methodname>
                          <void /> <modifier>() const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            The base class returns the string:
                            <literal>Unknown</literal> followed by the parenthesized
                            numeric
                            type from the ring item header in hexadecimal.
                            Derived classes are
                            expected to return a text string which indicates the
                            type of the ring item. 
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual std::string </type>
                          <methodname>toString</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns a human readable stringified dump
                            of the body of the item.  In this case this is just
                            a byte by byte dump.  Derived classes are expected
                            to return something a bit more meaningful.  The
                            NSCLDAQ dumper, e.g. uses this string to
                            dump items it encounters.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void* </type>
                          <methodname>appendBodyData</methodname>
                          <methodparam>
                              <type>const void* </type><parameter>pSrc</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t </type><parameter>nBytes
                              </parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Appends the <parameter>nBytes</parameter> bytes
                            of data pointed to by <parameter>pSrc</parameter>
                            to the ring item.  The data are placed where
                            the current body cursor is pointing.  The body cursor
                            is updated and the size recomputed.
                           </para>
                           <para>
                            This is equivalent to the following code fragment:
                           </para>
                           <informalexample>
                            <programlisting>
  uint8_t* p = reinterpret_cast&lt;uint8_t*&gt;(getBodyCursor());
  memcpy(p, pSrc, nBytes);
  p += nBytes;
  setBodyCursor(p);
  updateSize();
  return p;

                            </programlisting>
                           </informalexample>
                           <para>
                            The ring item object must have the capacity for the
                            additional bytes of data.
                           </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </refsect1>
        </refentry>
        <refentry>
           <refmeta>
              <refentrytitle>CAbnormalEndItem (v11)</refentrytitle>
              <manvolnum>3FORMAT</manvolnum>
           </refmeta>
           <refnamediv>
              <refname>CAbnormalEndItem (v11)</refname>
              <refpurpose>Encapsulate abnormal end run item.</refpurpose>
            </refnamediv>
            <refsynopsisdiv>
                <programlisting>
#include &lt;CAbnormalEndItem.h&gt;

namespace v11 {
class CAbnormalEndItem : public ::CAbnormalEndItem
{
public:
    CAbnormalEndItem();
    virtual bool  hasBodyHeader() const;
    virtual void* getBodyHeader() const;
    virtual void  setBodyHeader(uint64_t timestamp, uint32_t sourceId,
                         uint32_t barrierType = 0);
    
    
    virtual std::string typeName() const;
    virtual std::string toString() const;
};

                </programlisting>
            </refsynopsisdiv>
            <refsect1>
                     <title>DESCRIPTION</title>
                  <para>
                    Abnormal end items are sent into the event stream to mark
                    an end to data taking that was not commanded by an end run.  They
                    allow downstream analysis and recording software to close up
                    processing on the run in progress as well as to note that some
                    recovery may be required prior to restarting data taking.
                  </para>
                  <para>
                    Abnormal end items in v11 look like ring item headers followed
                    by a <literal>0</literal> uint32_t indicating the lack of
                    a body header.
                  </para>
            </refsect1>
            <refsect1>
                <title>METHODS</title>
                <variablelist>
                    <varlistentry>
                       <term><constructorsynopsis>
                           <methodname>CAbnormalEndItem</methodname>
                        <void />
                       </constructorsynopsis></term>
                       <listitem>
                           <para>
                            Constructs the item.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void* </type>
                          <methodname>getBodyHeader</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns <literal>nullptr</literal>
                            since these items don't have body headers.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void  </type>
                          <methodname>setBodyHeader</methodname>
                          <methodparam>
                              <type>uint64_t </type><parameter>timestamp</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t </type><parameter>sourceId</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t </type><parameter>barrierType</parameter>
                              <initializer>0</initializer>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Since the <classname>CAbnormalEndItem</classname>
                            never has a body header, this is a no-op.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual std::string </type>
                          <methodname>typeName</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the string
                            <literal>Abnormal End</literal>
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual std::string </type>
                          <methodname>toString</methodname>
                          <void /> <modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the string
                            <literal>Abnormal End\n</literal> where the
                            <literal>\n</literal> should be interpreted to mean
                            a new line.
                           </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </refsect1>
                     
        </refentry>
        <refentry>
           <refmeta>
              <refentrytitle>CDataFormatItem (v11)</refentrytitle>
              <manvolnum>3format</manvolnum>
           </refmeta>
           <refnamediv>
              <refname>CDataFormatItem (v11)</refname>
              <refpurpose>Provide the format version of subsequent data</refpurpose>
            </refnamediv>
            <refsynopsisdiv>
                <programlisting>
#include &lt;v11/CDataFormatITem.h&gt;

namespace v11 {

/
class CDataFormatItem : public ::CDataFormatItem
{
    // Canonical methods:
public:
    CDataFormatItem();
    virtual ~CDataFormatItem();
    
    virtual uint16_t getMajor() const;
    virtual uint16_t getMinor() const;
    
    virtual std::string typeName() const;
    virtual std::string toString() const;
    
    virtual bool hasBodyHeader() const;
    virtual void* getBodyHeader() const;
    virtual void setBodyHeader(uint64_t timestamp, uint32_t sourceId,
                         uint32_t barrierType = 0);
    
    
    
};
}
                </programlisting>
            </refsynopsisdiv>
            <refsect1>
                     <title>DESCRIPTION</title>
                  <para>
                    At the beginning of a run acquired in NSCLDAQ-11,
                    A data format item is emitted specifying that the
                    data format is that of NSCLDAQ-11.  These items, in
                    addition to a ring item header and an indicator that there
                    is no body header, contain a major and minor version number.
                  </para>
                  <para>
                    In practice the minor version number is 0 and is not important
                    for decoding ring items.
                  </para>
            </refsect1>
            <refsect1>
                <title>METHODS</title>
                <variablelist>
                   <varlistentry>
                      <term><constructorsynopsis>
                          <methodname>CDataFormatItem</methodname>
                        <void />
                      </constructorsynopsis></term>
                      <listitem>
                          <para>
                            The constructor fills in the item with the
                            major and minor vesions that define the data
                            format.
                       </para>
                    </listitem>
                   </varlistentry>
                   <varlistentry>
                      <term><methodsynopsis>
                         <type>virtual uint16_t </type>
                         <methodname>getMajor </methodname>
                         <void /><modifier>const</modifier>
                      </methodsynopsis></term>
                      <listitem>
                          <para>
                            Returns the major version of the data format.  In
                            practice, this is sufficient to establish the data
                            format.
                       </para>
                    </listitem>
                   </varlistentry>
                   <varlistentry>
                      <term><methodsynopsis>
                         <type>virtual uint16_t </type>
                         <methodname>getMinor</methodname>
                         <void /><modifier>const</modifier>
                      </methodsynopsis></term>
                      <listitem>
                          <para>
                            Returns the minor version of the data format.  In practice
                            this is seldom necessary.
                       </para>
                    </listitem>
                   </varlistentry>
                   <varlistentry>
                      <term><methodsynopsis>
                         <type>virtual std::string </type>
                         <methodname>typeName</methodname>
                         <void /><modifier>const</modifier>
                      </methodsynopsis></term>
                      <listitem>
                          <para>
                            Return the string:
                            <literal>Ring Item format version</literal>
                       </para>
                    </listitem>
                   </varlistentry>
                   <varlistentry>
                      <term><methodsynopsis>
                         <type>virtual std::string </type>
                         <methodname>toString</methodname>
                         <void /> <modifier>const</modifier>
                      </methodsynopsis></term>
                      <listitem>
                          <para>
                            Returns a human readable string that describes the
                            contents of the ring item.
                       </para>
                    </listitem>
                   </varlistentry>
                   <varlistentry>
                      <term><methodsynopsis>
                         <type>virtual void* </type>
                         <methodname>getBodyHeader</methodname>
                         <void /><modifier>const</modifier>
                      </methodsynopsis></term>
                      <listitem>
                          <para>
                            Returns <literal>nullptr</literal> since these items
                            never have a body header.
                       </para>
                    </listitem>
                   </varlistentry>
                   <varlistentry>
                      <term><methodsynopsis>
                         <type>virtual void </type>
                         <methodname>setBodyHeader</methodname>
                         <methodparam>
                             <type>uint64_t </type><parameter>timestamp</parameter>
                         </methodparam>
                         <methodparam>
                             <type>uint32_t </type><parameter>sourceId</parameter>
                         </methodparam>
                         <methodparam>
                             <type>uint32_t </type><parameter>barrierType </parameter>
                             <initializer>0</initializer>
                         </methodparam>
                      </methodsynopsis></term>
                      <listitem>
                          <para>
                            No-op since these items don't have body headers.
                       </para>
                    </listitem>
                   </varlistentry>                    
                </variablelist>
            </refsect1>
        </refentry>
        <refentry>
           <refmeta>
              <refentrytitle>CGlomParameters (V11)</refentrytitle>
              <manvolnum>3format</manvolnum>
           </refmeta>
           <refnamediv>
              <refname>CGlomParameters (V11)</refname>
              <refpurpose>Document event builder parameters.</refpurpose>
            </refnamediv>
            <refsynopsisdiv>
                <programlisting>
#include &lt;v11/CGlomParameters.h&gt;

namespace v11 {
class CGlomParameters : public ::CGlomParameters
{

    
public:
   CGlomParameters(uint64_t interval, bool isBuilding, TimestampPolicy policy);
   uint64_t coincidenceTicks() const;
   bool     isBuilding() const;
   TimestampPolicy timestampPolicy() const;
   virtual std::string typeName() const;
   virtual std::string toString() const;
   virtual bool  hasBodyHeader() const;
   virtual void* getBodyHeader() const;
   virtual void setBodyHeader(uint64_t timestamp, uint32_t sourceId,
                         uint32_t barrierType = 0);
   

};

}                                // v11 namespace

                </programlisting>
            </refsynopsisdiv>
            <refsect1>
                     <title>DESCRIPTION</title>
                  <para>
                    The <classname>v11::CGlomParameters</classname>
                    class provides the ability to document three
                    event builder settings in the event stream:
                  </para>
                  <itemizedlist>
                    <listitem>
                       <para>
                          <literal>isBuilding</literal> -A boolean that, if true,
                          indicates the event builder glom stage is actualy
                          building events rather than emitting single
                          fragment events.
                       </para>
                    </listitem>
                    <listitem>
                       <para>
                          <literal>coincidenceTicks</literal>
                          The number of timestamp ticks in the coincidence interval
                          that determines if fragments belong in the sam event.
                          This is meaningless if the <literal>isBuilding</literal>
                          flag is false.
                       </para>
                    </listitem>
                    <listitem>
                       <para>
                          <literal>timestampPolicy</literal> Determines how
                          timestamps are assigned to output events from the fragments
                          in that event.
                       </para>
                    </listitem>
                  </itemizedlist>
                  <para>
                    In general, glom parameter items do not have body headers.
                  </para>
            </refsect1>
            <refsect1>
                <title>METHODS</title>
                <variablelist>
                    <varlistentry>
                       <term><constructorsynopsis>
                           <methodname>CGlomParameters</methodname>
                        <methodparam>
                            <type>uint64_t </type><parameter>interval</parameter>
                        </methodparam>
                        <methodparam>
                            <type>bool </type><parameter>isBuilding</parameter>
                        </methodparam>
                        <methodparam>
                            <type>TimestampPolicy </type><parameter>policy</parameter>
                        </methodparam>
                       </constructorsynopsis></term>
                       <listitem>
                           <para>
                            Fully parameterized construction.  <parameter>interval</parameter>
                            is the coincidence interval used to build events from
                            the sorted fragments.  If <parameter>isBuilding</parameter>
                            is false, the output stream is just a stream of single
                            fragment events, regardless of the coincidence interval.
                            This is intended for use in testing only.
                            <parameter>>policy</parameter> is the policy used to derive
                            timestamps of the output event stream from the
                            fragments that compose them.
                            See <literal>DATA TYPES and CONSTANTS</literal>
                            for valid values and their meanings.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual uint64_t </type>
                          <methodname>coincidenceTicks</methodname>
                          <void /> <modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the coincidence interval stored in the object.
                            The units of this value are timestamp ticks.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual bool     </type>
                          <methodname>isBuilding</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the state of the object's building flag.
                            If true, the data are event built. If not the
                            event builder was run in a test mode where
                            each event output consists of a single fragment.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual TimestampPolicy </type>
                          <methodname>timestampPolicy</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the timestamp policy used to derive the
                            timestamp of output events.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual std::string </type>
                          <methodname>typeName</methodname>
                          <void /> <modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns a string that identifies the ring item type:
                            <literal>Glom Parameters</literal>.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual std::string </type>
                          <methodname>toString</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns a stringified representation of the object.
                            Intended for use in e.g. <command>dumper</command>.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void* </type>
                          <methodname>getBodyHeader</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns a pointer to the object's body header.
                            Since glom parameter items dont, at present,
                            have body headers, expect a
                            <literal>nullptr</literal> to be returned.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void </type>
                          <methodname>setBodyHeader</methodname>
                          <methodparam>
                              <type>uint64_t </type><parameter>timestamp</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t sourceId</type><parameter></parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t </type><parameter>barrierType</parameter>
                              <initializer>0</initializer>
                          </methodparam>
                       </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Sets/adds a body header to the item.  Since
                            glom parameter items don't have a body header,
                            this is a no-op.
                           </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </refsect1>
            <refsect1>
                <title>DATA TYPES and CONSTANTS</title>
                <para>
                    The <classname>CGlomParameters</classname> class provides
                    a single data type:  <type>TimestampPolicy</type>.  THe
                    event builder in NSCLDAQ supports hierarchical event building.
                    This means that the output of an event builder can be input
                    for a subsequent event builder in the data acquisition
                    data flow.
                </para>
                <para>
                    This allows detector systems which require an event builder
                    of their own to be run together with other detector systems
                    by simply providing a second level event builder to glue together
                    events from each detector subsystem into coincident events.
                </para>
                <para>
                    This ability for hierarchical event building requires that
                    output events are also given a timestamp.  The
                    <type>TimestampPolicy</type> data type provides a type that
                    specifies how this output timestamp is determined.  It
                    can have the following values:
                </para>
                <variablelist>
                    <varlistentry>
                       <term><literal>first</literal></term>
                       <listitem>
                           <para>
                            The output timestamp is taken from the earliest (first)
                            fragment's timestamp.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><literal>last</literal></term>
                       <listitem>
                           <para>
                            The output timestamp is taken from the latest (last)
                            fragment's timestamp.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><literal>average</literal></term>
                       <listitem>
                           <para>
                            The output timestamp is the average of all timestamps
                            of the fragments that make up the event.
                           </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </refsect1>
        </refentry>
        <refentry>
           <refmeta>
              <refentrytitle>CPhysicsEventItem (v11)</refentrytitle>
              <manvolnum>3format</manvolnum>
           </refmeta>
           <refnamediv>
              <refname>CPhysicsEventItem (v11)</refname>
              <refpurpose>Encapsulate a physics event.</refpurpose>
            </refnamediv>
            <refsynopsisdiv>
                <programlisting>
#include &lt;v11/CPhysicsEventItem&gt;


namespace v11 {

class CPhysicsEventItem : public ::CPhysicsEventItem
{
public:
  CPhysicsEventItem(size_t maxBody=8192);
  CPhysicsEventItem(                                 // Our factory can use this.
       uint64_t timestamp, uint32_t source, uint32_t barrier,
       size_t maxBody=8192
   );
  virtual size_t getBodySize()    const;
  virtual const void*  getBodyPointer() const;
  virtual void* getBodyPointer();
  virtual bool hasBodyHeader() const;
  virtual uint64_t getEventTimestamp() const;
  virtual uint32_t getSourceId() const;
  virtual uint32_t getBarrierType() const;

  virtual std::string typeName() const;	// Textual type of item.
  virtual std::string toString() const; // Provide string dump of the item.

  virtual void* getBodyHeader() const;
  virtual void setBodyHeader(
        uint64_t timestamp, uint32_t sourceId,
        uint32_t barrierType = 0
  );

 
 
};
}

                </programlisting>
            </refsynopsisdiv>
            <refsect1>
                     <title>DESCRIPTION</title>
                  <para>
                    Ring item to encapsulate the application
                    specific physics event data ring item.
                  </para>
            </refsect1>
            <refsect1>
                <title>METHODS</title>
                <variablelist>
                    <varlistentry>
                       <term><constructorsynopsis>
                           <methodname>CPhysicsEventItem</methodname>
                        <methodparam>
                            <type>size_t </type><parameter>maxBody</parameter>
                            <initializer>8192</initializer>
                        </methodparam>
                       </constructorsynopsis></term>
                       <listitem>
                           <para>
                            Constructs an item for a single physics trigger.
                            Note that the storage size is statically allocated
                            with <parameter>maxBody</parameter> bytes of payload
                            data.  The ring item header type field is initialized
                            to <literal>PHYSICS_EVENT</literal>.
                           </para>
                           <para>
                            Upon creating the item, if a body header
                            is required, <methodname>setBodyHeader</methodname>
                            is invoked.  <methodname>getBodyCursor</methodname>
                            is then used get a pointer into the object at where
                            the physics data should be put.  After incrementing
                            this pointer by an appopriate amount,
                            calls to <methodname>setBodyCursor</methodname>,
                            folowed by <methodname>updateSize</methodname>
                            are required to set the size field of the
                            ring item header.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual std::string </type>
                          <methodname>typeName</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns a string that represents the ring item type:
                            <literal>Event</literal>
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual std::string </type>
                          <methodname>toString</methodname>
                          <void /> <modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns a string that represents the contents of the
                            event.  This is used, e.g., by the
                            <command>dumper</command> command to render human
                            readable data.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void*</type>
                          <methodname>getBodyHeader</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns a pointer to the body header for the event.
                            If the event has no body header,
                            <literal>nullptr</literal> is returned. Note that
                            the base class <methodname>hasBodyHeader</methodname>
                            can be called to determine if the ring item type has
                            a body header.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void </type>
                          <methodname>setBodyHeader</methodname>
                          <methodparam>
                              <type>uint64_t </type><parameter>timestamp</parameter>
                          </methodparam>
                          <methodparam>
                              <type> uint32_t </type><parameter>sourceId</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t </type><parameter>barrierType </parameter>
                              <initializer>0</initializer>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Inserts a new or modifies an existing body header of the event.
                           </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </refsect1>
        </refentry>
        <refentry>
           <refmeta>
              <refentrytitle>CRingFragmentItem (v11)</refentrytitle>
              <manvolnum>3format</manvolnum>
           </refmeta>
           <refnamediv>
              <refname>CRingFragmentItem (v11)</refname>
              <refpurpose>Encapsulate an event builder fragment.</refpurpose>
            </refnamediv>
            <refsynopsisdiv>
                <programlisting>
#include &lt;v11/CRingFragmentItem.h&gt;

namespace v11 {

class CRingFragmentItem : public ::CRingFragmentItem
{
public:
  CRingFragmentItem(uint64_t timestamp, 
		    uint32_t source, 
		    uint32_t payloadSize, 
		    const void* pBody,
		    uint32_t barrier=0);

  virtual uint64_t     timestamp() const;
  virtual uint32_t     source() const;
  virtual size_t       payloadSize() const;
  virtual void*        payloadPointer();
  virtual uint32_t     barrierType() const;
  virtual const void*  getBodyPointer() const;
  virtual void* getBodyPointer();
  virtual void setBodyHeader(uint64_t timestamp, uint32_t sourceId,
                         uint32_t barrierType = 0) ;
  virtual void* getBodyHeader() const;
  virtual bool hasBodyHeader() const;
  virtual std::string typeName() const;
  virtual std::string toString() const;

};
}
                </programlisting>

            </refsynopsisdiv>
            <refsect1>
                     <title>DESCRIPTION</title>
                  <para>
                    The full NSCLDAQ event builder is broken into two major
                    section.  The <firstterm>orderer</firstterm> takes
                    event fragments from an arbitrary number of sources and
                    emits them in a totally time ordered stream.  The
                    <firstterm>glom</firstterm> program then glues together
                    those physics fragments that occur within a user supplied trigger
                    interval into events.
                  </para>
                  <para>
                    For diagnostic purposes a seldom used program <firstterm>teering</firstterm>
                    can be fit between the orderer and glom.  teering takes the stream
                    of fragments the orderer produces, outputs them to glom and
                    also wraps them in ring items (the stream of event fragments
                    are not ring items) and places those into a ringbuffer
                    where they can be used for diagnostics of the orderer
                    itself.
                  </para>
                  <para>
                    The ring items created are called event builder fragment
                    items and have the type <literal>v11::EVB_FRAGMENT</literal>.
                    The <classname>v11::CRingFragmentItem</classname> can encapsulate
                    these items when the fragment payoad is a ring item.
                    This is a rarely, if ever, used class/object.
                  </para>
            </refsect1>
            <refsect1>
                <title>METHODS</title>
                <variablelist>
                    <varlistentry>
                       <term><constructorsynopsis>
                           <methodname>CRingFragmentItem</methodname>
                        <methodparam>
                            <type>uint64_t </type><parameter>timestamp</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint32_t </type><parameter>source</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint32_t </type><parameter>payloadSize</parameter>
                        </methodparam>
                        <methodparam>
                            <type>const void* </type><parameter>pBody</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint32_t </type><parameter>barrier</parameter>
                            <initializer>0</initializer>
                        </methodparam>
                       </constructorsynopsis></term>
                       <listitem>
                           <para>
                            Constructs the item.  The <parameter>timestamp</parameter>,
                            <parameter>sourcde</parameter> and optional
                            <parameter>barrier</parameter> parameters fill in
                            the body header.  The default value of 0
                            for the <parameter>barrier</parameter> represents a
                            non-barrier event.
                           </para>
                           <para>
                            The payload of the fragment is <parameter>payloadSize</parameter>
                            bytes taken from the data pointed to by <parameter>pBody</parameter>.
                           </para>
                           <para>
                            For this item, type, <parameter>pBody</parameter>
                            is expected to point to an event builder fragment
                            that contains a ring item  Note that it is possible,
                            though it has not yet been done, for the orderer
                            to operate on Non-NSCLDAQ data (non ring items),
                            see <classname>CUnknonwnFragment</classname>.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual uint64_t     </type>
                          <methodname>timestamp</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the timestamp from the item's body header.
                            Note that by definition, fragment items have
                            a body header.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual uint32_t     </type>
                          <methodname>source</methodname>
                          <void /><modifier> const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the source id from the item's body header.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual size_t  </type>
                          <methodname>payloadSize</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the size of the payload. Note that it is
                            acceptable, and normal for this to be computed by the
                            implementation from the ring item size and the body
                            header size
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void*        </type>
                          <methodname>payloadPointer</methodname>
                          <void />
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns a pointer to the payload data.  The pointer
                            allows the data to be edited as well as simply
                            inspected.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual uint32_t     </type>
                          <methodname>barrierType</methodname>
                          <void />
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the item's body header barrier type field.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual std::string </type>
                          <methodname>typeName</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns a string that describes the type of the
                            ring item: <literal>Event fragment</literal>
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual std::string </type>
                          <methodname>toString</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns a string representation of the  contents of
                            the ring item. This is used e.g. by
                            <command>dumper</command>
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void </type>
                          <methodname>setBodyHeader</methodname>
                          <methodparam>
                              <type>uint64_t </type><parameter>timestamp</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t </type><parameter>sourceId</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t </type><parameter>barrierType </parameter>
                              <initializer>0</initializer>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Modifies the contents of the item's body header
                            (this type always has  a body header).
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void* </type>
                          <methodname>getBodyHeader</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns a pointer to the object's body header.
                            Note that the actual shape of the body header
                            depends on the actual data format version.  
                            The <filename>v11/DataFormat.h</filename> header
                            describes the body header to expect from v11
                            data in its definition of the
                            <type>v12::BodyHeader</type> type.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual bool</type>
                          <methodname> hasBodyHeader</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns <literal>true</literal> as this type of ring item
                            always has a body header.
                           </para>
                       </listitem>
                    </varlistentry>
                </variablelist>
            </refsect1>
        </refentry>
        <refentry>
           <refmeta>
              <refentrytitle>CRingPhysicsEventCountItem (v11)</refentrytitle>
              <manvolnum>3format</manvolnum>
           </refmeta>
           <refnamediv>
              <refname>CRingPhysicsEventCountItem (v11)</refname>
              <refpurpose>Encapsulate trigger count ring item.</refpurpose>
            </refnamediv>
            <refsynopsisdiv>
                <programlisting>
#include &lt;v11/CRingPhysicsEventCountItem.h&gt;

namespace v11 {

class CRingPhysicsEventCountItem : public ::CRingPhysicsEventCountItem
{

public:
  CRingPhysicsEventCountItem();
  CRingPhysicsEventCountItem(uint64_t count,
			     uint32_t timeOffset, unsigned divisor);
  CRingPhysicsEventCountItem(uint64_t count,
			     uint32_t timeOffset, time_t stamp, unsigned divisor);
  CRingPhysicsEventCountItem(uint64_t count, 
			     uint32_t timeoffset, 
			     time_t stamp, uint64_t timestamp, uint32_t sid, unsigned divisor = 1,
           uint32_t barrier=0);
  virtual uint32_t getTimeOffset() const;
  virtual void     setTimeOffset(uint32_t offset);
  virtual float    computeElapsedTime() const;
  virtual uint32_t getTimeDivisor() const;

  virtual time_t   getTimestamp() const;
  virtual void     setTimestamp(time_t stamp);

  virtual uint64_t getEventCount() const;
  virtual void     setEventCount(uint64_t count);

  virtual uint32_t getOriginalSourceId() const;
  
  virtual void*     getBodyPointer() ;
  virtual const void* getBodyPointer() const;
  virtual size_t  getBodySize() const;
  virtual bool hasBodyHeader() const;
  virtual void setBodyHeader(uint64_t timestamp, uint32_t sourceId,
                         uint32_t barrierType = 0);
  virtual void* getBodyHeader() const; 


  virtual std::string typeName() const;	
  virtual std::string toString() const; 


};
}                                      // v
                </programlisting>
            </refsynopsisdiv>
            <refsect1>
                     <title>DESCRIPTION</title>
                  <para>
                    Periodically the NSCLDAQ readout frameworks emit ring items
                    that document the number of triggers that have resulted in
                    data.  Similarly, the glom stage of the event builder outputs
                    ring items that document the number of events it has built.
                    These are intended to be used by online software that may,
                    for performance reasons, have to sample data from the
                    online data flow.
                  </para>
                  <para>
                    A legitimate question users may ask of such program is
                    "What fraction of the data has it analyzed this run?"
                    Trigger count ring items allow this question to be answered,
                    such programs can simply count the number of physics event
                    ring items they've processed and, when they see a trigger
                    count ring item, divide that by the number of triggers.
                  </para>
                  <para>
                    The <classname>CRingPhysicsEventCountItem</classname>
                    class provides a class that, when instantiated, can encapsulate
                    a trigger count ring item.
                  </para>
                  <para>
                    Note that <classname>CRingPhysicsEventCountItem</classname>
                    objects may have body headers.
                  </para>
            </refsect1>
            <refsect1>
                <title>METHODS</title>
                <variablelist>
                    <varlistentry>
                       <term><constructorsynopsis>
                           <methodname>CRingPhysicsEventCountItem</methodname>
                        <void />
                       </constructorsynopsis></term>
                       <listitem>
                           <para>
                            Constructs an event count item with a count of zero,
                            run time offset of zero and timestamp of the time
                            the constructor was invoked.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><constructorsynopsis>
                           <methodname>CRingPhysicsEventCountItem</methodname>
                        <methodparam>
                            <type>uint64_t </type><parameter>count</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint32_t </type><parameter>timeOffset</parameter>
                        </methodparam>
                        <methodparam>
                            <type>unsigned </type><parameter>divisor</parameter>
                        </methodparam>
                       </constructorsynopsis></term>
                       <listitem>
                           <para>
                            Creates an event count item where the trigger
                            count is initialized to <parameter>count</parameter>.
                            The run offset is given by <parameter>timeOffset</parameter>
                            with <parameter>divisor</parameter> ticks per second.
                            The clock time is set to the construction time of
                            the object.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><constructorsynopsis>
                           <methodname>CRingPhysicsEventCountItem</methodname>
                        <methodparam>
                            <type>uint64_t </type><parameter>count</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint32_t </type><parameter>timeoffset</parameter>
                        </methodparam>
                        <methodparam>
                            <type>time_t </type><parameter>stamp</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint32_t </type><parameter>sid</parameter>
                        </methodparam>
                        <methodparam>
                            <type> unsigned </type><parameter>divisor</parameter>
                            <initializer>1</initializer>
                        </methodparam>
                       </constructorsynopsis></term>
                       <listitem>
                           <para>
                            Full construction of a physics event count item
                            with a prototypical body header.  The additional
                            parameter from the previous constructor are
                            <parameter>stamp</parameter>, which provides
                            the clock time at which the item was constructed and
                            <parameter>sid</parameter> which provides the source
                            id for the original source id field (if any) of the
                            item.  
                           </para>
                           <para>
                            The original source id allows analysis programs to
                            track the originating data source for this item.
                            Note that the constructor does not produce a
                            body  header but one can be added with
                            <methodname>setBodyHeader</methodname>.
                            
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual uint32_t </type>
                          <methodname>getTimeOffset</methodname>
                          <void /> <modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the raw time offset into the run at which
                            this item was created.  Note that
                            <methodname>computeElapsedTime</methodname> is the
                            preferred method to get the elapsed run time.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void     </type>
                          <methodname>setTimeOffset</methodname>
                          <methodparam>
                              <type>uint32_t</type><parameter> offset</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Sets the object's raw run time offset.  This
                            offset is uncorrected by the offset divisor.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual float    </type>
                          <methodname>computeElapsedTime</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Computes the elapsed time in the run at which this
                            was emitted from the raw offset and the divisor.
                            Units are seconds.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual uint32_t </type>
                          <methodname>getTimeDivisor</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the number of ticks in a second in the
                            elapsed time raw value.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type> virtual time_t   </type>
                          <methodname>getTimestamp</methodname>
                          <void />
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Return the clock time associated with the item.
                           </para>
                        </listitem>
                    </varlistentry>
                   <varlistentry>
                      <term><methodsynopsis>
                         <type>virtual void     </type>
                         <methodname>setTimestamp</methodname>
                         <methodparam>
                             <type>time_t </type><parameter>stamp</parameter>
                         </methodparam>
                      </methodsynopsis></term>
                      <listitem>
                          <para>
                            Sets the clock time associated with the item.
                       </para>
                    </listitem>
                   </varlistentry>
                   <varlistentry>
                      <term><methodsynopsis>
                         <type>virtual uint64_t </type>
                         <methodname>getEventCount</methodname>
                         <void /><modifier>const</modifier>
                      </methodsynopsis></term>
                      <listitem>
                          <para>
                            Return the number of triggers documented by this
                            item.
                       </para>
                    </listitem>
                   </varlistentry>
                   <varlistentry>
                      <term><methodsynopsis>
                         <type>virtual void     </type>
                         <methodname>setEventCount</methodname>
                         <methodparam>
                             <type>uint64_t </type><parameter>count</parameter>
                         </methodparam>
                      </methodsynopsis></term>
                      <listitem>
                          <para>
                            sets the item's trigger count.
                       </para>
                    </listitem>
                   </varlistentry>
                   <varlistentry>
                      <term><methodsynopsis>
                         <type>virtual uint32_t </type>
                         <methodname>getOriginalSourceId</methodname>
                         <void /><modifier> const</modifier>
                      </methodsynopsis></term>
                      <listitem>
                          <para>
                            Returns the source id of the data source that emitted
                            this object.
                       </para>
                    </listitem>
                   </varlistentry>
                   <varlistentry>
                      <term>
                        <methodsynopsis>
                           <type>virtual std::string </type>
                           <methodname>typeName</methodname>
                           <void /><modifier>const</modifier>
                        </methodsynopsis>
                      </term>
                      <listitem>
                          <para>
                            Returns a string indicating the type of ring item
                            this object is:  <literal>Trigger count</literal>
                       </para>
                    </listitem>
                   </varlistentry>
                   <varlistentry>
                      <term><methodsynopsis>
                         <type>virtual std::string </type>
                         <methodname>toString</methodname>
                         <void /><modifier>const</modifier>
                      </methodsynopsis></term>
                      <listitem>
                          <para>
                            Return  a string that describes the contents of the
                            item.  This is used by, e.g. <command>dumper</command>
                       </para>
                    </listitem>
                   </varlistentry>
                   <varlistentry>
                      <term><methodsynopsis>
                         <type>virtual void </type>
                         <methodname>setBodyHeader</methodname>
                         <methodparam>
                             <type>uint64_t </type><parameter>timestamp</parameter>
                         </methodparam>
                         <methodparam>
                             <type>uint32_t </type><parameter>sourceId</parameter>
                         </methodparam>
                         <methodparam>
                             <type>uint32_t </type><parameter>barrierType </parameter>
                             <initializer>0</initializer>
                         </methodparam>
                      </methodsynopsis></term>
                      <listitem>
                          <para>
                            Adds a new body header or modifies the contents of the
                            existing body header.
                       </para>
                    </listitem>
                   </varlistentry>
                   <varlistentry>
                      <term><methodsynopsis>
                         <type>virtual void* </type>
                         <methodname>getBodyHeader</methodname>
                         <void /><modifier>const</modifier>
                      </methodsynopsis></term>
                      <listitem>
                          <para>
                            Returns a pointer to the body header or
                            <literal>nullptr</literal> if the object has no
                            body header.
                       </para>
                    </listitem>
                   </varlistentry>
                </variablelist>
            </refsect1>
        </refentry>
        <refentry>
           <refmeta>
              <refentrytitle>CRingScalerItem (v11)</refentrytitle>
              <manvolnum>3format</manvolnum>
           </refmeta>
           <refnamediv>
              <refname>CRingScalerItem (v11)</refname>
              <refpurpose>Encapsulate periodic scaler ring items.</refpurpose>
            </refnamediv>
            <refsynopsisdiv>
                <programlisting>
#include &lt;v11/CRingScalerItem.h&gt;

namespace v11 {
/*!
   This class derived from CRingItem and represents a set of scalers that have been 
   formatted as a ring item.  
*/
class CRingScalerItem : public ::CRingScalerItem
{


public:
  CRingScalerItem(size_t numScalers);
  CRingScalerItem(uint32_t startTime,
		  uint32_t stopTime,
		  time_t   timestamp,
		  std::vector&lt;uint32_t&gt; scalers,
                  bool                  isIncremental = true,
                  uint32_t              sid = 0,
                  uint32_t              timeOffsetDivisor = 1);
  CRingScalerItem(uint64_t eventTimestamp, uint32_t source, uint32_t barrier,
                  uint32_t startTime,
		  uint32_t stopTime,
		  time_t   timestamp,
		  std::vector&lt;uint32_t&gt; scalers,
                  uint32_t timeDivisor = 1, bool incremental=true);
  virtual ~CRingScalerItem();

  virtual void     setStartTime(uint32_t startTime);
  virtual uint32_t getStartTime() const;
  virtual float    computeStartTime() const;
  
  virtual void     setEndTime(uint32_t endTime);
  virtual uint32_t getEndTime() const;
  virtual float    computeEndTime() const;

  virtual uint32_t getTimeDivisor() const;

  virtual void     setTimestamp(time_t stamp);
  virtual time_t   getTimestamp() const;
  
  virtual bool isIncremental() const;

  virtual void     setScaler(uint32_t channel, uint32_t value) ;
  virtual uint32_t getScaler(uint32_t channel) const ;
  virtual std::vector&lt;uint32_t&gt; getScalers() const;

  virtual uint32_t getScalerCount() const;
  virtual uint32_t getOriginalSourceId() const;


  virtual void* getBodyPointer();
  virtual const void* getBodyPointer() const;
  virtual bool hasBodyHeader() const;
  virtual void* getBodyHeader() const;
  
  virtual void setBodyHeader(
      uint64_t timestamp, uint32_t sourceId,
      uint32_t barrierType = 0
  );
  virtual std::string typeName() const;
  virtual std::string toString() const;

};
}
                </programlisting>
            </refsynopsisdiv>
            <refsect1>
                     <title>DESCRIPTION</title>
                  <para>
                    Periodically NSCLDAQ readout frameworks can read a set of
                    counters or <firstterm>scalers</firstterm> as they are called.
                    In v11, this readout results in a ring item with the type:
                    <literal>v11::PERIODIC_SCALERS</literal>.  
                  </para>
                  <para>
                    There are two tactics that can be employed to read scaler data.
                  </para>
                  <orderedlist>
                    <listitem>
                       <para>
                          Read and clear - or <firstterm>incremental</firstterm>
                          as it's referred to.  In that scheme scalers are
                          read and cleared so that each set of scaler values represents
                          an incremental set of counts since the last read.
                       </para>
                    </listitem>
                    <listitem>
                       <para>
                          Cummulative - or <firstterm>non-incremental</firstterm>
                          as the NSCLDAQ calls it.  In that scheme the scalers
                          are allowed to free run and the analysis software
                          must deal with the wrap-arounds that may occur in
                          each channel.
                       </para>
                    </listitem>
                  </orderedlist>
                  <para>
                    While the analysis of incremental scalers is simpler, there
                    are scaler devices that cannot be atomically read and clear,
                    resulting in some time skew between the readout of the
                    first channel and readout of the last channel of a module
                    that is exacerbated somewhat by the commmon clear time
                  </para>
                  <para>
                    Specifically incremental scaler reads will lose counts that
                    occur between the read of a channel and its subsequent clear.
                    The severity of this problem depends both on the counting
                    rates (more severe at high counting rates) of the channel and
                    the precision required of the data from that channel.
                  </para>
                  <para>
                    Note that read skew still occurs for cummulative readout
                    but eventually all counts are seen since the scalers are
                    never cleared.
                  </para>
                  <para>
                    The verison 11 scaler ring items provide a flag that
                    can specify if the scaler readout was incremental or non-incremental.
                  </para>
            </refsect1>
            <refsect1>
                <title>METHODS</title>
                <variablelist>
                    <varlistentry>
                       <term><constructorsynopsis>
                           <methodname>CRingScalerItem</methodname>
                        <methodparam>
                            <type>size_t </type><parameter>numScalers</parameter>
                        </methodparam>
                       </constructorsynopsis></term>
                       <listitem>
                           <para>
                            Constructs a scaler item large enough to hold
                            <parameter>numScalers</parameter> 32 bit scaler counters.
                            The start/stop time offsets are both set to
                            <literal>0</literal> as are the scaler values.
                            The time divisor is initialized to <literal>1</literal>
                            and the clock time is set to the time at which
                            the item was constructed.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><constructorsynopsis>
                           <methodname>CRingScalerItem</methodname>
                        <methodparam>
                            <type>uint32_t </type><parameter>startTime</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint32_t </type><parameter>stopTime,</parameter>
                        </methodparam>
                        <methodparam>
                            <type>time_t   </type><parameter>timestamp</parameter>
                        </methodparam>
                        <methodparam>
                            <type>std::vector&lt;uint32_t&gt; </type><parameter>scalers,</parameter>
                        </methodparam>
                        <methodparam>
                            <type>bool </type><parameter>isIncremental</parameter>
                            <initializer>true</initializer>
                        </methodparam>
                        <methodparam>
                            <type>uint32_t </type><parameter>sid</parameter>
                            <initializer>0</initializer>
                        </methodparam>
                        <methodparam>
                            <type>uint32_t  </type><parameter>timeOffsetDivisor</parameter>
                            <initializer>1</initializer>
                        </methodparam>
                       </constructorsynopsis></term>
                       <listitem>
                           <para>
                            Fully constructs a scaler item.  The scaler values
                            are passed in via the <parameter>scalers</parameter>
                            parameter.  The size of that vector determines
                            the number of scalers the item will hold.
                           </para>
                           <para>
                            The interval start and stop offsets are given
                            by <parameter>startTime</parameter> and
                            <parameter>stopTime</parameter> respecively.
                            The optional <parameter>timeOffsetDivisor</parameter>
                            parameter provides the number of ticks in these
                            offset values per second providing support for
                            sub-second time resolution.
                           </para>
                           <para>
                            THe clock time is provided by
                            <parameter>timestamp</parameter>.
                           </para>
                           <para>
                            If <parameter>isIncremental</parameter> is false,
                            the counts are assumed to accumulate for the length
                            of the run.  Otherwise the counts in the scalers are
                            assumed to represent the counts over the interval
                            defined by <parameter>startTime</parameter>
                            through <parameter>stopTime</parameter>.
                           </para>
                           <para>
                            Beginning with the 12.0 data format, the
                            scaler bodies contain a field to retain the source id
                            of the data source the originally created the item.
                            This is important because event builders overwrite
                            the source id of scaler items.  This field is
                            initialized with the value of the
                            <parameter>sid</parameter> parameter.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void     </type>
                          <methodname>setStartTime</methodname>
                          <methodparam>
                              <type>uint32_t </type><parameter>startTime</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Sets the offset into the run at which the scaler counting
                            interval began.
        
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual uint32_t</type>
                          <methodname> getStartTime() </methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the offset into the run at which the
                            scaler counting began.  See next method, however.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual float    </type>
                          <methodname>computeStartTime</methodname>
                          <void />
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Uses the scaler interval start offset and the
                            counting divisor to compute the start time offset
                            in seconds.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void     </type>
                          <methodname>setEndTime</methodname>
                          <methodparam>
                              <type>uint32_t </type><parameter>endTime</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Sets the offset into the run of the end of the
                            scaler counting interval
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual uint32_t </type>
                          <methodname>getEndTime</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the offset into the run at which the scaler
                            counting interval ended.  See, however the next
                            method.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual float    </type>
                          <methodname>computeEndTime</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Using the end offset and the offset divisor computes
                            and returns the number of seconds into the run at
                            which the scaler counting interval ended.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual uint32_t </type>
                          <methodname>getTimeDivisor</methodname>
                          <void /> <modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the number of ticks in the start and end
                            time offsets that correspond to a second.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void     </type>
                          <methodname>setTimestamp</methodname>
                          <methodparam>
                              <type>time_t </type><parameter>stamp</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Sets the clock time associated with the item
                            to be <parameter>stamp</parameter>.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual time_t   </type>
                          <methodname>getTimestamp</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the clock time associated with the item.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual bool </type>
                          <methodname>isIncremental</methodname>
                          <void />
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            If the scalers are cleared after each read, this
                            returns <literal>true</literal>, if they are allowed
                            to accumulate across counting intervals, this returns
                            <literal>false</literal>
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void     </type>
                          <methodname>setScaler</methodname>
                          <methodparam>
                              <type>uint32_t </type><parameter>channel</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t </type><parameter>value</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Sets the counts for the scaler  selected by
                            <parameter>channel</parameter> to
                            <parameter>value</parameter>. If <parameter>channel</parameter>
                            is out of range an <classname>std::out_of_range</classname>
                            exception is thrown.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual uint32_t </type>
                          <methodname>getScaler</methodname>
                          <methodparam>
                              <type>uint32_t </type><parameter>channel</parameter>
                          </methodparam>
                          <modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returs the value of the scaler selected by
                            <parameter>channel</parameter>.  If
                            <parameter>channel</parameter> is out of range a
                            <classname>std::out_of_range</classname>
                            exception is thrown.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual std::vector&lt;uint32_t&gt; </type>
                          <methodname>getScalers</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns a vector containing the values of the scaler
                            counts in the item.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual uint32_t </type>
                          <methodname>getScalerCount</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the number of scalers in the item.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type> virtual uint32_t </type>
                          <methodname>getOriginalSourceId</methodname>
                          <void /><modifier> const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the original source id field from the item.
                            Version 11 does not support orginal source ids and therefore
                            if there's a body header the source id from the body
                            header is returned, if not <literal>0</literal>
                            is returned.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void* </type>
                          <methodname>getBodyHeader</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns a pointer to the item's body header
                            or <literal>nullptr</literal> if it does not have one.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void </type>
                          <methodname>setBodyHeader</methodname>
                          <methodparam>
                              <type>   uint64_t </type><parameter>timestamp</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t </type><parameter>sourceId</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t </type><parameter>barrierType</parameter>
                              <initializer>0</initializer>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Sets new values for the body header of the item
                            if it already has one or creates a new one if it does not.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual std::string </type>
                          <methodname>typeName</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns a string that identifies the type of the item:
                            <literal>Scaler</literal>
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual std::string </type>
                          <methodname>toString</methodname>
                          <void /> <modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns a string that details the contents of the
                            item.  This is used by e.g. <command>dumper</command>
                            to produce a formated dump of a stream of ring items.
                           </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </refsect1>
        </refentry>
        <refentry>
           <refmeta>
              <refentrytitle>CRingStateChangeItem (v11)</refentrytitle>
              <manvolnum>3format</manvolnum>
           </refmeta>
           <refnamediv>
              <refname>CRingStateChangeItem (v11)</refname>
              <refpurpose>Encapsulate state change ring items.</refpurpose>
            </refnamediv>
            <refsynopsisdiv>
                <programlisting>
#include &lt;v11/CRingStateChangeItem.h&gt;

namespace v11 {
class CRingStateChangeItem : public ::CRingStateChangeItem
{
public:
  CRingStateChangeItem(uint16_t reason = BEGIN_RUN);
  CRingStateChangeItem(uint16_t reason,
		       uint32_t runNumber,
		       uint32_t timeOffset,
		       time_t   timestamp,
		       std::string title) ;
  CRingStateChangeItem(uint64_t eventTimestamp, uint32_t sourceId, uint32_t barrierType,
                       uint16_t reason,
		       uint32_t runNumber,
		       uint32_t timeOffset,
		       time_t   timestamp,
		       std::string title,
                       uint32_t offsetDivisor = 1);

  virtual void setRunNumber(uint32_t run);
  virtual uint32_t getRunNumber() const;

  virtual void setElapsedTime(uint32_t offset);
  virtual uint32_t getElapsedTime() const;
  virtual float    computeElapsedTime() const;

  virtual void setTitle(std::string title) ;
  virtual std::string getTitle() const;

  virtual void setTimestamp(time_t stamp);
  virtual time_t getTimestamp() const;
  
  virtual uint32_t getOriginalSourceId() const;
  virtual const void*  getBodyPointer() const;
  virtual void*        getBodyPointer();
  virtual bool hasBodyHeader() const;
  virtual void* getBodyHeader() const;
  virtual void setBodyHeader(uint64_t timestamp, uint32_t sourceId,
                         uint32_t barrierType = 0);
  virtual std::string typeName() const;
  virtual std::string toString() const;

};
}

                </programlisting>
            </refsynopsisdiv>
            <refsect1>
                     <title>DESCRIPTION</title>
                  <para>
                    When a run begins, pauses, resumes or ends (normally), the
                    NSCLDAQ readout frameworks produce state change ring items
                    to document the times at which these state changes occured.
                    <classname>v11::CRingStateChangeItem</classname> is intended
                    to encapsulate these ring items for version 11.
                  </para>
                  <para>
                    Several types of state change items are supported:
                    <literal>v11::BEGIN_RUN</literal>,
                    <literal>v11::PAUSE_RUN</literal>, <literal>v11::RESUME_RUN</literal>
                    and <literal>v11::END_RUN</literal>.  Note that not all readers
                    support pausing a run and the paused state will likely be
                    deprecated and eventually phased out.
                  </para>
            </refsect1>
            <refsect1>
                <title>METHODS</title>
                <variablelist>
                    <varlistentry>
                       <term><constructorsynopsis>
                           <methodname>CRingStateChangeItem</methodname>
                        <methodparam>
                            <type>uint16_t </type><parameter>reason </parameter>
                            <initializer>BEGIN_RUN</initializer>
                        </methodparam>
                       </constructorsynopsis></term>
                       <listitem>
                           <para>
                            Creates a state change item for the specified state
                            change type.  The offset time is set to zero, which is
                            appropriate for a begin run, the clock time stamp is
                            set to the current time.  The run number is also set
                            to zero.  The title is set to an empty string.
                            Other version specific initialization may occur.
                           </para>
                           <para>
                            v11 supports body headers but
                            this constructor will create an item without a body
                            header.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><constructorsynopsis>
                           <methodname> CRingStateChangeItem</methodname>
                        <methodparam>
                            <type>uint16_t </type><parameter>reason</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint32_t </type><parameter>runNumber</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint32_t timeOffset</type><parameter></parameter>
                        </methodparam>
                        <methodparam>
                            <type>time_t   </type><parameter>timestamp</parameter>
                        </methodparam>
                        <methodparam>
                            <type>std::string </type><parameter>title</parameter>
                        </methodparam>
                       </constructorsynopsis></term>
                       <listitem>
                           <para>
                            Full construction of a state change item.  The
                            <parameter>reason</parameter> is the type of state change
                            item as listed in <literal>DESCRIPTION</literal>.
                            <parameter>runNumber</parameter> us the number of the
                            run undergoing the transition.  <parameter>timeOffset</parameter>
                            is the offset into the run at which the transition occured.
                            This should always be <literal>0</literal> for
                            <literal>BEGIN_RUN</literal> transitions.
                            
                           </para>
                           <para>
                            <parameter>timestamp</parameter> is the clock time
                            at which the transition occured.   This is the output
                            of the unix <function>time</function> function.
                           </para>
                           <para>
                            Finally, <parameter>title</parameter> is the run's title.
                            This should be the same string for all transitions
                            within a run.   Note that there is a maximum
                            length to titles defined in
                            <filename>DataFormat.h</filename> with the symble
                            <literal>TITLE_MAXSIZE</literal>. Title strings longer
                            than that should be silently truncated by the
                            version's implementation.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void </type>
                          <methodname>setRunNumber</methodname>
                          <methodparam>
                              <type>uint32_t</type><parameter> run</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Modifies the item's run number.   This is most often
                            used when the minimal constructor is used to
                            create the item.  In that case, various methods
                            are used to fill in actual values of the fields.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual uint32_t </type>
                          <methodname>getRunNumber</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Return the run number from the state change ring item
                            encapsulated in the object.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void </type>
                          <methodname>setElapsedTime</methodname>
                          <methodparam>
                              <type>uint32_t </type><parameter>offset</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Sets the raw time offset of the state change item.
                            The offset says when in the timespan of the run
                            the state change occured.  It is zero at the beginning
                            of the run.  No attempt is made to synchronize this time
                            offset between several data sources.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual uint32_t </type>
                          <methodname>getElapsedTime</methodname>
                          <void />
                          <modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the raw time offset stored in the event.  This
                            is the time offset in to the run at which the state change
                            occured. Note that the time divisor (see below) represents
                            the numbver of ticks in the offset in a second.
                           </para>
                           <para>
                            It's usually preferrable to get the offset in seconds
                            using <methodname>computeElapedTime</methodname>.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual uint32_t </type>
                          <methodname>getTimeDivisor</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the time divisor.  This value represents the
                            number of ticks of time offset in a second.
                            Note that at present, all constructors initialize
                            this to <literal>1</literal> and there is no mechanism
                            to modify the divisor.  Later releases may provide
                            such a mechanism.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual float </type>
                          <methodname>computeElapsedTime</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Computes the time offset stored in the item in
                            seconds.  This is the preferred method to get the
                            time offset in the presence of the capability
                            for divisors that are greater than 1.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void </type>
                          <methodname>setTitle</methodname>
                          <methodparam>
                              <type>std::string </type><parameter>title</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Sets the title of the run for the state transition
                            item.  The state transition items that belong to the
                            same run should have the same title.  Note that
                            there is a maximum title length and implementations
                            should silently truncate any title longer than that.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual std::string </type>
                          <methodname>getTitle</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the value of the title string for the
                            transition object.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void </type>
                          <methodname>setTimestamp</methodname>
                          <methodparam>
                              <type>time_t </type><parameter>stamp</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Sets a clock times associted with the item.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual time_t </type>
                          <methodname>getTimestamp</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Return the clock time associated with the
                            item.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                            <methodsynopsis>
                               <type>virtual uint32_t</type>
                               <methodname> getOriginalSourceId</methodname>
                               <void /><modifier>const</modifier>
                            </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Returns the original source id of the item.
                            Since v11 does not support original source ids,
                            if the item has a body header the source id in the
                            body header is returned, otherwise
                            <literal>0</literal> is returned.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void* </type>
                          <methodname>getBodyHeader</methodname>
                          <void /> <modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns a pointer to the object's body header.
                            If the object has no body header
                            <literal>nullptr</literal> is returned.  The
                            actual format of the body header
                            is described in
                            <filename>v11/DataFormat.h</filename>
                            by the <type>v11::BodyHeader</type>
                            data type.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void </type>
                          <methodname>setBodyHeader</methodname>
                          <methodparam>
                              <type>uint64_t </type><parameter>timestamp</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t </type><parameter>sourceId</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t </type><parameter>barrierType </parameter>
                              <initializer>0</initializer>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Adds, if no body header exists, or modifies an
                            existing body header in the object.  If the version
                            does not support body headers, the method should do
                            nothing.
                           </para>
                           <para>
                            Note that any body pointer or body cursor is invalidated
                            by this call if there is not already a body header to
                            modify.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual std::string </type>
                          <methodname>typeName</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns a string that identifies the type of the object.
                            Note that the type is a fine grained concept.
                            For examle, if the type is
                            <literal>BEGIN_RUN</literal>,
                            this method returns <literal>Begin Run</literal>.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual std::string</type>
                          <methodname>toString</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns a string that describes the contents of the
                            item.  This is used by e.g.
                            <command>dumper</command> to emit formatted
                            ring items.
                           </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </refsect1>
        </refentry>
        <refentry>
           <refmeta>
              <refentrytitle>CRingTextItem (v11)</refentrytitle>
              <manvolnum>3format</manvolnum>
           </refmeta>
           <refnamediv>
              <refname>CRingTextItem (v11)</refname>
              <refpurpose>Encapsulate text strings.</refpurpose>
            </refnamediv>
            <refsynopsisdiv>
                <programlisting>
#include &lt;v11/CRingTextItem.h&gt;

namespace v11 {

class CRingTextItem : public ::CRingTextItem
{
public:
  
  CRingTextItem(uint16_t type,
		std::vector&lt;std::string&gt; theStrings,
		uint32_t                 offsetTime,
		time_t                   timestamp,
    uint32_t                 divisor = 1) ;
  CRingTextItem(
    uint16_t type, uint64_t eventTimestamp, uint32_t source, uint32_t barrier,
    std::vector&lt;std::string&gt; theStrings, uint32_t offsetTime, time_t timestamp,
    int offsetDivisor = 1
  );
  std::vector&lt;std::string&gt;  getStrings() const;

  void     setTimeOffset(uint32_t offset);
  uint32_t getTimeOffset() const;
  float    computeElapsedTime() const;
  uint32_t getTimeDivisor() const;

  virtual void     setTimestamp(time_t stamp);
  virtual time_t   getTimestamp() const;
  virtual uint32_t getOriginalSourceId() const;

  
  
  // Virtual methods all ring overrides.
  
  
  virtual void* getBodyPointer();
  virtual const void* getBodyPointer() const;
  virtual bool hasBodyHeader() const;
  virtual void* getBodyHeader() const;
  virtual void setBodyHeader(
        uint64_t timestamp, uint32_t sid, uint32_t barrierType= 0
  );


  virtual std::string typeName() const;
  virtual std::string toString() const;
  
};

}                                

                </programlisting>
            </refsynopsisdiv>
            <refsect1>
                     <title>DESCRIPTION</title>
                  <para>
                    There are cases when a Readout framework needs to provide
                    some free form documentation in the form of text strings
                    placed in the data flow.  Two such cases have been identifies
                    and are captured in textual ring items.
                  </para>
                  <para>
                    <literal>v11::PACKET_TYPES</literal> contain information about
                    the format of the data one can see in physics event data.
                    The SBS readout framework allows you to  organize data into
                    packets.  A packet is sort of like a mini-ringitem.  It
                    consists of a size and a payload.  When using registered
                    packets in this framework <literal>v11::PACKET_TYPES</literal>
                    ring items will be emitted.
                  </para>
                  <para>
                    <literal>v11::MONITORED_VARIABLES</literal> describe the state
                    of selected Tcl variables in the readout program's Tcl interpreter.
                    A server plug in component supports external programs that
                    push information into these variables.  The EPICS tools
                    part of NSCLDAQ includes programs that will push the values
                    of EPICS variables into the interpreter where they can be
                    declared as monitored variables.
                  </para>
                  <para>
                    In addition to run and clock time information, and an optional
                    body header, the payload of text ring items is a set of
                    null terminated strings.  The payload contains a count field
                    which tells the consumer how many strings to expect.  This is
                    sufficient information to allow strings to be extracted from
                    the item.
                  </para>
                  <para>
                    The <classname>CRingTextItem</classname> class provides a
                    wrapper for textual ring items.
                  </para>
            </refsect1>
            <refsect1>
                <title>METHODS</title>
                <variablelist>
                    <varlistentry>
                       <term><constructorsynopsis>
                           <methodname>CRingTextItem</methodname>
                        <methodparam>
                            <type>uint16_t </type><parameter>type</parameter>
                        </methodparam>
                        <methodparam>
                            <type>size_t </type><parameter>maxsize</parameter>
                        </methodparam>
                       </constructorsynopsis></term>
                       <listitem>
                           <para>
                            Constructor.  <parameter>type</parameter> is the item
                            type and <parameter>maxsize</parameter> sets a
                            limit on the ring item size.  Note that if you
                            already know the set of strings to put in the item,
                            it's better to use a constructor that takes them
                             as a parameter as then the actual maximum size
                             can be computed.
                           </para>
                           <para>
                            The string count for the item is initialized to zero.
                            The run offset is also initialized to zero as is the
                            original source id.  The clock time is initialized to the
                            current time.
                           </para>
                           <para>
                            If you use this  constructor you will need to know
                            the structure of the underlying ring item to set the
                            item's strings.  In almost all cases, the constructors
                            that support passing string vectors as parameters
                            are preferrable.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><constructorsynopsis>
                           <methodname> CRingTextItem(</methodname>
                        <methodparam>
                            <type>uint16_t </type><parameter>type</parameter>
                        </methodparam>
                        <methodparam>
                            <type>std::vector&lt;std::string&gt; </type><parameter>theStrings</parameter>
                        </methodparam>
                       </constructorsynopsis></term>
                       <listitem>
                           <para>
                            In this constructor, <parameter>theStrings</parameter>
                            is used to compute the required item size.  The
                            strings are set into the item's string pool
                            as null terminated strings and the string count
                            is set to <literal>theStrings.size()</literal>.
                            The offset, original source id, and clock time are
                            initialized as in the previous constructor.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><constructorsynopsis>
                           <methodname>CRingTextItem</methodname>
                        <methodparam>
                            <type>uint16_t </type><parameter>type</parameter>
                        </methodparam>
                        <methodparam>
                            <type>std::vector&lt;std::string&gt;</type><parameter> theStrings</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint32_t  </type><parameter>offsetTime</parameter>
                        </methodparam>
                        <methodparam>
                            <type>time_t </type><parameter>timestamp</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint32_t </type><parameter>divisor</parameter>
                            <initializer>1</initializer>
                        </methodparam>
                       </constructorsynopsis></term>
                       <listitem>
                           <para>
                            Fully parameterized constructor.  This constructor
                            adds <parameter>offsetTime</parameter> to set the
                            time  offset in the run at which the item was emitted,
                            <parameter>timestamp</parameter> which allows the
                            clock time the item was emitted to be expclicitly
                            specified and <parameter>divisor</parameter>
                            (optional, defaults to 1) which indicates the number
                            of ticks of <parameter>offsetTime</parameter> in
                            a second.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual std::vector&lt;std::string&gt;</type>
                          <methodname> getStrings</methodname>
                          <void /><modifier> const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns a vector that contains the text strings in the
                            object's payload.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void     </type>
                          <methodname>setTimeOffset</methodname>
                          <methodparam>
                              <type>uint32_t </type><parameter>offset</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Set the offset into the run at which this object was
                            emitted.  Note that this, together with the time divisor
                            determine the number of seconds into the run the
                            object was emitted.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual uint32_t </type>
                          <methodname>getTimeOffset</methodname>
                          <void /> <modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the raw time offset. Note that calling
                            <methodname>computeElapsedTime</methodname>
                            is the perferred method to call to get the run time
                            offset in seconds.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual float</type>
                          <methodname>computeElapsedTime</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Return the elapsed time in the run at which this
                            item was emitted, in seconds.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual uint32_t </type>
                          <methodname>getTimeDivisor</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Return the number of offset ticks per second.  
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void </type>
                          <methodname>setTimestamp</methodname>
                          <methodparam>
                              <type>time_t </type><parameter>stamp</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Sets the clock time at which the item was emitted.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual time_t  </type>
                          <methodname> getTimestamp</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the clock time associated with the item.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual uint32_t </type>
                          <methodname>getOriginalSourceId</methodname>
                          <void /><modifier> const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            return the item's original source id. Note that
                            version 11 data does not have an original source id
                            field.  If the object has a body header, the source id
                            from the body header is returned, if not,
                            <literal>0</literal> is returned.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void* </type>
                          <methodname>getBodyHeader</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            If the item has a body header, this returns a pointer
                            to it.  Otherwise, <literal>nullptr</literal>
                            is returned.  Note that the structure of the body
                            header depends on the format version.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void </type>
                          <methodname>setBodyHeader</methodname>
                          <methodparam>
                              <type>uint64_t </type><parameter>timestamp</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t </type><parameter>sid</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t </type><parameter>barrierType</parameter>
                              <initializer>0</initializer>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            If the item has a body header it is modified as indicated
                            by the parameters.  IF not, one is created and filled in
                            as indicated by the parameters.  If the data format
                            does not support body headers, this method should
                            be a no-op.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type> virtual std::string </type>
                          <methodname>typeName</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns a string that identifies the item type.  This
                            will be one of <literal>Packet types</literal> or
                            <literal>Monitored Variables</literal>
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual std::string </type>
                          <methodname>toString</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns a string that describes the contents of
                            the item in human readable form.
                           </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </refsect1>
        </refentry>
        <refentry>
           <refmeta>
              <refentrytitle>CUnknownFragment (v11)</refentrytitle>
              <manvolnum>3format</manvolnum>
           </refmeta>
           <refnamediv>
              <refname>CUnknownFragment (v11)</refname>
              <refpurpose>Event buider fragments with non ringitem payloads.</refpurpose>
            </refnamediv>
            <refsynopsisdiv>
                <programlisting>
#include &lt;v11/CUnknownFragment.h&gt;

namespace v11 {

class CUnknownFragment : public ::CUnknownFragment
{
    
public:
    CUnknownFragment(uint64_t timestamp, uint32_t sourceid, uint32_t barrier,
                     uint32_t size, void* pPayload);
    virtual const void*  getBodyPointer() const;
    virtual void* getBodyPointer();
    virtual bool hasBodyHeader() const;
    virtual void* getBodyHeader() const;
    virtual void setBodyHeader(uint64_t timestamp, uint32_t sourceId,
                         uint32_t barrierType = 0) ;
    

    std::string typeName() const;
    virtual std::string toString() const;
    
};

}


                </programlisting>
            </refsynopsisdiv>
            <refsect1>
                     <title>DESCRIPTION</title>
                  <para>
                    The way to think about this item is as a
                    <classname>CRingFragmentItem</classname> whose payload
                    is not know to be a ring item itself.  It has all of the
                    same methods with all the same meanings as tha class, however
                    the item type is
                    <literal>v11::EVB_UNKNOWN_PAYLOAD</literal>.
                  </para>
                  
            </refsect1>
        </refentry>
       </section>
       <section>
        <title>NSCLDAQ Version 12 format</title>
        <para>
            NSCLDAQ version 12 introduced two format changes relative to
            NSCLDAQ version 11:  The lack of a body header is denoted differently,
            Information is provided to trace back items whose body header source
            id was rewritten by the event builder back to their original source.
        </para>
        <para>
            In NSCLDAQ-11, the ring item header is followed by either the
            size of a body header, if the item has  a body header, or zero
            if it does not.  A more consistent interpretation of the
            32 bit word following the header was adopted in version 12;
            The lack of a body header is indicated by a 32 bit word
            containing <literal>sizeof(uint32_t)</literal>.  Thus skipping
            the body header, or lack of it, is handled consistently without
            a special case check for the lack of a body header.
        </para>
        <para>
            It's important to know which readout program actually produced each
            item of data.  In version 11, e.g. scaler data had a source id in
            its body header but the event builder overwrites that to the source
            id it was told to emit (in case there is hierarchical event building).
            Many ring items in NSCLDAQ version 12 have an added original source id
            field.  The idea is that the originator can write its source id here
            as well as in the body header.
        </para>
        <para>
            The original source id can then be used to determine which producer
            actually produced the item as it is immutable through the dataflow.
        </para>
        <para>
            As with other concrete formats, the headers of the classes exported
            by this format are in a subdirectory of the includes installation
            directory.  In our case the subdirectory is <filename>v12</filename>.
            Furthermore, all classes and definitions are qualified by the
            <literal>v12</literal> namespace to prevent collision with classes
            in other format.
        </para>
        <refentry>
           <refmeta>
              <refentrytitle>RingItemFactory (v12)</refentrytitle>
              <manvolnum>3format</manvolnum>
           </refmeta>
           <refnamediv>
              <refname>RingItemFactory (v12)</refname>
              <refpurpose>Create ring items formatted for version 12.</refpurpose>
            </refnamediv>
            <refsynopsisdiv>
                <programlisting>
#include &lt;v12/RingItemFactory.h&gt;

namespace v12 {
    
class RingItemFactory : public ::RingItemFactoryBase
{
public:
    virtual ::CRingItem* makeRingItem(uint16_t type, size_t maxBody) ;
    virtual ::CRingItem* makeRingItem(uint16_t type, uint64_t timestamp, uint32_t sourceId,
            size_t maxBody, uint32_t barrierType = 0 ) ;
    virtual ::CRingItem* makeRingItem(const ::CRingItem&amp; rhs) ;
    virtual ::CRingItem* makeRingItem(const ::RingItem* pRawRing) ;


    virtual ::CRingItem* getRingItem(CRingBuffer&amp; ringbuf) ;
    virtual ::CRingItem* getRingItem(int fd) ;
    virtual ::CRingItem* getRingItem(std::istream&amp; in) ;

    virtual std::ostream&amp; putRingItem(const ::CRingItem* pItem, std::ostream&amp; out) ;
    virtual void putRingItem(const ::CRingItem* pItem, int fd) ;
    virtual void putRingItem(const ::CRingItem* pItem, CRingBuffer&amp; ringbuf) ;

    virtual ::CAbnormalEndItem* makeAbnormalEndItem() ;
    virtual ::CAbnormalEndItem* makeAbnormalEndItem(const ::CRingItem&amp; rhs) ;

    virtual ::CDataFormatItem* makeDataFormatItem() ;
    virtual ::CDataFormatItem* makeDataFormatItem(const ::CRingItem&amp; rhs) ;

    virtual ::CGlomParameters* makeGlomParameters(
        uint64_t interval, bool isBuilding, uint16_t policy
    )  ;
    virtual ::CGlomParameters* makeGlomParameters(const ::CRingItem&amp; rhs) ;

    virtual ::CPhysicsEventItem* makePhysicsEventItem(size_t maxBody) ;
    virtual ::CPhysicsEventItem* makePhysicsEventItem(
        uint64_t timestamp, uint32_t source, uint32_t barrier, size_t maxBody
    ) ;
    virtual ::CPhysicsEventItem* makePhysicsEventItem(const ::CRingItem&amp; rhs) ;

    virtual ::CRingFragmentItem* makeRingFragmentItem(
        uint64_t timestamp, uint32_t source, uint32_t payloadSize,
        const void* payload, uint32_t barrier=0
    ) ;
    virtual ::CRingFragmentItem* makeRingFragmentItem(const ::CRingItem&amp; rhs) ;


    virtual ::CRingPhysicsEventCountItem* makePhysicsEventCountItem(
        uint64_t count, uint32_t timeoffset, time_t stamp,
    int divisor=1
    ) ;
    virtual ::CRingPhysicsEventCountItem* makePhysicsEventCountItem(
        const ::CRingItem&amp; rhs
    ) ;

    virtual ::CRingScalerItem* makeScalerItem(size_t numScalers) ;
    virtual ::CRingScalerItem* makeScalerItem(
        uint32_t startTime,
        uint32_t stopTime,
        time_t   timestamp,
        std::vector&lt;uint32_t&gt; scalers,
        bool                  isIncremental = true,
        uint32_t              sid = 0,
        uint32_t              timeOffsetDivisor = 1
    ) ;
    virtual ::CRingScalerItem* makeScalerItem(const ::CRingItem&amp; rhs) ;

    virtual ::CRingTextItem* makeTextItem(
        uint16_t type,
        std::vector&lt;std::string&gt; theStrings
    ) ;
    virtual ::CRingTextItem* makeTextItem(
        uint16_t type,
        std::vector&lt;std::string&gt; theStrings,
        uint32_t                 offsetTime,
        time_t                   timestamp,
        uint32_t divisor 
    ) ;
    virtual ::CRingTextItem* makeTextItem(const ::CRingItem&amp; rhs) ;

    virtual ::CUnknownFragment* makeUnknownFragment(
        uint64_t timestamp, uint32_t sourceid, uint32_t barrier,
        uint32_t size, void* pPayload
    ) ;
    virtual ::CUnknownFragment* makeUnknownFragment(const ::CRingItem&amp; rhs) ;

    virtual ::CRingStateChangeItem* makeStateChangeItem(
        uint32_t itemType, uint32_t runNumber,
        uint32_t timeOffset,
        time_t   timestamp,
        std::string title
    ) ;
    virtual ::CRingStateChangeItem* makeStateChangeItem(const ::CRingItem&amp; rhs) ;

    
};
    
}                     // V12 namespace.


                </programlisting>
            </refsynopsisdiv>
            <refsect1>
                     <title>DESCRIPTION</title>
                  <para>
                    This class produces ring item objects formatted for
                    NSCLDAQ-12.  All returned items are pointers to dynamically
                    allocated objects.  These are owned by the caller who must
                    ensure they are deleted when no longer needed.
                  </para>
                  <para>
                    You can prevent or reduce the changes of memory leakage
                    by using the return values to initialize standard library
                    smart pointer objects such as
                    <classname>std::unique_ptr</classname> or
                    <classname>std::shared_ptr/</classname>.
                  </para>
            </refsect1>
            <refsect1>
                <title>METHODS</title>
                <variablelist>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>::CRingItem* </type>
                          <methodname>makeRingItem</methodname>
                          <methodparam>
                              <type>uint16_t </type><parameter>type</parameter>
                          </methodparam>
                          <methodparam>
                              <type>size_t </type><parameter>maxBody</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Creates a new ring item that is undifferentiated,
                            that is it implements no type specific methods.
                            <parameter>type</parameter> is put in the ring item
                            header's type field.  Storage capacity sufficient for
                            a body of up to <parameter>maxBody</parameter>
                            bytes of data are reserved though you'll need to
                            communicate the size of the item (normally via
                            the object's <methodname>setBodyCursor</methodname>
                            and <methodname>updateSize</methodname> methods) to
                            actually fill in the header's size field.
                           </para>
                           <para>
                            The returned value is a pointer to a
                            <classname>v12::CRingItem</classname> object
                            (cast to <classname>::CRingItem</classname>).
                            The caller is responsible for deleting the object
                            when it is no longer needed (e.g. by initializing a smart
                            pointer object with it).
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>::CRingItem* </type>
                          <methodname>makeRingItem</methodname>
                          <methodparam>
                              <type>uint16_t </type><parameter>type</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint64_t </type><parameter>timestamp</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t </type><parameter>sourceId</parameter>
                          </methodparam>
                          <methodparam>
                              <type>size_t </type><parameter>maxBody</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t</type><parameter> barrierType</parameter>
                              <initializer>0</initializer>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Creates an undifferentiateded ring item that is parameterized
                            for a body header.  The ring item will be created
                            with a body header whose fields will come
                            from the <parameter>timestamp</parameter>,
                            <parameter>sourceId</parameter> and
                            optional <parameter>barrierType</parameter>
                            arguments.  <parameter>barrierType</parameter>
                            defaults to <literal>0</literal> which means no
                            barrier is triggered.
                           </para>
                           <para>
                            For a user to add a body header extension, prior to
                            any actual body data being added, requires
                            that they first use <methodname>getBodyHeader</methodname>
                            to get a pointer to the body, then
                            <methodname>getBodyCursor</methodname> to obtain
                            a pointer past the end of the body cursor add
                            the data and then adust the size field of the
                            body header.
                           </para>
                           <para>
                            For example, suppose the application is to
                            add a body header extension that will contain
                            the experiment number which is stored in the
                            constant EXPERIMENT_NUMBER:
                           </para>
                           <example>
                            <title>Adding a body header extension</title>
                            <programlisting>
std::uinque_ptr&lt;::CRingItem&gt; p(factory.makeRingItem(...)) // make ring item with body header.

v12::pBodyHeader pH = reinterpret_cast&lt;v12::pBodyHeader&gt;(p-&gt;getBodyHeader());
uint32_t* pCursor = reinterpret_cast&lt;uint32_t*&gt;(p-&gt;getBodyCursor);
*pCursor = EXPERIMENT_NUMBER;
pH->s_size += sizeof(uint32_t);
p-&gt;setBodyCursor(pCursor);      // For whomever is filling the item body.

                            </programlisting>
                           </example>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>::CRingItem* </type>
                          <methodname>makeRingItem</methodname>
                          <methodparam>
                              <type>const ::CRingItem&amp; </type><parameter>rhs</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Makes a ring item by copying the contents of another
                            ring item.  Note that the results are not well defined
                            if the <parameter>rhs</parameter> item comes from
                            a different ring item format than this factory.
                           </para>
                           <para>
                            In practice this is not a problem unless you are writing
                            a format converter.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>::CRingItem* </type>
                          <methodname>makeRingItem</methodname>
                          <methodparam>
                              <type>const RingItem* </type><parameter>pRawRing</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Wraps a raw ring item in a <classname>v12::CRingItem</classname>
                            object and returns a pointer to that object.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual CRingItem* </type>
                          <methodname>getRingItem</methodname>
                          <methodparam>
                              <type>CRingBuffer&amp;</type><parameter>ringbuf</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Reads a ring item from the ringbuffer
                            <parameter>ringbuf</parameter> and wraps it in a new
                            <type>v12::CRingItem</type>.
                           </para>
                           <para>
                            <parameter>ringbuf</parameter> must be attached to
                            the ring buffer in consumer mode.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual CRingItem* </type>
                          <methodname>getRingItem</methodname>
                          <methodparam>
                              <type>int</type><parameter> fd</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Reads a ring item from the entity open on the linux
                            file descriptor <parameter>fd</parameter> and wraps it
                            into a new <type>v12::CRingItem</type>.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual CRingItem* </type>
                          <methodname>getRingItem</methodname>
                          <methodparam>
                              <type>std::istream&amp; </type><parameter>in</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Reads a ring item from the C++ <classname>istream</classname>
                            referenced by <parameter>in</parameter> and wraps it in a
                            <classname>v12::CRingItem</classname>.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual std::ostream&amp;</type>
                          <methodname> putRingItem</methodname>
                          <methodparam>
                              <type>const CRingItem*</type><parameter> pItem</parameter>
                          </methodparam>
                          <methodparam>
                              <type>std::ostream&amp; </type><parameter>out</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Puts the wrapped ring item pointed to by <parameter>pItem</parameter>
                            in the <classname>std::ostream</classname> referenced by <parameter>out</parameter>.
                            The raw binary of the ring item is output which allows it to be read in using
                             <methodname>getRingItem</methodname> at some later date.
                           </para>
                           <para>
                            The <parameter>out</parameter> stream must be open
                            for write and in binary mode.  Note any actual ring item
                            type can be used for the <parameter>pItem</parameter>
                            since they all ultimately descend from
                            <classname>::CRingItem</classname>.
                           </para>
                           <para>
                            The method, like most C++ stream I/O methods, returns
                            a reference to <parameter>out</parameter> following the
                            put.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void </type>
                          <methodname>putRingItem</methodname>
                          <methodparam>
                              <type>const ::CRingItem*</type><parameter> pItem</parameter>
                          </methodparam>
                          <methodparam>
                              <type>int </type><parameter>fd</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Writes the ring item pointed to by
                            <parameter>pItem</parameter> to the file descriptor
                            <parameter>fd</parameter>
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void </type>
                          <methodname>putRingItem</methodname>
                          <methodparam>
                              <type>const ::CRingItem* </type><parameter>pItem</parameter>
                          </methodparam>
                          <methodparam>
                              <type>CRingBuffer&amp;</type><parameter>ringbuf</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Writes the ring item pointed to by
                            <parameter>pItem</parameter> to the ringbuffer
                            referenced by <parameter>ringbuf</parameter>.
                            <parameter>ringbuf</parameter> must be attached
                            to the ring buffer in producer mode.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type> virtual ::CAbnormalEndItem* </type>
                          <methodname>makeAbnormalEndItem</methodname>
                          <void />
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Creates a new abnormal end run item.  Abnormal
                            end run items flag event data taking that has
                            ended without a proper end run request/indication.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual ::CAbnormalEndItem* </type>
                          <methodname>makeAbnormalEndItem</methodname>
                          <methodparam>
                              <type>const CRingItem&amp;</type><parameter>rhs</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            If <parameter>rhs</parameter> references
                            an abnormal end item, this will create a new copy
                            of that item with the specific type, a pointer
                            to <classname>v12::CAbnormalEndItem</classname>.
                            If, however the type of
                            <parameter>rhs</parameter> is not
                            <literal>v12::ABNORMAL_ENDRUN</literal>
                            and the size of the ring item is not
                            <literal>sizeof(v12::AbnormalEndItem</literal>, a
                            <classname>std::bad_cast</classname>
                            exception is thrown.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual ::CDataFormatItem* </type>
                          <methodname>makeDataFormatItem</methodname>
                          <void />
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            This creates  a new data format item.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual ::CDataFormatItem* </type>
                          <methodname>makeDataFormatItem</methodname>
                          <methodparam>
                              <type>const CRingItem&amp;</type><parameter>rhs</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            If <parameter>rhs</parameter>
                            references a data format item, this method will
                            produce a duplicate item and return a pointer to it.
                            If not a <classname>std::bad_cast</classname>
                            is thrown.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual ::CGlomParameters*</type>
                          <methodname> makeGlomParameters</methodname>
                          <methodparam>
                              <type>uint64_t </type><parameter>interval</parameter>
                          </methodparam>
                          <methodparam>
                              <type>bool </type><parameter>isBuilding</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint16_t </type><parameter>policy</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Produces a pointer to a
                            <classname>v12::CGlomParameters</classname>.
                            This data type is used to encapsulate a informational
                            ring item emitted by the event builder's glom stage.
                            The ring item contains the coincidence interval:
                            <parameter>interval</parameter>,
                            The <parameter>policy</parameter> for assigning
                            timestamps to output events and a flag,
                            <parameter>isBuilding</parameter> which is true
                            if glom is actually building events and false if it
                            is just emitting single fragment events.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                          <term><methodsynopsis>
                             <type>::CGlomParameters*</type>
                             <methodname>makeGlomParameters</methodname>
                             <methodparam>
                                 <type>const ::CRingItem&amp; </type><parameter>rhs</parameter>
                             </methodparam>
                          </methodsynopsis></term>
                          <listitem>
                              <para>
                               If <parameter>rhs</parameter> is a v12
                               glom parameters ring item, duplicates it as
                               a <classname>v12::CGlomParameters</classname>
                               item and returns a  pointer to this item.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual ::CPhysicsEventItem* </type>
                          <methodname>makePhysicsEventItem</methodname>
                          <methodparam>
                              <type>size_t </type><parameter>maxBody</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Creates and returns a pointer to a physics event item
                            (<classname>v12::CPhysicsEventItem</classname>). The
                            capacity of the item will be sufficient for the item
                            to have a body of <parameter>maxBody</parameter>.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type> virtual ::CPhysicsEventItem* </type>
                          <methodname>makePhysicsEventItem</methodname>
                          <methodparam>
                              <type>uint64_t </type><parameter>timestamp</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t </type><parameter>source</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t </type><parameter>barrier</parameter>
                          </methodparam>
                          <methodparam>
                              <type>size_t </type><parameter>maxBody</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Makes a physics event with a body header filled in
                            from the additional parameters.
                            The body header timestamp is filled in from
                            <parameter>timestamp</parameter>,
                            the source id from <parameter>source</parameter>
                            and the barrier type from <parameter>barrier</parameter>.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type> virtual ::CPhysicsEventItem* </type>
                          <methodname>makePhysicsEventItem</methodname>
                          <methodparam>
                              <type>const ::CRingItem&amp;</type><parameter>rhs</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Given an undifferentiated ring item that
                            encapsulates a physics event item in <parameter>rhs</parameter>,
                            constructs an actual <classname>v12::CPhysicsEventItem</classname>
                            returning a pointer to the constructed item.
                            If the type of the item is not <literal>v12::PHYSICS_EVENT</literal>
                            a <classname>std::bad_cast</classname> exception is thrown.
                           </para>
                           <para>
                            Note that if the item is from a different version of
                            NSCLDAQ, the behavior of the resulting item
                            is not well defined.  Consider for example, if
                            <parameter>rhs</parameter> is v10 ring item,
                            That item has no word indicating it has no body
                            header and therefore, the
                            <classname>v12::CPhysicsEventItem</classname>
                            class will misinterpret the shape of the underlying
                             ring item.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual ::CRingFragmentItem* </type>
                          <methodname>makeRingFragmentItem</methodname>
                          <methodparam>
                              <type>uint64_t </type><parameter>timestamp</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t</type><parameter> source</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t </type><parameter>payloadSize</parameter>
                          </methodparam>
                          <methodparam>
                              <type>const void* </type><parameter>payload</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t</type><parameter> barrier</parameter>
                              <initializer>0</initializer>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns a ring fragment item with the timestamp,
                            source id and barrier as described by the
                            <parameter>timestamp</parameter>,
                            <parameter>source</parameter>, and
                            <parameter>barrier</parameter> parameters.
                            The payload size and contents are as in
                            <parameter>payloadSize</parameter> and
                            <parameter>payload</parameter>.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual ::CRingFragmentItem*</type>
                          <methodname> makeRingFragmentItem</methodname>
                          <methodparam>
                              <type>const ::CRingItem&amp;</type><parameter> rhs</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            If <parameter>rhs</parameter> is a ring fragment item returns a fragment
                            item that is functionally equivalent to <parameter>rhs</parameter>.
                            If <parameter>rhs</parameter> is not a fragment item,
                            throws a <classname>std::bad_cast</classname>
                            exception.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual ::CRingPhysicsEventCountItem* </type>
                          <methodname>makePhysicsEventCountItem</methodname>
                            <methodparam>
                                <type>uint64_t</type><parameter>count</parameter>
                            </methodparam>
                            <methodparam>
                                <type>uint32_t </type><parameter>timeoffset</parameter>
                            </methodparam>
                            <methodparam>
                                <type>time_t </type><parameter>stamp</parameter>
                            </methodparam>
                            <methodparam>
                                <type>int </type><parameter>divisor</parameter>
                                <initializer>1</initializer>
                            </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Makes a physics event count item in version 12 format.
                            <parameter>count</parameter> must be the number
                            of triggers handled by the readout system at
                            <parameter>timeoffset</parameter> into the run.
                            <parameter>divisor</parameter> is the number of
                            ticks of <parameter>timeoffset</parameter> in one second.
                           </para>
                           <para>
                            <parameter>stamp</parameter> is the clock time at which
                            the item is being created (should be during the run not
                            during analysis).  It can be generated by a call
                            to the unix <function>time</function> service.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual ::CRingPhysicsEventCountItem* </type>
                          <methodname>makePhysicsEventCountItem</methodname>
                          <methodparam>
                            <type>const ::CRingItem&amp; </type><parameter>rhs</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            If <parameter>rhs</parameter> is an undifferentiated
                            ring item that wraps a physics event count item,
                            this method creates a new
                            <classname>v12::CRingPhysicsEventCountItem</classname>
                            that contains the same information as
                            <parameter>rhs</parameter>.  
                           </para>
                           <para>
                            Note that if
                            <parameter>rhs</parameter> is not a
                            <literal>v12::PHYSICS_EVENT_COUNT</literal> ring
                            item, a <classname>std::bad_cast</classname>
                            exception is thrown.   The behavior of this
                            generator method is not well defined if the
                            ring item comes from another version of NSCLDAQ.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual ::CRingScalerItem* </type>
                          <methodname>makeScalerItem</methodname>
                          <methodparam>
                              <type>size_t </type><parameter>numScalers</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Create a scaler item for V12 that has storage reserved
                            for <parameter>numScalers</parameter> scalers.
                            The interval start and end time must be set
                            at a later time. The scaler storage is initialized
                            to zero and the clock time stamp is initialized to the
                            time this method is called.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual ::CRingScalerItem*</type>
                          <methodname> makeScalerItem</methodname>
                          <methodparam>
                              <type>uint32_t </type><parameter>startTime</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t</type><parameter> stopTime</parameter>
                          </methodparam>
                          <methodparam>
                              <type>time_t</type><parameter>timestamp</parameter>
                          </methodparam>
                          <methodparam>
                              <type>std::vector&lt;uint32_t&gt; </type><parameter>scalers</parameter>
                          </methodparam>
                          <methodparam>
                              <type>bool  </type><parameter>isIncremental </parameter>
                              <initializer>true</initializer>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t </type><parameter> sid </parameter>
                              <initializer>0</initializer>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t</type><parameter>timeOffsetDivisor</parameter>
                              <initializer>1</initializer>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Creates a version 12  scaler item that is fully
                            populated.  <parameter>startTime</parameter> and
                            <parameter>stopTime</parameter> along with
                            <parameter>timeOffsetDivisor</parameter> describe
                            the time interval relative to the start of the run
                            over which the scaler counted.
                            <parameter>timeOffsetdivisor</parameter> specifies
                            the number of ticks in <parameter>startTime</parameter>
                            and <parameter>stopTime</parameter> in one second.
                            If omitted, it defaults to <literal>1</literal>
                            meaning that those parameters are in units of seconds.
                           </para>
                           <para>
                             <parameter>scalers</parameter> is a vector of
                             scaler values.  THe actual meaning of these values
                             depends on the state of  the
                             <parameter>isIncremental</parameter> flag.
                             If <parameter>isIncremental</parameter> is
                             <literal>true</literal>, the scalers represent
                             additional counts over the counting interval.
                             If <literal>false</literal>, the scalers
                             represent cummulative counts since the beginning
                             of the run.
                            </para>
                           <para>
                            The item is created with a body header
                            that has a special timestamp that requests the event
                            builder assign a timestamp from the last timestamped
                            item.  The source id is <parameter>sid</parameter>
                            and barrier type <parameter>0</parameter>.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual ::CRingScalerItem* </type>
                          <methodname>makeScalerItem</methodname>
                          <methodparam>
                              <type>const CRingItem&amp;</type><parameter> rhs</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            If <parameter>rhs</parameter> is a scaler item
                            a new <classname>v12::CRingScalerItem</classname> is
                            made from the data in <parameter>rhs</parameter>.
                            If <parameter>rhs</parameter> is not of type
                            <literal>v12::PERIODIC_SCALERS</literal>
                            a <classname>std::bad_cast</classname> exception
                            is thrown.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual CRingTextItem* </type>
                          <methodname>makeTextItem</methodname>
                          <methodparam>
                              <type>uint16_t </type><parameter>type</parameter>
                          </methodparam>
                          <methodparam>
                              <type>std::vector&lt;std::string&gt; </type><parameter>theStrings</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Creates an item that contains text strings.
                            <parameter>type</parameter> is the ring item
                            type and must be one of <literal>v12::PACKET_TYPES</literal>
                            or <literal>v12::MONITORED_VARIABLES</literal>.
                            The strings themselves are taken from the vector
                            <parameter>theStrings</parameter>.
                           </para>
                           <para>
                            The clock time is filled in from the time at which this
                            method is called and the run time offset is
                            initialized to <literal>0</literal>
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual CRingTextItem* </type>
                          <methodname>makeTextItem</methodname>
                          <methodparam>
                              <type>uint16_t </type><parameter>type</parameter>
                          </methodparam>
                          <methodparam>
                              <type>std::vector&lt;std::string&gt;</type><parameter> theStrings</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t   </type><parameter>offsetTime</parameter>
                          </methodparam>
                          <methodparam>
                              <type>time_t  </type><parameter>timestamp</parameter>
                          </methodparam>
                            <methodparam>
                            <type>uint32_t </type><parameter>divisor</parameter>
                            <initializer>1</initializer>
                        </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Same as the previous methods however the additional
                            parameters serve to initialize other bits otf the
                            ring item: <parameter>offsetTime</parameter>  and
                            <parameter>divisor</parameter> describe the offset into
                            the run at which the item was emitted.  The
                            <parameter>divisor</parameter> parameter provides
                            the number of <parameter>offsetTime</parameter> ticks
                             in a second.  If omitted it defaults to
                             <literal>1</literal> which means that
                             <parameter>offsetTime</parameter> is in units of
                             seconds.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual CRingTextItem*</type>
                          <methodname> makeTextItem</methodname>
                          <methodparam>
                              <type>const CRingItem&amp;</type><parameter> rhs</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Given an undifferentiated ring item; <parameter>rhs</parameter>
                            that encpasulates a valid text item creats a new
                            <classname>v12::CRingTextItem</classname> from the
                            data in <parameter>rhs</parameter>.  If the item is not
                             a valid v12 text item,
                             a <classname>std::bad_cast</classname>
                             exception is thrown.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual CUnknownFragment* </type>
                          <methodname>makeUnknownFragment</methodname>
                          <methodparam>
                              <type>uint64_t </type><parameter>timestamp</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t </type><parameter>sourceid</parameter>
                          </methodparam>
                          <methodparam>
                            <type>uint32_t </type><parameter>barrier</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t </type><parameter>size</parameter>
                          </methodparam>
                          <methodparam>
                              <type>void*</type><parameter> pPayload</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                            
                           <para>
                            Generates and returns a pointer to a
                            <classname>v12::CUnknownFragment</classname>
                            object.   The parameters provided are used to
                            initialize the object data:
                            <parameter>timestamp</parameter>, <parameter>sourceid</parameter>
                            and <parameter>barrier</parameter> provide the
                            header information.
                            <parameter>size</parameter> is the number of bytes
                            of payload pointed to by <parameter>pPayload</parameter>
                            that will be copied into the body of the item.
                           </para>
                           <para>
                            Note that <classname>CUnknownFragment</classname>
                            objects are <classname>CRingFragmentItem</classname>
                            objects with a type of <literal>v12::EVB_UNKNOWN_PAYLOAD</literal>
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual CUnknownFragment* </type>
                          <methodname>makeUnknownFragment</methodname>
                          <methodparam>
                              <type>const CRingItem&amp;</type><parameter>rhs</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            If <parameter>rhs</parameter> is an unknown fragment,
                            produces a copy of it and wraps that in a
                            <classname>v12::CUnknownFragment</classname>
                            object returing a pointer to the resulting object.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual CRingStateChangeItem* </type>
                          <methodname>makeStateChangeItem</methodname>
                          <methodparam>
                              <type>uint32_t </type><parameter>itemType</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t </type><parameter>runNumber</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t</type><parameter> timeOffset</parameter>
                          </methodparam>
                          <methodparam>
                              <type>time_t </type><parameter>timestamp</parameter>
                          </methodparam>
                          <methodparam>
                              <type>std::string </type><parameter>title</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Creates a new run state change item formatted for
                            version 12.  The <parameter>itemType</parameter>
                            defines the new run state and must be one of
                            <literal>v12::BEGIN_RUN</literal>,
                            <literal>v12::PAUSE_RUN</literal>,
                            <literal>v12::RESUME_RUN</literal>,
                            or <literal>v12::END_RUN</literal>.  If it is none of those,
                            a <classname>std::bad_cast</classname> exception is
                            thrown.
                           </para>
                           <para>
                            The remaining parameters define parameters of the run:
                            <parameter>runNumber</parameter> is the unique number
                            of the run.  <parameter>timeOffset</parameter> is
                            the offset into the run at which the state change
                            occurerd.  This must be in units of seconds.
                            <parameter>timestamp</parameter> is the clock time
                            at which the state transition happened.
                            Finally, <parameter>title</parameter> is the
                            title string associated with the run. 
                           </para>
                           <para>
                            Note that
                            all state change items associated with the same
                            run should have the same title and run number.
                            This is not enforced.  The <parameter>timeOffset</parameter>
                            for a <literal>v12::BEGIN_RUN</literal> item should
                            always be <literal>0</literal>, but this too is not
                            enforced.  Finally, the <parameter>timestamp</parameter>
                            parameter can be the output of a call to the
                            unix <function>time</function> function.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual CRingStateChangeItem* </type>
                          <methodname>makeStateChangeItem</methodname>
                          <methodparam>
                              <type>const CRingItem&amp;</type><parameter> rhs</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            If <parameter>rhs</parameter> is an undifferentiated
                            ring item that encapsualtes a valid v11 run state
                            transition ring object, a new
                            <classname>v12::CRingStateChangeItem</classname>
                            is created encapsulating the same information.
                            If <parameter>rhs</parameter> is not a valid
                            v12 run state transition item,
                            a <classname>std::bad_cast</classname> exception
                            is thrown.
                           </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </refsect1>
        </refentry>
        <refentry>
           <refmeta>
              <refentrytitle>CRingItem (v12)</refentrytitle>
              <manvolnum>3format</manvolnum>
           </refmeta>
           <refnamediv>
              <refname>CRingItem (v12)</refname>
              <refpurpose>Encapsulate V12 undifferentiated ring item</refpurpose>
            </refnamediv>
            <refsynopsisdiv>
                <programlisting>
#include &lt;v12/CRingItem.h&gt;

namespace v12 {

class CRingItem : public ::CRingItem
{

public:
  CRingItem(
      uint16_t type,
      size_t maxBody = CRingItemStaticBufferSize - 10
  );
  CRingItem(uint16_t type, uint64_t timestamp, uint32_t sourceId,
            uint32_t barrierType = 0, size_t maxBody = CRingItemStaticBufferSize - 10);
  
  virtual size_t getBodySize()    const;
  virtual const void*  getBodyPointer() const;
  virtual void*  getBodyPointer();

  virtual bool mustSwap() const;
  virtual bool hasBodyHeader() const;
  virtual void* getBodyHeader() const;
  virtual uint64_t getEventTimestamp() const;
  virtual uint32_t getSourceId() const;
  virtual uint32_t getBarrierType() const;
  virtual void setBodyHeader(uint64_t timestamp, uint32_t sourceId,
                     uint32_t barrierType = 0);

  
  virtual std::string typeName() const;	// Textual type of item.
  virtual std::string toString() const; // Provide string dump of the item.


  
};
} 


                </programlisting>
            </refsynopsisdiv>
            <refsect1>
                     <title>DESCRIPTION</title>
                  <para>
                    Encapsulates an undifferentiate v12 ring item. Note that
                    there's a bit of dirt used in implementing the other ring
                    item classes because they need to derive from their
                    abstract versions and that puts them out of the class
                    hierearchy in which <classname>v12::CRingItem</classname>
                    lives.
                  </para>
                  <para>
                    Doing double inheritance in other classes to this and the abstract
                    items results in the diamond of death
                    (see the wikipedia article on multiple inheritence at
                    <ulink url='https://en.wikipedia.org/wiki/Multiple_inheritance#The_diamond_problem' />
                    ).  However <classname>v12::CRingItem</classname> supplies
                    valuable methods to access the underlying data that we may want to
                    use in other classes.
                  </para>
                  <para>
                    The dirt is to do casts and then explicitly override
                    the virtual function calls as needed.  If, for example
                    a v12 class wants to determine if its encapsulated data
                    has a body header this code fragment serves as a pattern
                    that can be applied to other accessors if you are designing
                    your own data encapsulation classes:
                  </para>
                  <informalexample>
                    <programlisting>
v12::CRingItem* pThis = reinterpret_cast&lt;v12::CRingItem*&gt;(this);
if (pThis-&gt;v12::CRingItem::hasBodyHeader()) {
...
}
                    </programlisting>
                  </informalexample>
                  <para>
                    The correctness of this code relies on the fact that:
                  </para>
                  <orderedlist>
                    <listitem>
                       <para>
                          <classname>v12::CRingItem</classname>
                          itself does derive from <classname>::CRingItem</classname>.
                       </para>
                    </listitem>
                    <listitem>
                       <para>
                          The encapsulated data are in v12 format and therefor when
                          accessed by <classname>v12::CRingItem</classname> in the
                          code fragment above, the correct results will be returned.
                       </para>
                    </listitem>
                  </orderedlist>
                  <para>
                    This is not for the faint at heart.
                  </para>
            </refsect1>
            <refsect1>
                <title>METHODS</title>
                <variablelist>
                    <varlistentry>
                       <term>
                        <constructorsynopsis>
                            <methodname>CRingItem</methodname>
                            <methodparam>
                                <type>uint16_t</type><parameter>type</parameter>
                            </methodparam>
                            <methodparam>
                                <type>size_t </type><parameter>maxBody</parameter>
                                <initializer>CRingItemStaticBufferSize - 10</initializer>
                            </methodparam>
                        </constructorsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Constructor.  <parameter>type</parameter> will be stored
                            in the ring item header's type field.  Note that
                            the header form is common for all formats.
                            The <parameter>type</parameter> is 16 bit wide because in
                            the original design it was also used to determine the
                            byte order of the originator.  Specifically, if the
                            'low order' 16 bits of a type field were zero, the
                            byte order of the originator was the opposite of the
                            consumer.  Now that little-endianess has won the
                            byte order wars and big-endinaness only appears
                            vestigially in network byte ordering,  We define
                            the byte ordering of Ring items to be little-endian.
                           </para>
                           <para>
                            <parameter>maxBody</parameter> determines the maximum
                            number of bytes the internal storage for the ring item
                            can hold in the body (the part following the header).
                            Note that the design of <classname>CRingItem</classname>
                            includes a decently sized static block of data.
                            If this value indicates the data will fit in that
                            block, no dynamic memory allocation is required and
                            that block is used.  If this value indicates that
                            the data won't fit, a block is dynamically allocated
                            and used.  The intent is to minimize the costly
                            set of dynamic memory allocations/deallocations
                            needed if all <classname>CRingItem</classname>
                            constructions dynamically allocated the needed
                            data.
                           </para>
                           <para>
                            The default value for <parameter>maxBody</parameter>
                            allows callers to use the static buffer and is
                            defined in <filename>CRingItem.h</filename>.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <constructorsynopsis>
                            <methodname>CRingItem</methodname>
                            <methodparam>
                                <type>v11::pRingItem </type><parameter>pItem</parameter>
                            </methodparam>
                        </constructorsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Wraps a <classname>CRingItem</classname> object
                            around a raw ring item.  The type
                            <type>pRingItem</type> is defined in
                            <filename>DataFormat.h</filename>.
                           </para>
                           <para>
                            <parameter>pItem</parameter> is used to size
                            the ring item and copied into the data storage
                            region of the item.  The body cursor is set to point
                            after the ring item data.  This allows the
                            item to be mutated (via <methodname>getBodyPointer</methodname>)
                            and to be extended (via <methodname>getBodyCursor</methodname>,
                            <methodname>setBodyCursor</methodname>, and <methodname>updateSize</methodname>).
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual size_t </type>
                           <methodname>getStorageSize</methodname>
                           <void />
                           <modifier>const</modifier>
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Returns the capacity of the block of data that is being used
                            to store the ring item.   Can be used to determine
                            if sufficient storage has been allocated to
                            hold the desired ring item.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual size_t </type>
                           <methodname>getBodySize</methodname>
                           <void />
                           <modifier>const</modifier>
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Returns the current size, in bytes,
                            of the ring item body.
                            This computes the number of bytes between the
                            pointers returned by
                            <methodname>getBodyCursor</methodname> and the
                            <methodname>geBodyPointer</methodname>.  For it to be
                            accurate, <methodname>getBodyCursor</methodname>
                            must be updated (via <methodname>setBodyCursor</methodname>)
                            to point past the body of the ring item as it is
                            so far.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual const void*  </type>
                           <methodname>getBodyPointer</methodname>
                           <void /><modifier>const</modifier>
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Returns a pointer to the body of the item. Since
                            the pointer is const, this is intended to allow
                            read access.  Note that the concept of a ring item
                            <firstterm>body</firstterm> is not that straightforward.
                            V11 support returns either a pointer after the items' body
                            header or after the word that indcates there
                            is no body header -- that is a pointer to the payload
                            section of the ring item data.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type> virtual void* </type>
                           <methodname>getBodyPointer</methodname>
                           <void />
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Same as above except that the pointer can be used
                            to modify the body contents.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>void*  </type>
                          <methodname>getBodyCursor</methodname>
                          <void />
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the body cursor of the item. When a ring item
                            is created, a pointer, called the body cursor is
                            created which points to the first free byte of memory
                            into which data can be appended to the ring item.
                            As data are appended to the ring item, the
                            object's body cursor should be updated with
                            <methodname>setBodyCursor</methodname>, at some point,
                            when the ring item has been completely built,
                            <methodname>updateSize</methodname> should be called
                            to compute the ring item's size and store it in the
                            size field of the ring item's header.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>pRingItem  </type>
                          <methodname>getItemPointer</methodname>
                          <void />
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns a pointer to the ring item as encapsulated
                            by this class.  Note that <type>pRingItem</type>
                            is defined in <filename>v11/DataFormat.h</filename>.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>const RingItem*  </type>
                          <methodname>getItemPointer</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Same as above but the pointer only allows read access
                            to the contents of the ring item.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>uint32_t </type>
                          <methodname>type</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the full 32 bit type field of the
                            ring item.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>uint32_t </type>
                          <methodname>size</methodname>
                          <void /> <modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the size field of the header. Note that unless
                            <methodname>updateSize</methodname> has been called,
                            this value is not a reliable measure of the number
                            of bytes that make up the ring item.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual bool </type>
                          <methodname>mustSwap</methodname>
                          <void /> <modifier> const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns <literal>false</literal>.  All data is
                            now specified be little endian as are all computing
                            systems processing that data.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual bool </type>
                          <methodname>hasBodyHeader</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns <literal>true</literal> if the ring item
                            has a body header.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void* </type>
                          <methodname>getBodyHeader</methodname>
                          <void /> <modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns a pointer to the body header of the item
                            if it has one.  If it does not returns a
                            <literal>nullptr</literal>. 
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual uint64_t </type>
                           <methodname>getEventTimestamp</methodname>
                           <void /> <modifier>const</modifier>
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Returns the event/fragment timestamp stored
                            in the body header of the ring item.  If the ring
                            item has no body header,
                            <classname>std::logic_error</classname> is thrown.
                            You can use e.g. <methodname>hasBodyHeader</methodname>
                            to test for the presence of a body header in the
                            item.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual uint32_t </type>
                          <methodname>getSourceId</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Retrieves the source id from the ring item's body header.
                            If the ring item does not have a body header,
                            <classname>std::logic_error</classname> is throw
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual uint32_t </type>
                          <methodname>getBarrierType</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the barrier type field from the item's
                            body header.   If the ring item does not have a body
                            header, <classname>std::logic_error</classname>
                            is thrown.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                          <type>virtual void </type>
                          <methodname>setBodyHeader</methodname>
                          <methodparam>
                              <type>uint64_t </type><parameter>timestamp</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t </type><parameter>sourceId</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t </type><parameter>barrierType</parameter>
                              <initializer>0</initializer>
                          </methodparam>
                       </methodsynopsis>
                       
                       </term>
                       <listitem>
                           <para>
                            If the item does not have a body header (yet),
                            data are moved to reserve space for it just following
                            the ring item header.  The body header is filled
                            in with data from the parameters
                            <parameter>timestamp</parameter>,
                            <parameter>sourceId</parameter> and
                            <parameter>barrierType</parameter>
                           </para>
                           <para>
                            If the item already has a body header, its contents
                            are modified in accordance with the parameters.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void </type>
                          <methodname>setBodyCursor</methodname>
                          <methodparam>
                              <type>void* </type><parameter>pNewCursor</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Updates the internal body cursor of the object
                            with <parameter>pNewCursor</parameter>.  If coupled
                            with a call to <methodname>updateSize</methodname>,
                            this causes the size field of the ring item header
                            to be computed and updated.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void</type>
                          <methodname>updateSize</methodname>
                          <void />
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Treating the current body cursor value as a pointer
                            to the byte following the current contents of the
                            ring item, the size of the ring item is computed
                            and stored in the size field of the ring item
                            header.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual std::string </type>
                          <methodname>typeName</methodname>
                          <void /> <modifier>() const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            The base class returns the string:
                            <literal>Unknown</literal> followed by the parenthesized
                            numeric
                            type from the ring item header in hexadecimal.
                            Derived classes are
                            expected to return a text string which indicates the
                            type of the ring item. 
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual std::string </type>
                          <methodname>toString</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns a human readable stringified dump
                            of the body of the item.  In this case this is just
                            a byte by byte dump.  Derived classes are expected
                            to return something a bit more meaningful.  The
                            NSCLDAQ dumper, e.g. uses this string to
                            dump items it encounters.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void* </type>
                          <methodname>appendBodyData</methodname>
                          <methodparam>
                              <type>const void* </type><parameter>pSrc</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t </type><parameter>nBytes
                              </parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Appends the <parameter>nBytes</parameter> bytes
                            of data pointed to by <parameter>pSrc</parameter>
                            to the ring item.  The data are placed where
                            the current body cursor is pointing.  The body cursor
                            is updated and the size recomputed.
                           </para>
                           <para>
                            This is equivalent to the following code fragment:
                           </para>
                           <informalexample>
                            <programlisting>
  uint8_t* p = reinterpret_cast&lt;uint8_t*&gt;(getBodyCursor());
  memcpy(p, pSrc, nBytes);
  p += nBytes;
  setBodyCursor(p);
  updateSize();
  return p;

                            </programlisting>
                           </informalexample>
                           <para>
                            The ring item object must have the capacity for the
                            additional bytes of data.
                           </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </refsect1>
        </refentry>
        <refentry>
           <refmeta>
              <refentrytitle>CAbnormalEndItem (v12)</refentrytitle>
              <manvolnum>3format</manvolnum>
           </refmeta>
           <refnamediv>
              <refname>CAbnormalEndItem (v12)</refname>
              <refpurpose>Encapsulate abnormal end run item.</refpurpose>
            </refnamediv>
            <refsynopsisdiv>
                <programlisting>
#include &lt;CAbnormalEndItem.h&gt;

namespace v12 {
class CAbnormalEndItem : public ::CAbnormalEndItem
{
    CAbnormalEndItem();
    virtual void* getBodyHeader() const;
    virtual void  setBodyHeader(uint64_t timestamp, uint32_t sourceId,
                         uint32_t barrierType = 0);

    virtual std::string typeName() const;
    virtual std::string toString() const;
};

}

                </programlisting>
            </refsynopsisdiv>
            <refsect1>
                     <title>DESCRIPTION</title>
                  <para>
                    Abnormal end runs are sent through the data flow to indicate
                    that a readout failed and that the run must be ended in an
                    incorrect manner.  The item itself only consists of a ring
                    item header (defined in <filename>v12/DataFormat.h</filename>),
                    and a uint32_t containing <literal>sizeof(uint32_t)</literal>
                    indicating there is no body header in the item.
                  </para>
            </refsect1>
            <refsect1>
                <title>METHODS</title>
                <variablelist>
                    <varlistentry>
                       <term><constructorsynopsis>
                           <methodname>CAbnormalEndItem</methodname>
                        <void />
                       </constructorsynopsis></term>
                       <listitem>
                           <para>
                            Constructs the item.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void* </type>
                          <methodname>getBodyHeader</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns <literal>nullptr</literal>
                            since these items don't have body headers.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void  </type>
                          <methodname>setBodyHeader</methodname>
                          <methodparam>
                              <type>uint64_t </type><parameter>timestamp</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t </type><parameter>sourceId</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t </type><parameter>barrierType</parameter>
                              <initializer>0</initializer>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Since the <classname>CAbnormalEndItem</classname>
                            never has a body header, this is a no-op.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual std::string </type>
                          <methodname>typeName</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the string
                            <literal>Abnormal End</literal>
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual std::string </type>
                          <methodname>toString</methodname>
                          <void /> <modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the string
                            <literal>Abnormal End\n</literal> where the
                            <literal>\n</literal> should be interpreted to mean
                            a new line.
                           </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </refsect1>
        </refentry>
        <refentry>
           <refmeta>
              <refentrytitle>CDataFormatItem (v12)</refentrytitle>
              <manvolnum>3format</manvolnum>
           </refmeta>
           <refnamediv>
              <refname>CDataFormatItem (v12)</refname>
              <refpurpose>Document the version of NSCLDAQ format that follows</refpurpose>
            </refnamediv>
            <refsynopsisdiv>
                <programlisting>
#include &lt;v12/CDataFormatItem.h&gt;
namespace v12 {
class CDataFormatItem : public ::CDataFormatItem
{
    // Canonical methods:
public:
    CDataFormatItem();
    
    virtual uint16_t getMajor() const;
    virtual uint16_t getMinor() const;

    virtual std::string typeName() const;
    virtual std::string toString() const;
    
    virtual void* getBodyHeader() const;
    virtual void setBodyHeader(uint64_t timestamp, uint32_t sourceId,
                         uint32_t barrierType = 0);
    
    
};
}                                // v12 namespace

                    </programlisting>
            </refsynopsisdiv>
            <refsect1>
                     <title>DESCRIPTION</title>
                  <para>
                    Data format items are emitted by data generators to document
                    the format of data they are inserting into the event stream.
                    These ring items are relatively minimal, having a header,
                    a uint32_t containing <literal>sizeof(uint32_t)</literal>
                    and a pair of uint16_t's containing the major and minor
                    versions of the version.
                  </para>
                  <para>
                    In practice, the minor version is unimportant
                 </para>
            </refsect1>
            <refsect1>
                <title>METHODS</title>
                <variablelist>
                   <varlistentry>
                      <term><constructorsynopsis>
                          <methodname>CDataFormatItem</methodname>
                        <void />
                      </constructorsynopsis></term>
                      <listitem>
                          <para>
                            The constructor fills in the item with the
                            major and minor vesions that define the data
                            format.
                       </para>
                    </listitem>
                   </varlistentry>
                   <varlistentry>
                      <term><methodsynopsis>
                         <type>virtual uint16_t </type>
                         <methodname>getMajor </methodname>
                         <void /><modifier>const</modifier>
                      </methodsynopsis></term>
                      <listitem>
                          <para>
                            Returns the major version of the data format.  In
                            practice, this is sufficient to establish the data
                            format.
                       </para>
                    </listitem>
                   </varlistentry>
                   <varlistentry>
                      <term><methodsynopsis>
                         <type>virtual uint16_t </type>
                         <methodname>getMinor</methodname>
                         <void /><modifier>const</modifier>
                      </methodsynopsis></term>
                      <listitem>
                          <para>
                            Returns the minor version of the data format.  In practice
                            this is seldom necessary.
                       </para>
                    </listitem>
                   </varlistentry>
                   <varlistentry>
                      <term><methodsynopsis>
                         <type>virtual std::string </type>
                         <methodname>typeName</methodname>
                         <void /><modifier>const</modifier>
                      </methodsynopsis></term>
                      <listitem>
                          <para>
                            Return the string:
                            <literal>Ring Item format version</literal>
                       </para>
                    </listitem>
                   </varlistentry>
                   <varlistentry>
                      <term><methodsynopsis>
                         <type>virtual std::string </type>
                         <methodname>toString</methodname>
                         <void /> <modifier>const</modifier>
                      </methodsynopsis></term>
                      <listitem>
                          <para>
                            Returns a human readable string that describes the
                            contents of the ring item.
                       </para>
                    </listitem>
                   </varlistentry>
                   <varlistentry>
                      <term><methodsynopsis>
                         <type>virtual void* </type>
                         <methodname>getBodyHeader</methodname>
                         <void /><modifier>const</modifier>
                      </methodsynopsis></term>
                      <listitem>
                          <para>
                            Returns <literal>nullptr</literal> since these items
                            never have a body header.
                       </para>
                    </listitem>
                   </varlistentry>
                   <varlistentry>
                      <term><methodsynopsis>
                         <type>virtual void </type>
                         <methodname>setBodyHeader</methodname>
                         <methodparam>
                             <type>uint64_t </type><parameter>timestamp</parameter>
                         </methodparam>
                         <methodparam>
                             <type>uint32_t </type><parameter>sourceId</parameter>
                         </methodparam>
                         <methodparam>
                             <type>uint32_t </type><parameter>barrierType </parameter>
                             <initializer>0</initializer>
                         </methodparam>
                      </methodsynopsis></term>
                      <listitem>
                          <para>
                            No-op since these items don't have body headers.
                       </para>
                    </listitem>
                   </varlistentry>                    
                </variablelist>
            </refsect1>
        </refentry>
        <refentry>
           <refmeta>
              <refentrytitle>CGLomParameters (v12)</refentrytitle>
              <manvolnum>3format</manvolnum>
           </refmeta>
           <refnamediv>
              <refname>CGLomParameters (v12)</refname>
              <refpurpose>Document event builder parameters.</refpurpose>
            </refnamediv>
            <refsynopsisdiv>
                <programlisting>
#include &lt;v12/CGlomParameters.h&gt;

namespace v12 {


class CGlomParameters : public ::CGlomParameters
{
    
    // Canonicals:
    
public:
    CGlomParameters(uint64_t interval, bool isBuilding, TimestampPolicy policy);
   virtual uint64_t coincidenceTicks() const;
   virtual bool     isBuilding() const;
   virtual TimestampPolicy timestampPolicy() const;
   virtual std::string typeName() const;
   virtual std::string toString() const;
   virtual void* getBodyHeader() const;
   virtual void setBodyHeader(uint64_t timestamp, uint32_t sourceId,
                         uint32_t barrierType = 0);

};


}                   // v12 namespac.

                </programlisting>
            </refsynopsisdiv>
            <refsect1>
                     <title>DESCRIPTION</title>
                  <para>
                    <classname>v12::CGlomParameters</classname>
                    items are written by the glom stage of the event builder
                    pipeline.  They describe the parameters glom is using to
                    buid events from the ordered stream of fragments it receives
                    on <literal>stdin</literal>.
                  </para>
                  <para>
                    Three parameters determine how glom operates:
                  </para>
                  <variablelist>
                    <varlistentry>
                       <term>build flag</term>
                       <listitem>
                           <para>
                            If true (normal) glom builds events, if not,
                            then for diagnostic purposes, glom creates events
                            out of single fragments.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>coincidence interval</term>
                       <listitem>
                           <para>
                            If the build flag is set, this is the number
                            of timestamp ticks that define a n event.
                            Glom operates by accepting a 'first fragment' to begin
                            an event and then accepting additional fragments until
                            the timestamp differnence with the first fragment is
                            greater than the coincidence interval.  At that point
                            the accumulated fragments constitute and event and that
                            fragment becomes a new first fragment for the next event.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>timestamp policy.</term>
                       <listitem>
                           <para>
                            Determines how the timestamp for output events are determined
                            from the fragments that make up the event.  There are
                            three policies:  earliest - timestamps are taken from
                            the first fragment's timestamp, latest - timetamps are
                            taken from the last fragment's timestamps, and
                            average - the output timestamp is the average of all
                            timestamps in the fragment.
                           </para>
                        </listitem>
                    </varlistentry>
                  </variablelist>
            </refsect1>
            <refsect1>
                <title>METHODS</title>
                <variablelist>
                    <varlistentry>
                       <term><constructorsynopsis>
                           <methodname>CGlomParameters</methodname>
                        <methodparam>
                            <type>uint64_t </type><parameter>interval</parameter>
                        </methodparam>
                        <methodparam>
                            <type>bool </type><parameter>isBuilding</parameter>
                        </methodparam>
                        <methodparam>
                            <type>TimestampPolicy </type><parameter>policy</parameter>
                        </methodparam>
                       </constructorsynopsis></term>
                       <listitem>
                           <para>
                            Fully parameterized construction.  <parameter>interval</parameter>
                            is the coincidence interval used to build events from
                            the sorted fragments.  If <parameter>isBuilding</parameter>
                            is false, the output stream is just a stream of single
                            fragment events, regardless of the coincidence interval.
                            This is intended for use in testing only.
                            <parameter>>policy</parameter> is the policy used to derive
                            timestamps of the output event stream from the
                            fragments that compose them.
                            See <literal>DATA TYPES and CONSTANTS</literal>
                            for valid values and their meanings.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual uint64_t </type>
                          <methodname>coincidenceTicks</methodname>
                          <void /> <modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the coincidence interval stored in the object.
                            The units of this value are timestamp ticks.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual bool     </type>
                          <methodname>isBuilding</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the state of the object's building flag.
                            If true, the data are event built. If not the
                            event builder was run in a test mode where
                            each event output consists of a single fragment.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual TimestampPolicy </type>
                          <methodname>timestampPolicy</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the timestamp policy used to derive the
                            timestamp of output events.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual std::string </type>
                          <methodname>typeName</methodname>
                          <void /> <modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns a string that identifies the ring item type:
                            <literal>Glom Parameters</literal>.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual std::string </type>
                          <methodname>toString</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns a stringified representation of the object.
                            Intended for use in e.g. <command>dumper</command>.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void* </type>
                          <methodname>getBodyHeader</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns a pointer to the object's body header.
                            Since glom parameter items dont, at present,
                            have body headers, expect a
                            <literal>nullptr</literal> to be returned.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void </type>
                          <methodname>setBodyHeader</methodname>
                          <methodparam>
                              <type>uint64_t </type><parameter>timestamp</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t sourceId</type><parameter></parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t </type><parameter>barrierType</parameter>
                              <initializer>0</initializer>
                          </methodparam>
                       </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Sets/adds a body header to the item.  Since
                            glom parameter items don't have a body header,
                            this is a no-op.
                           </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </refsect1>
            <refsect1>
                <title>DATA TYPES and CONSTANTS</title>
                <para>
                    The <classname>CGlomParameters</classname> class provides
                    a single data type:  <type>TimestampPolicy</type>.  THe
                    event builder in NSCLDAQ supports hierarchical event building.
                    This means that the output of an event builder can be input
                    for a subsequent event builder in the data acquisition
                    data flow.
                </para>
                <para>
                    This allows detector systems which require an event builder
                    of their own to be run together with other detector systems
                    by simply providing a second level event builder to glue together
                    events from each detector subsystem into coincident events.
                </para>
                <para>
                    This ability for hierarchical event building requires that
                    output events are also given a timestamp.  The
                    <type>TimestampPolicy</type> data type provides a type that
                    specifies how this output timestamp is determined.  It
                    can have the following values:
                </para>
                <variablelist>
                    <varlistentry>
                       <term><literal>first</literal></term>
                       <listitem>
                           <para>
                            The output timestamp is taken from the earliest (first)
                            fragment's timestamp.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><literal>last</literal></term>
                       <listitem>
                           <para>
                            The output timestamp is taken from the latest (last)
                            fragment's timestamp.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><literal>average</literal></term>
                       <listitem>
                           <para>
                            The output time stamp is the average of all timestamps
                            of the fragments that make up the event.
                           </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </refsect1>
        </refentry>
        <refentry>
           <refmeta>
              <refentrytitle>CPhysicsEventItem  (v12)</refentrytitle>
              <manvolnum>3format</manvolnum>
           </refmeta>
           <refnamediv>
              <refname>CPhysicsEventItem  (v12)</refname>
              <refpurpose>Encapsulate physics event data.</refpurpose>
            </refnamediv>
            <refsynopsisdiv>
                <programlisting>
#include &lt;v12/CPhysicsEventItem&gt;

namespace v12 {



class CPhysicsEventItem : public ::CPhysicsEventItem
{
public:
    CPhysicsEventItem(size_t maxBody=8192);
    CPhysicsEventItem(uint64_t ts, uint32_t sid, uint32_t barrierType, size_t maxBody=8192);
    virtual ~CPhysicsEventItem();
  
    virtual std::string typeName() const;	// Textual type of item.
    virtual std::string toString() const; // Provide string dump of the item.
    
    size_t        getBodySize() const;
    virtual void* getBodyPointer();
    virtual const void* getBodyPointer() const;
    virtual bool  hasBodyHeader() const;
    virtual void* getBodyHeader() const;
    virtual void setBodyHeader(
        uint64_t tstamp, uint32_t sourceId, uint32_t barrierType
    );
    virtual uint64_t getEventTimestamp() const;
    virtual uint32_t getSourceId() const;
    virtual uint32_t getBarrierType() const;
 
  
};

}
                </programlisting>
            </refsynopsisdiv>
            <refsect1>
                     <title>DESCRIPTION</title>
                  <para>
                    This class contains the data taken in response to a trigger.
                    We leave the concept of trigger delibrarately vague.
                    The format of the body of the item is not defined as it
                    is completely application dependent. 
                  </para>
                  <para>
                    Normally, one wil instantiate an object in response to a trigger.
                    <methodname>getBodyCursor</methodname> is then used to determine
                    Where data can be stored.  After the data are stored
                    <methodname>setBodyCursor</methodname> should be updated
                    to reflect the new insertion position.
                    <methodname>updateSize</methodname> is then called to
                    set the size of the ring item in the ring item header.
                  </para>
                  <para>
                    <classname>CPhysicsEventItem</classname> objects may or may not
                    have body headers.  However if event bulidng is done;
                    the body header should be set either at construction time or
                    via a call to <methodname>setBodyHeader</methodname>.
                    </para>
            </refsect1>
            <refsect1>
                <title>METHODS</title>
                <variablelist>
                    <varlistentry>
                       <term><constructorsynopsis>
                           <methodname>CPhysicsEventItem</methodname>
                        <methodparam>
                            <type>size_t </type><parameter>maxBody</parameter>
                            <initializer>8192</initializer>
                        </methodparam>
                       </constructorsynopsis></term>
                       <listitem>
                           <para>
                            Constructs an item for a single physics trigger.
                            Note that the storage size is statically allocated
                            with <parameter>maxBody</parameter> bytes of payload
                            data.  The ring item header type field is initialized
                            to <literal>PHYSICS_EVENT</literal>.
                           </para>
                           <para>
                            Upon creating the item, if a body header
                            is required, <methodname>setBodyHeader</methodname>
                            is invoked.  <methodname>getBodyCursor</methodname>
                            is then used get a pointer into the object at where
                            the physics data should be put.  After incrementing
                            this pointer by an appopriate amount,
                            calls to <methodname>setBodyCursor</methodname>,
                            folowed by <methodname>updateSize</methodname>
                            are required to set the size field of the
                            ring item header.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual std::string </type>
                          <methodname>typeName</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns a string that represents the ring item type:
                            <literal>Event</literal>
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual std::string </type>
                          <methodname>toString</methodname>
                          <void /> <modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns a string that represents the contents of the
                            event.  This is used, e.g., by the
                            <command>dumper</command> command to render human
                            readable data.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void*</type>
                          <methodname>getBodyHeader</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns a pointer to the body header for the event.
                            If the event has no body header,
                            <literal>nullptr</literal> is returned. Note that
                            the base class <methodname>hasBodyHeader</methodname>
                            can be called to determine if the ring item type has
                            a body header.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void </type>
                          <methodname>setBodyHeader</methodname>
                          <methodparam>
                              <type>uint64_t </type><parameter>timestamp</parameter>
                          </methodparam>
                          <methodparam>
                              <type> uint32_t </type><parameter>sourceId</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t </type><parameter>barrierType </parameter>
                              <initializer>0</initializer>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Inserts a new or modifies an existing body header of the event.
                           </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </refsect1>
        </refentry>
        <refentry>
           <refmeta>
              <refentrytitle>CRingFragmentItem (v12)</refentrytitle>
              <manvolnum>3format</manvolnum>
           </refmeta>
           <refnamediv>
              <refname>CRingFragmentItem (v12)</refname>
              <refpurpose>Encapsulate an event builder fragment.</refpurpose>
            </refnamediv>
            <refsynopsisdiv>
                <programlisting>
#include &lt;v12/CRingFragmentItem.h&gt;

namespace v12 {
class CRingFragmentItem : public ::CRingFragmentItem
{
public:
  CRingFragmentItem(uint64_t timestamp, 
		    uint32_t source, 
		    uint32_t payloadSize, 
		    const void* pBody,
		    uint32_t barrier=0);
  virtual ~CRingFragmentItem();
  virtual uint64_t     timestamp() const;
  virtual uint32_t     source() const;
  virtual size_t       payloadSize();
  virtual void*        payloadPointer();
  virtual uint32_t     barrierType() const;

  virtual std::string typeName() const;
  virtual std::string toString() const;
  
  virtual size_t getBodySize()    const;
  virtual const void*  getBodyPointer() const;
  virtual void*  getBodyPointer();

  virtual bool hasBodyHeader() const;
  virtual void setBodyHeader(uint64_t timestamp, uint32_t sourceId,
                         uint32_t barrierType = 0) ;

  virtual void* getBodyHeader() const;
  virtual uint64_t getEventTimestamp() const;
  virtual uint32_t getSourceId() const;
  virtual uint32_t getBarrierType() const;

};

}


                </programlisting>
            </refsynopsisdiv>
            <refsect1>
                     <title>DESCRIPTION</title>
                  <para>
                    The full NSCLDAQ event builder is broken into two major
                    section.  The <firstterm>orderer</firstterm> takes
                    event fragments from an arbitrary number of sources and
                    emits them in a totally time ordered stream.  The
                    <firstterm>glom</firstterm> program then glues together
                    those physics fragments that occur within a user supplied trigger
                    interval into events.
                  </para>
                  <para>
                    For diagnostic purposes a seldom used program <firstterm>teering</firstterm>
                    can be fit between the orderer and glom.  teering takes the stream
                    of fragments the orderer produces, outputs them to glom and
                    also wraps them in ring items (the stream of event fragments
                    are not ring items) and places those into a ringbuffer
                    where they can be used for diagnostics of the orderer
                    itself.
                  </para>
                  <para>
                    The ring items created are called event builder fragment
                    items and have the type <literal>v11::EVB_FRAGMENT</literal>.
                    The <classname>v11::CRingFragmentItem</classname> can encapsulate
                    these items when the fragment payoad is a ring item.
                    This is a rarely, if ever, used class/object.
                  </para>
            </refsect1>
        
            <refsect1>
                    <title>METHODS</title>
                    <variablelist>
                        <varlistentry>
                           <term><constructorsynopsis>
                               <methodname>CRingFragmentItem</methodname>
                            <methodparam>
                                <type>uint64_t </type><parameter>timestamp</parameter>
                            </methodparam>
                            <methodparam>
                                <type>uint32_t </type><parameter>source</parameter>
                            </methodparam>
                            <methodparam>
                                <type>uint32_t </type><parameter>payloadSize</parameter>
                            </methodparam>
                            <methodparam>
                                <type>const void* </type><parameter>pBody</parameter>
                            </methodparam>
                            <methodparam>
                                <type>uint32_t </type><parameter>barrier</parameter>
                                <initializer>0</initializer>
                            </methodparam>
                           </constructorsynopsis></term>
                           <listitem>
                               <para>
                                Constructs the item.  The <parameter>timestamp</parameter>,
                                <parameter>sourcde</parameter> and optional
                                <parameter>barrier</parameter> parameters fill in
                                the body header.  The default value of 0
                                for the <parameter>barrier</parameter> represents a
                                non-barrier event.
                               </para>
                               <para>
                                The payload of the fragment is <parameter>payloadSize</parameter>
                                bytes taken from the data pointed to by <parameter>pBody</parameter>.
                               </para>
                               <para>
                                For this item, type, <parameter>pBody</parameter>
                                is expected to point to an event builder fragment
                                that contains a ring item  Note that it is possible,
                                though it has not yet been done, for the orderer
                                to operate on Non-NSCLDAQ data (non ring items),
                                see <classname>CUnknonwnFragment</classname>.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>virtual uint64_t     </type>
                              <methodname>timestamp</methodname>
                              <void /><modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Returns the timestamp from the item's body header.
                                Note that by definition, fragment items have
                                a body header.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>virtual uint32_t     </type>
                              <methodname>source</methodname>
                              <void /><modifier> const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Returns the source id from the item's body header.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>virtual size_t  </type>
                              <methodname>payloadSize</methodname>
                              <void /><modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Returns the size of the payload. Note that it is
                                acceptable, and normal for this to be computed by the
                                implementation from the ring item size and the body
                                header size
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>virtual void*        </type>
                              <methodname>payloadPointer</methodname>
                              <void />
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Returns a pointer to the payload data.  The pointer
                                allows the data to be edited as well as simply
                                inspected.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>virtual uint32_t     </type>
                              <methodname>barrierType</methodname>
                              <void />
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Returns the item's body header barrier type field.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>virtual std::string </type>
                              <methodname>typeName</methodname>
                              <void /><modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Returns a string that describes the type of the
                                ring item: <literal>Event fragment</literal>
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>virtual std::string </type>
                              <methodname>toString</methodname>
                              <void /><modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Returns a string representation of the  contents of
                                the ring item. This is used e.g. by
                                <command>dumper</command>
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>virtual void </type>
                              <methodname>setBodyHeader</methodname>
                              <methodparam>
                                  <type>uint64_t </type><parameter>timestamp</parameter>
                              </methodparam>
                              <methodparam>
                                  <type>uint32_t </type><parameter>sourceId</parameter>
                              </methodparam>
                              <methodparam>
                                  <type>uint32_t </type><parameter>barrierType </parameter>
                                  <initializer>0</initializer>
                              </methodparam>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Modifies the contents of the item's body header
                                (this type always has  a body header).
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>virtual void* </type>
                              <methodname>getBodyHeader</methodname>
                              <void /><modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Returns a pointer to the object's body header.
                                Note that the actual shape of the body header
                                depends on the actual data format version.  
                                The <filename>v12/DataFormat.h</filename> header
                                describes the body header to expect from v12
                                data in its definition of the
                                <type>v12::BodyHeader</type> type.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><methodsynopsis>
                              <type>virtual bool</type>
                              <methodname> hasBodyHeader</methodname>
                              <void /><modifier>const</modifier>
                           </methodsynopsis></term>
                           <listitem>
                               <para>
                                Returns <literal>true</literal> as this type of ring item
                                always has a body header.
                               </para>
                           </listitem>
                        </varlistentry>
                    </variablelist>
                </refsect1>
            </refentry>
       </section>
       
    </chapter>
</book>