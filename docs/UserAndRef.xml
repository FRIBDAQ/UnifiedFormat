<?xml version="1.0" encoding="UTF-8"?>


<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN"
                      "file:///usr/share/xml/docbook/schema/dtd/4.5/docbookx.dtd
"
>
<book>
    <bookinfo>
      <title>NSCLDAQ Unified Format Library</title>
      <author><firstname>Ron</firstname><surname>Fox</surname></author>
      <revhistory>
          <revision>
             <revnumber>1.0</revnumber>
             <date>June 6, 2022</date>
             <authorinitials>RF</authorinitials>
             <revremark>Original Release</revremark>
          </revision>
      </revhistory>
    </bookinfo>
    <chapter>
       <title>Introduction</title>
       <section>
        <title>Motivation</title>
        <para>
         Data in the NSCLDAQ system are distributed online through ring buffers.
         While a ring buffer, at its lowest level, is just a stream of bytes
         produced by a producer and consumed by zero or more consumers,
         in practice, a structure is layered on top of this byte stream.
        </para>
        <para>
         Items are placed by producers as Ring Items.  A Ring Item consists of
         a header and a payload.  The header contains the complete size of the item
         and an item type.  As NSCLDAQ has evolved, so too have the formats
         of the payloads for various item types.  This makes writing programs
         that can process data from all versions of NSCLDAQ difficult to
         write correctly.
        </para>
        <para>
         This document describes a set of libraries which should ease this burden,
         and allow you to very simply write programs that can operate on data
         from any of the NSCLDAQ data formats.
        </para>
       </section>

       <section>
        <title>Document Organization</title>
        <para>
            The remainder of this document is organized as follows:
        </para>
        <itemizedlist>
            <listitem>
               <para>
                   The remainder of this chapter,
                   describes what you need to do to incorporate this library
                   into your program (compilation and link directives).
               </para>
            </listitem>
            <listitem>
               <para>
                  <link linkend='ch.organization' endterm='ch.organization.title' />
                  Describes the organization of the library.
               </para>
            </listitem>
            <listitem>
               <para>
                  <link linkend='ch.factories' endterm='ch.factories.title' />
                  Describes the abstract factory design pattern and how it's applied
                  to this library.
               </para>
            </listitem>
            <listitem>
               <para>
                  <link linkend='ch.reference' endterm='ch.reference.title' />
                  Provides detailed reference pages.
               </para>
            </listitem>
        </itemizedlist>
        <section>
            <title>Incorporating this library into your programs</title>
            <para>
                As with most Linux library installations, there are
                <filename>include</filename> and <filename>lib</filename> directories
                under the installation directory.  If <literal>$INSTALL_ROOT</literal>
                is the top level installation directory, at compilation time you'll
                need to add
            </para>
            <informalexample>
                <programlisting>
-I$INSTALL_ROOT/include
                </programlisting>
            </informalexample>
            <para>
                to your compilation flags so that header files can be located
                by the compiler's preprocessor.  Note that there are several
                subdirectories below this top level header directory, however
                you <emphasis>should not</emphasis> add those to the header
                file search path.
            </para>
            <para>
                The software consists of several libraries.  These must
                be added to the link and, since the libraries are shared,
                an rpath directive must be added so that the run time
                loader can locate those libraries when programs using them
                start.  
            </para>
            <para>
                This means adding the following flags to the link command:
            </para>
            <informalexample>
                <programlisting>
-L$INSTALL_ROOT/lib -lNSCLDAQFormat \
    -lV10Format -lV11Format -lV12Format -lAbstractFormat \
    -Wl,-rpath=$INSTALL_ROOT/lib
                </programlisting>
            </informalexample>
        </section>
       </section>
    </chapter>
    <chapter id='ch.organization'>
       <title id='ch.organization.title'>Library Organization</title>
       <para>
        This chapter describes the organization of the libraries.  
       </para>
       <para>
        The first question a user might reasonbly ask is how a library can hide
        the format differences between the versions of NSCLDAQ from a program.
        This can be done mostly by understanding that each version layers on additional
        fields and capabilities on the base of fields and capabilities supplied by
        the prior version.  For example V11 adds the ability to have a body header
        used in event building to the V10 format.  V12, makes a slight change to
        the value that indicates there is no body header and provides the ability to
        track the original source id of objects whose body headers are otherwise
        overwritten during event building.
       </para>
       <para>
        The format libary:
       </para>
       <orderedlist>
        <listitem>
           <para>
              Provides a set of classes that is derived from a base class that
              completely hides the actual layout of each item, only providing
              constructors and accessors to retrieve/set fields in the underlying
              data of each object.
           </para>
           <para>
            Where capabilities dont' yet exist, the library either hands off
            reasonable defaults or throws exceptions.
           </para>
        </listitem>
        <listitem>
           <para>
              Provides a set of object factories, one for each supported
              NSCLDAQ version to generate objects either from parameterization,
              undifferentiated items or from sources of data (e.g. ringbuffers,
              file descriptors or c++ streams).  The factories also provide support
              for serializing objects to these entities.
           </para>
        </listitem>
        <listitem>
           <para>
              Given information about the version of NSCLDAQ used (either an
              explicit version number or a data format item, the library can
              provide an instance of the appropriate factory.
           </para>
        </listitem>
       </orderedlist>
       <para>
        In this way a program is not looking at the actual data but simply getting or
        setting properties of the data based on an interface that can accomodate
        the maximal capabilities of a ring item over all versions.
       </para>
       <para>
        The next sections describe and give examples of
       </para>
       <itemizedlist>
        <listitem>
           <para>
              <link linkend='sec.ringitems' endterm='sec.ringitems.title' />
              The ring item classes which encapsulate the data from each ring item
              type.
           </para>
        </listitem>
        <listitem>
           <para>
              <link linkend='sec.factories' endterm='sec.factories.title' />
              The factory classes see, however
              <link linkend='ch.factories' endterm='ch.factories.title' /> for more.
              
           </para>
        </listitem>
       </itemizedlist>
       <section id='sec.ringitems'>
        <title id='sec.ringitems.title'>Ring Item classes.</title>
        <para>
         Ring item contents are hidden from users behind a family of classes.
         A set of base classes, abstract ring items define a interfaces for each
         type of ring item. For each supported version of NSCLDAQ a set of subclasses
         exists that actually provide those interfaces for that specific data format.
         In the next section we'll see how we can then use the factory classes
         and factory selector to produce items without knowing the detailed format
         of those items.
        </para>
        <para>
            The headers for the abstract ring items types are located in
            the <filename>include</filename> subdirectory of the library's
            installation directory root.  Subdirectories named
            <literal>v</literal><emphasis>nn</emphasis> where <emphasis>nn</emphasis>
            is the NSCLDAQ version number host the headers for specific NSCLDAQ
            versions.  For example  <filename>include/v11</filename> holds
            the headers for version 11.  
        </para>
        <para>
            Since each of the version dependent headers will reference the
            abstract headers, it's important to only add the top level include
            directory to the header search path.  Here's a code fragment
            that shows how to create and fill in a physics data item
            with event builder information for version 11 (note that in
            practice you'll do this using a ring item factory as described
            in the next section).
        </para>
        <example>
            <title>Generating a Physics item for NSCLDAQ-11</title>
            <programlisting>
#include &lt;v11/CPhysicsEventItem.h&gt;     <co id='v11phys.header' />
...
v11::CPhysicsEventItem item;                      <co id='v11phys.create' />
item.setBodyHeader(someTimestamp, someSourceId); <co id='v11phys.setbodyheader' />
uint16_t* pBody = reinterpret_cast&lt;uint16_t*&gt;(item.getBodyCursor); <co id='v11phys.getcursor' />
...
item.setBodyCursor(pBody);                   <co id='v11phys.updatecursor' />
item.updateSize();                           <co id='v11phys.setsize' />
...

            </programlisting>
        </example>
        <calloutlist>
            <callout arearefs='v11phys.header' >
                <para>
                    Note how we explicitly pull in the header from the v11
                    subdirectory of the header directory tree for the library.
                    This header will, in turn, refer to the header in the
                    top level directory, which supplies the base interface.
                </para>
            </callout>
            <callout arearefs='v11phys.create' >
                <para>
                    After some code that's not relevant, a V11 Physics item is
                    created.  Note that each subclass family lives in a namespace
                    that indicates its version.  The parameter-less constructor
                    just reservers a default amount of storage (about 8192 bytes),
                    and reserves the ring item header filling in the type field
                    with <literal>v11::PHYSICS_EVENT</literal>.  An optional parameter
                    can be used to reserve additional storage if needed.
                </para>
                <para>
                    We'll still need to fill in the header's size field as we'll
                    see later on.
                </para>
            </callout>
            <callout arearefs='v11phys.setbodyheader' >
                <para>
                    Event builder data is in the item's body header which contains
                    a timestamp, sourceid and barrier type.  The
                    <methodname>setBodyHeader</methodname> sets the body header
                    of the item, if necessary sliding down any existing body data
                    to accomodate it.  The barrier type argumetn of
                    <methodname>setBodyHeader</methodname> defaults to
                    <literal>0</literal> which implies the event is not an
                    event builder barrier.
                </para>
            </callout>
            <callout arearefs='v11phys.getcursor' >
                <para>
                    Ring items have a <firstterm>body cursor</firstterm>. This is
                    the location at which additional body data can be stored. The
                    <methodname>getBodyCursor</methodname> method retrieves a
                    <type>void*</type> pointer to this storage in a format
                    independent manner.  This provides us a pointer which we
                    can use to fill in the data from the physics trigger.
                </para>
                <para>
                    Note that the code in the section marked <literal>...</literal>
                    below is assumed to fill in the physics data and advance
                    the <varname>pBody</varname> pointer to point past the
                    body data we put in.
                </para>
            </callout>
            <callout arearefs='v11phys.updatecursor' >
                <para>
                    Sets the item's body cursor this does two things:
                    First it allows several distinct sections of code to fill
                    in the body of an item without knowing what other sections
                    of code did.  Each section just asks for the current body
                    cursor, fills in its chunk of data and updates the body cursor
                    for the next chunk.  More importantly, however, the body
                    cursor tells the item's encapsulating object the extent of the
                    object's storage.
                </para>
            </callout>
            <callout arearefs='v11phys.setsize' >
                <para>
                    Uses the objects current body cursor to compute the size
                    of the object and stores that in the item's header.
                    The physics item is now completely filled in.  Later sections
                    will describe what we do with that item.
                </para>
            </callout>
        </calloutlist>
       </section>
        <section id='sec.factories' >
            <title id='sec.factories.title'>Factories.</title>
            <para>
                Factories are classes that create instances of other classes.
                Abstract factories are a family (inheritance hierarchy) of factory
                classes, where each factory instance createst instances of classes
                from parallel class hierarchies.  
            </para>
            <para>
                I Know the previous paragraph might sound a bit confusing.  Let's
                describe this in the concrete terms of how factories and the
                abstract factory pattern fit into this library:
            </para>
            <itemizedlist>
                <listitem>
                   <para>
                      We have a base class factory with an interface that describes
                      various ways to create different types of ring items.
                   </para>
                </listitem>
                <listitem>
                   <para>
                      For each supported version of NSCLDAQ we have a factory
                      which knows how to instantiate objects from the class
                      hierarchy that implement its own ring item data formats.
                   </para>
                </listitem>
                <listitem>
                   <para>
                      Finally, and this is slightly different from the classic
                      abstract factory pattern, we have a factory factory which,
                      given information about the version of NSCLDAQ being used
                      (either an explicit version number or, in the case of
                      versions 11 and higher a data format item), can give us an
                      instance of the correct factory to use for that version of NSCLDAQ.
                      <footnote>
                        <para>
                            Our use of the abstract factory pattern differs from the
                            classic presentation in that in the classic presentation,
                            there's a factory that makes use of specific factories for
                            the desired concrete set of objects.
                        </para>
                        <para>
                            For more on the abstract factory pattern as it is normally used,
                            see e.g.
                            <ulink url='https://en.wikipedia.org/wiki/Abstract_factory_pattern'>
                                this Wikipedia article.
                            </ulink>
                        </para>
                    </footnote>
                   </para>
                   <para>
                    Since all factories provide the same interface as the factory
                    base class, once we've selected the factory we're going to use,
                    we don't need to know anything about the NSCLDAQ version.
                    The same interface will be used for all versions to produce
                    ring item objects which support the same interface across
                    all versions.
                   </para>
                </listitem>
            </itemizedlist>
            <para>
                Before continuing with the next chapter, which describes abstract
                factories in detail, let's look at a simple example of using
                a concrete factory to build a physics
                item, as we did in the previous section:
            </para>
            <example>
                <title>Using Factories to Make a Physics Item for NSCLDAQ-11</title>
                <programlisting>
#include &lt;v11/RingItemFactory.h&gt;    <co id='v11fact.include' />
#include &lt;CPhysicsEventItem.h&gt;      <co id='v11fact.physics' />
#include &lt;memory&gt;                   <co id='v11fact.memory' />
...

v11::RingItemFactory fact;               <co id='v11fact.instance' />
std::unique_ptr&lt;::CPhysicsEventItem&gt; pItem(fact.makePhysicsEventItem()); <co id='v11fact.make' />

pItem-&gt;setBodyHeader(someTimestamp, someSourceId); 
uint16_t* pBody = reinterpret_cast&lt;uint16_t*&gt;(pItem-&gt;getBodyCursor); 
...
pItem-&gt;setBodyCursor(pBody);                   
pItem-&gt;updateSize();                          
...
            </programlisting>
            </example>
            <calloutlist>
                <callout arearefs='v11fact.include' >
                    <para>
                        In this example, we will, directly create a V11
                        ring item factory.  Therefore we need the header
                        for that class.  In the next chapter we'll seee how to
                        select an appropriate ring item factory if we only know the
                        correct version at run-time.
                    </para>
                </callout>
                <callout arearefs='v11fact.physics' >
                    <para>
                        Note that we include the header for the abstract
                        <classname>CPhysicsEventItem</classname>.  This is what
                        factories create.  This is the base class for the version specific
                        classes such as <classname>v11::CPhysicsEventItem</classname>.
                    </para>
                    <para>
                        We choose this class so that, once we've instantiated the
                        physics item using the appropriate factory, we no longer need
                        to know the version of NSCLDAQ we're operating with.
                    </para>
                </callout>
                <callout arearefs='v11fact.memory' >
                    <para>
                        This header, part of the C++ standard library, supplies, among other
                        things, smart pointer classes which can help avoid memory leaks.
                        Our factory classes produce dynamically allocated items.
                        Using e.g. <classname>std::unique_ptr</classname> can ensure
                        these objects are deleted.
                    </para>
                </callout>
                <callout arearefs='v11fact.instance' >
                    <para>
                        This line of code creates an instance of the
                        object factory for NSCLDAQ-11.  Since we use virtual
                        methods to support a polymorphic base class/subclass
                        class hierarchy, we need to have an object as virtual methods
                        cannot be static.
                    </para>
                </callout>
                <callout arearefs='v11fact.make' >
                    <para>
                        This line is a bit involved.  Let's look at it from the
                        inside out.  We ask the <varname>fact</varname>
                        object to create a new physics event item.  Since it is
                        an instance of a <classname>v11::RingItemFactory</classname>,
                        what well get is a pointer to a <classname>v11::CPhysicsEventItem</classname>
                        object returned as a pointer to its base class
                        <classname>::CPhysicsEventItem</classname>.
                    </para>
                    <para>
                        We use this to initialize a
                        <classname>std::unique_ptr&lt;::CPhysicsEventItem&gt;</classname>
                        object named <varname>pItem</varname>.  Once the unique
                        pointer is created it can be used exactly as if it were
                        a <classname>::CPhysicsEventItem*</classname>.  When we call methods
                        using this pointer like object, due to polymorphism the
                        NSCLDAQ-11 version of those methods will get called.
                    </para>
                    <para>
                        Once <varname>pItem</varname> goes out of scope, the item
                        it 'points to' will be deleted.  This includes going out
                        of scope due to an unhandled exception.
                    </para>
                    <para>
                        Once <varname>pItem</varname> is created it can be used
                        to fill in the body header and body of the item just as
                        we did in the example in the previous section.  The result,
                        since we used the V11 factory is a V11 Physics event item.
                    </para>
                    <para>
                        Note that the code which fills in the item, which may be
                        very far  from the code which selects the factory, does not
                        need to know that we are making items for NSCLDAQ-11.
                    </para>
                    <para>
                        You might wonder about the call to set the body header.  What
                        would happen if we'd chosen the <classname>v10::RingItemFactory</classname>
                        for our factory?  NSCLDAQ-10 items don't have body headers.
                        The implementation of <methodname>setBodyHeader</methodname>
                        for NSCLDAQ-10 item types is just a no-op which means that you
                        would wind up with a perfectly good NSCLDAQ-10 ring item.
                    </para>
                </callout>
            </calloutlist>
        </section>
    </chapter>
    <chapter id='ch.factories'>
       <title id='ch.factories.title'>Factories and the Abstract Factory Pattern</title>
       <para>
        In the last section of the previous chapter, we touched on the role factories
        play in the formatting library.  We'll look a bit deeper at the subject of
        abstract factories, factories and and important set of functions
        that allow you to select an appropriate factory at run time.
       </para>
       <para>
        We've seen that in the format library:
       </para>
       <itemizedlist>
        <listitem>
           <para>
              There is a factory base class that establishes the interfaces
              that version specific factories must implement.  This is an
              abstract base class called <classname>RingItemFactoryBase</classname>.
           </para>
        </listitem>
        <listitem>
           <para>
              Each supported format version has a concrete instance of this
              factory.  Normally these are called
              <classname>v<replaceable>nn</replaceable>::RingItemFactory</classname>
              where <replaceable>nn</replaceable> is the NSCLDAQ version for which
              that factory creates items (e.g. <classname>v11::RingItemFactory</classname>
              makes ring items for NSCLDAQ-11).
           </para>
           <para>
            Each factory implements the base class interface. This means that
            once you have a pointer or reference to a factory in your possession, you
            can treat it as a generic <classname>RingItemFactoryBase</classname>
            object and polymorphism will take care of the rest without your
            code needing to be aware of the actual factory you are using.
           </para>
        </listitem>
       </itemizedlist>
       <para>
        In addition to these concepts, the format factory implements a set of
        functions that can be used to get a reference to an
        <emphasis>appropriate</emphasis> factory object.  This can be done either
        by passing a version designator or  passing a <classname>::CDataFormat</classname>
        object by reference.  In NSCLDAQ-11 and later, these objects contain
        information about the version of NSCLDAQ that produced them.  In an event
        file or stream of online events, these indicate the format of the data
        to follow.
       </para>
       <para>
        In the next example, we'll produce the same physics event item we've been
        producing in our earlier examples but we'll select the factory at runtime
        using a version designator.  In the example, the version designator is
        hard coded but could be computationally determined (e.g. passed into the
        program form the command line)
       </para>
       <example>
        <title>Using a Version Designator to Construct a Ring Item Factory:</title>
        <programlisting>
#include &lt;NSCLDAQFormatFactorySelector.h&gt;
#include &lt;RingItemFactoryBase.h&gt;    <co id='select.headers' />
#include &lt;CPhysicsEventItem.h&gt;
#include &lt;memory&gt;
..

::RingItemFactoryBase&amp; fact(FormatSelector::selectFactory(FormatSelector::v11)); <co id='select.select' />
std::unique_ptr&lt;::CPhysicsEventItem&gt; pItem(fact.makePhysicsEventItem());  <co id='select.makeitem' />
                                                                  <co id='select.fillbody' />
pItem-&gt;setBodyHeader(someTimestamp, someSourceId); 
uint16_t* pBody = reinterpret_cast&lt;uint16_t*&gt;(pItem-&gt;getBodyCursor); 
...
pItem-&gt;setBodyCursor(pBody);                   
pItem-&gt;updateSize();                          
...

        </programlisting>
       </example>
       <calloutlist>
        <callout arearefs='select.headers' >
            <para>
                Includes the headers we need. Note that none of them are
                version specific.  This is the value aded by using the
                factory selector defined in
                <filename>NSCLDAQFormatFactorySelector.h</filename>.
                <filename>RingItemFactoryBase.h</filename> defines the abstract
                base class that establishes the factory API.
            </para>
        </callout>
        <callout arearefs='select.select' >
            <para>
                This call has a lot to unwrap.  Again let's start from the
                inside and work our way out.  <methodname>FormatSelector::selectFactory</methodname>
                is a family of functions that return references to factory objects.
                This version is parameterized by an explicit version designator
                <literal>FormatSelector::v11</literal> (version 11).
            </para>
            <para>
                The selection functions maintain a memory of the factories they've
                produced.  If, in a later section of code you ask for a factory
                for the same version; you'll get a reference to the same factory
                object.  This implies that the selection subsystem maintains ownership
                of the factories it produces and your code must not delete factories
                it receives.
            </para>
            <para>
                The resulting reference is used to initialize a reference to a
                <classname>::RingItemFactoryBase</classname> object.  Using a reference
                maintains the association between virtual functions and the
                implementations provided by the factory returned from
                <methodname>FormatSelector::selectFactory</methodname>.
                This calling methods on this reference will, actually, call methods on the
                <classname>v11::RingItemFactory</classname> that
                <methodname>FormatSelector::selectFactory</methodname> returned.
            </para>
        </callout>
        <callout arearefs='select.makeitem' >
            <para>
                As before, we use the factory to make a physics event item.
                The  pointer to the resulting dynamically allocated item
                initializes a <classname>std::unique_ptr</classname> so that
                the delete of that object is automatic when th smart pointer like
                object goes out of scope.
            </para>
        </callout>
        <callout arearefs='select.fillbody' >
            <para>
                The remainder of the code in this example is identical
                to the code used to fill in the physics item bodies of the
                previous examples in this document.
            </para>
        </callout>
       </calloutlist>
       <para>
        The key point in this is that the only point in time where
        we used knowledge of the DAQ version is when we called
        <methodname>FormatSelector::selectFactory</methodname>
        passing in the version format selector.
       </para>
       <para>
        Beginning with NSCLDAQ-11, prior to the begining of each run and,
        at the beginning of each event file a data format item is written which
        indicates the format of the data that follows.  There is a format selector
        item that can be passed a reference to an encapsulated data format item
        to provide the correct format factory for that format item.
       </para>
       <para>
        This does provide a bit of a chicken and egg problem...given a raw ring item,
        how do you get a data format item.  In the code that follows, we'll start
        with an undifferentiated <classname>::CRingItem</classname> and try to
        see if it represents a ring format item.  We'll then use the fact that
        we're guaranteed that ring format items look the same in all
        versions of NSCLDAQ that support them.
       </para>
       <example>
        <title>Using ring format items to select a format factory</title>
        <programlisting>
#include &lt;NSCLDAQFormatFactorySelector.h&gt;
#include &lt;RingItemFactoryBase.h&gt; 
#include &lt;CRingItem.h&gt;
#include &lt;CRingFormatItem.h&gt;    <co id='fmt.formatitem' />
#include &lt;memory&gt;
#include &lt;DataFormat.h&gt;         <co id='fmt.dataformat' />

static enum FormatSelector::SupportedVersions defaultVersion(FormatSelector::v10); <co id='fmt.defaultfmt' />
...
:RingItemFactoryBase* pFactory(0);

std::unique_ptr&lt;::CRingItem&gt; item(getRingItem());  <co id='fmt.getitem' />
if (item-&gt;type() == RING_FORMAT) {                    <co id='fmt.isformat' />
    ::CRingFormatItem* pFormatItem =
        reinterpret_cast&lt;::CRingFormatItem*&gt;(item.get()); <co id='fmt.cast' />
    pFactory = &amp;(FormatSelector::selectFactory(*pFormatItem)); <co id='fmt.selectfromitem' />
} else {
    pFactory = &amp;(FormatSelector::selectFactory(defaultVersion)); <co id='fmt.selectdefault' />
}

::RingItemFactoryBase&amp; fact(*pFactory);               <co id='fmt.makereference' />

...

        </programlisting>
       </example>
       <para>
        There's a lot to unpack in this fragment of code and some of it is a bit
        sneaky.  Therefore let's look at this code very carefully.
       </para>
       <calloutlist>
        <callout arearefs='fmt.formatitem' >
          <para>
            We'll need to use the definitions of the
            <classname>CRingFormatItem</classname> so we include it's header here.
          </para>
        </callout>
        <callout arearefs='fmt.dataformat' >
            <para>
                The <filename>DataFormat.h</filename> file provides
                format definitions for each of the supported data formats.
                In this case, we pull in the data format from the abstract
                directory.  The main thing we want here is the ring item type
                definitions which, for the most part, are stable across versions.
            </para>
        </callout>
        <callout arearefs='fmt.defaultfmt' >
            <para>
                We store the default format type in a variable.  You might imagine
                that processing in the omitted code could modify this.   Version
                10 is a reasonable default because there isn't a data format item
                for that version.
            </para>
        </callout>
        <callout arearefs='fmt.getitem' >
            <para>
                This line just uses some function we dreamed out
                <function>getRingItem</function> to return a pointer
                to a dynamically allocated ring item gotten somehow.
                We initialize a unique_ptr as usual to ensure destruction.
            </para>
        </callout>
        <callout arearefs='fmt.isformat' >
            <para>
                Asks the item we got for its item type.  The type is checked
                against <literal>RING_FORMAT</literal> which is defined in
                <filename>DataFormat.h</filename>.  This is the type value
                for items that contain ring item formatting information.
            </para>
        </callout>
        <callout arearefs='fmt.cast' >
            <para>
                This line is a bit tricky.  It uses the fact that the specific
                ring item classes just wrap data containing the raw ring item.
                It further uses the fact that the format of a data format item
                is fixed over all versions that support it.  The result is therefore
                a pointer to the same wrapped object but treated as a
                data format item that knows how to interrrogate the underlying
                data to extract the format.
            </para>
        </callout>
        <callout arearefs='fmt.selectfromitem' >
            <para>
                This version of <methodname>FormatSelector::selectFactory</methodname>
                uses a reference to the format item to obtain and pass back
                a reference to the factory implied by the data format item.
                There's a bit of trickiness here as well.  We're passed back
                a reference and that's, in the end, what we want, but references
                can only be initialized.  They can't be assigned.
                Therefore, we accept the factory as a pointer and store it away
                in a pointer with a scope outside the if bodies.
            </para>
        </callout>
        <callout arearefs='fmt.selectdefault' >
            <para>
                If the item was not a format item we just create the factory
                corresponding to the default format type.
            </para>
        </callout>
        <callout arearefs='fmt.makereference' >
            <para>
                When we get to this point in the program, the factory pointer has
                a non null value.  We initialize the reference <varname>fact</varname>
                to refer to what our factory pointer points to.   Once all this is done
                we can continue processing data.
            </para>
        </callout>
       </calloutlist>
       <para>
        The key take away from this example is that we can produce an appropriate
        object factory without actually knowing the version of NSCLDAQ that
        produced the data we're processing; if the streamof data we're processing
        has a format item (comes from NSCLDAQ-11 or later).
       </para>
    </chapter>
    <chapter id='ch.reference'>
       <title id='ch.reference.title'>Reference pages</title>
       <para>
        The reference pages here take into consideration both the organization
        of the library and the order in which classes are likely to be used
        in a program.  Thus we start with a section that has reference material
        for the factory selector functions the abstract factory and the the abstract
        format classes that determine the functionality all other format classes
        have.
       </para>
       <para>
        Subsequent sections provide reference material for the version 10, version 11
        and version 12 factories and format classes.
       </para>
       <section>
        <title>Abstract Formatting</title>
        <refentry>
           <refmeta>
              <refentrytitle>Format Selector</refentrytitle>
              <manvolnum>3format</manvolnum>
           </refmeta>
           <refnamediv>
              <refname>Format Selector</refname>
              <refpurpose>Select Specific Format Factory</refpurpose>
            </refnamediv>
            <refsynopsisdiv>
                <programlisting>
#include &lt;NSCLDAQFactorySelector.h&gt;

namespace FormatSelector {
    enum SupportedVersions {v10, v11, v12};

    RingItemFactoryBase&amp; selectFactory(SupportedVersions version);
    RingItemFactoryBase&amp; selectFactory(CDataFormatItem&amp; item);


}


                </programlisting>
            </refsynopsisdiv>
            <refsect1>
                     <title>DESCRIPTION</title>
                  <para>
                    The definitions in the <literal>FormatSelector</literal>
                    namespace provide mechnisms to select  specific format factory
                    either from an explicit format specifier or from a data format item.
                    Note that data format items appear in NSCLDAQ-11 and later.
                  </para>
                  <para>
                    The format factories instantiated by these functions are cached
                    for later lookup.  This implies that:
                  </para>
                  <orderedlist>
                    <listitem>
                       <para>
                          Ownership of the factories continues to reside with this
                          module.  Deleting a factory returned from this API
                          will result in undefined, possibly fatal, behavior.
                       </para>
                    </listitem>
                    <listitem>
                       <para>
                          Several attempts to get a factory reference for the same
                          format version will return references to the same factory
                          instance.
                       </para>
                    </listitem>
                  </orderedlist>
            </refsect1>
            <refsect1>
                <title>DATA TYPES</title>
                <para>
                    The <type>FormatSelector::SupportedVersions</type> enum
                    is a type that is used as an NSCLDAQ version selector.
                </para>
            </refsect1>
            <refsect1>
                <title>API</title>
                <para>
                    Note that while all functions live in the
                    <literal>FormatSelector</literal> namespace
                    this is not shown in the function list below for the sake
                    of brevity.
                </para>
                <variablelist>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>::RingItemFactoryBase&amp;</type>
                           <methodname>selectFactory</methodname>
                           <methodparam>
                               <type>SupportedVersions</type><parameter>version</parameter>
                           </methodparam>
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Returns a reference to a ring item factory that is
                            suitable for creatig ring items for the NSCLDAQ
                            version selected by <parameter>version</parameter>.
                            The factory continues to be owned by the selection
                            subsystem and must <emphasis>not</emphasis> be deleted
                            by the caller.
                           </para>
                           <para>
                            A cache of factories ensures that several attempts
                            to obtain a factory for the same version will return
                            references to the same factory.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>::RingItemFactoryBase&amp; </type>
                           <methodname>selectFactory</methodname>
                           <methodparam>
                               <type>CDataFormatItem&amp;</type><parameter> item</parameter>
                           </methodparam>
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Given a reference to a data format item from any
                            version of NSCLDAQ that can produce these, provides
                            a factory for the version of NSCLDAQ indicated by that
                            item.  This wraps the prior overload for
                            <methodname>selectFactory</methodname> so everything
                            described above about the returned reference holds for
                            this one.
                           </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
                <para>
                    If a version is selected which is somehow not supported,
                    <classname>std::invalid_argument</classname> is thrown by
                    the <methodname>selectFactoryMethods</methodname> above.
                </para>
            </refsect1>
            
        </refentry>
        <refentry>
           <refmeta>
              <refentrytitle>RingItemFactoryBase</refentrytitle>
              <manvolnum>3format</manvolnum>
           </refmeta>
           <refnamediv>
              <refname>RingItemFactoryBase</refname>
              <refpurpose>Provide interface for ring item factoires.</refpurpose>
            </refnamediv>
            <refsynopsisdiv>
                <programlisting>
#include &lt;RingItemFactoryBase.h&gt;

class RingItemFactoryBase {
public:
    virtual CRingItem* makeRingItem(uint16_t type, size_t maxBody) = 0;
    virtual CRingItem* makeRingItem(uint16_t type, uint64_t timestamp, uint32_t sourceId,
            size_t maxBody, uint32_t barrierType = 0 ) = 0;
    virtual CRingItem* makeRingItem(const CRingItem&amp; rhs) = 0;
    virtual CRingItem* makeRingItem(const RingItem* pRawRing) = 0;


    virtual CRingItem* getRingItem(CRingBuffer&amp; ringbuf) = 0;
    virtual CRingItem* getRingItem(int fd) = 0;
    virtual CRingItem* getRingItem(std::istream&amp; in) = 0;

    virtual std::ostream&amp; putRingItem(const CRingItem* pItem, std::ostream&amp; out) = 0;
    virtual void putRingItem(const CRingItem* pItem, int fd) = 0;
    virtual void putRingItem(const CRingItem* pItem, CRingBuffer&amp; ringbuf) = 0;

    virtual CAbnormalEndItem* makeAbnormalEndItem() = 0;
    virtual CAbnormalEndItem* makeAbnormalEndItem(const CRingItem&amp; rhs) = 0;

    virtual CDataFormatItem* makeDataFormatItem() = 0;
    virtual CDataFormatItem* makeDataFormatItem(const CRingItem&amp; rhs) = 0;

    virtual CGlomParameters* makeGlomParameters(
        uint64_t interval, bool isBuilding, uint16_t policy
    )  = 0;
    virtual CGlomParameters* makeGlomParameters(const CRingItem&amp; rhs) = 0;

    virtual CPhysicsEventItem* makePhysicsEventItem(size_t maxBody) = 0;
    virtual CPhysicsEventItem* makePhysicsEventItem(
        uint64_t timestamp, uint32_t source, uint32_t barrier, size_t maxBody
    ) = 0;
    virtual CPhysicsEventItem* makePhysicsEventItem(const CRingItem&amp; rhs) = 0;

    virtual CRingFragmentItem* makeRingFragmentItem(
        uint64_t timestamp, uint32_t source, uint32_t payloadSize,
        const void* payload, uint32_t barrier=0
    ) = 0;
    virtual CRingFragmentItem* makeRingFragmentItem(const CRingItem&amp; rhs) = 0;


    virtual CRingPhysicsEventCountItem* makePhysicsEventCountItem(
        uint64_t count, uint32_t timeoffset, time_t stamp,
    int divisor=1
    ) = 0;
    virtual CRingPhysicsEventCountItem* makePhysicsEventCountItem(const CRingItem&amp; rhs) = 0;

    virtual CRingScalerItem* makeScalerItem(size_t numScalers) = 0;
    virtual CRingScalerItem* makeScalerItem(
        uint32_t startTime,
        uint32_t stopTime,
        time_t   timestamp,
        std::vector&lt;uint32_t&gt; scalers,
        bool                  isIncremental = true,
        uint32_t              sid = 0,
        uint32_t              timeOffsetDivisor = 1
    ) = 0;
    virtual CRingScalerItem* makeScalerItem(const CRingItem&amp; rhs) = 0;

    virtual CRingTextItem* makeTextItem(
        uint16_t type,
                std::vector&lt;std::string&gt; theStrings
    ) = 0;
    virtual CRingTextItem* makeTextItem(
        uint16_t type,
                std::vector&lt;std::string&gt; theStrings,
                uint32_t                 offsetTime,
                time_t                   timestamp, uint32_t divisor=1
    ) = 0;
    virtual CRingTextItem* makeTextItem(const CRingItem&amp; rhs) = 0;

    virtual CUnknownFragment* makeUnknownFragment(
        uint64_t timestamp, uint32_t sourceid, uint32_t barrier,
        uint32_t size, void* pPayload
    ) = 0;
    virtual CUnknownFragment* makeUnknownFragment(const CRingItem&amp; rhs) = 0;

    virtual CRingStateChangeItem* makeStateChangeItem(
        uint32_t itemType, uint32_t runNumber,
        uint32_t timeOffset,
        time_t   timestamp,
        std::string title
    ) = 0;
    virtual CRingStateChangeItem* makeStateChangeItem(const CRingItem&amp; rhs) = 0;

};


                </programlisting>
            </refsynopsisdiv>
            <refsect1>
                     <title>DESCRIPTION</title>
                  <para>
                    The <classname>CRingItemFactoryBase</classname> class provides
                    an abstract base class for the ring item factories implemented
                    by version specific libraries.  Note that specific return classes
                    defined as forward classes in the header and, therefore,
                    you need to <literal>#include</literal> the specific ring item
                    classes you need to actually use.
                  </para>
                  <para>
                    All return values are  pointers to dynamically allocated
                    objects.  These objects are owned by the caller and must be
                    deleted by the caller when no longer needed.  The return pointer
                    types are from the abstract library, however the actual return
                    types from any version specific factory will be objects of
                    the correct version's library.  
                  </para>
                  <para>
                    Since storage management can be difficult, users are encouraged
                    to use these methods to initialize smart pointer objects
                    such as <classname>std::unique_ptr</classname> or
                    <classname>std::shared_ptr</classname> to ensure that these
                    objects are, in fact, properly managed.
                  </para>
            </refsect1>
            <refsect1>
                <title>METHODS</title>
                <para>
                    Note that all public methods are pure virtual and must be
                    implemented by any concrete version specific factory.
                </para>
                <variablelist>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual CRingItem*</type>
                           <methodname> makeRingItem</methodname>
                           <methodparam>
                               <type>uint16_t </type><parameter>type</parameter>
                           </methodparam>
                           <methodparam>
                               <type>size_t </type><parameter>maxBody</parameter>
                           </methodparam>
                            
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Creates an undifferentiated ring item.  The
                            storage should be sufficient to hold
                            <parameter>maxBody</parameter> bytes of data.
                            The ring item header should be initialized such
                            that its type is <parameter>type</parameter>.
                           </para>
                           <para>
                            The precise initialization of the remainder of the
                            ring item's storage is implementation dependent.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual CRingItem* </type>
                           <methodname>makeRingItem</methodname>
                           <methodparam>
                               <type>uint16_t </type><parameter>type</parameter>
                           </methodparam>
                           <methodparam>
                               <type>uint64_t </type><parameter>timestamp</parameter>
                           </methodparam>
                           <methodparam>
                               <type>uint32_t </type><parameter>sourceId</parameter>
                           </methodparam>
                            <methodparam>
                                <type>size_t </type><parameter>maxBody</parameter>
                            </methodparam>
                            <methodparam>
                                <type>uint32_t </type><parameter>barrierType</parameter>
                                <initializer>0</initializer>
                            </methodparam>
                             
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            As before but also provides the body header parameters:
                            <parameter>timestamp</parameter>, which will be used
                            as the event timestamp in any body header,
                            <parameter>sourceId</parameter> which will be used
                             as the item's source id and
                             <parameter>barrierType</parameter> which is an optional
                             parameter that specifies the barrier type.  This defaults
                             to zero as that's the most common
                           </para>
                           <para>
                            The implementation of this method shall be equivalent
                            to:
                           </para>
                           <informalexample>
                            <programlisting>
std::auto_ptr&lt;::CRingItem&gt; pItem(fact.makeRingItem(type, maxbody));
pItem->setBodyHeader(timestamp, sourceId, barrierType);
                            </programlisting>
                           </informalexample>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual CRingItem*</type>
                           <methodname> makeRingItem</methodname>
                           <methodparam>
                               <type>const CRingItem&amp; </type><parameter>rhs</parameter>
                           </methodparam>
                            
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Makes a new ring item that is a copy of the
                            ring item that is referenced by the
                            <parameter>rhs</parameter>.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual CRingItem* </type>
                           <methodname>makeRingItem</methodname>
                           <methodparam>
                               <type>const RingItem* </type><parameter>pRawRing</parameter>
                           </methodparam>
                            
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Copies the contents of <parameter>pRawRing</parameter>
                            into local storage of a new ringitem object.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual CRingItem* </type>
                           <methodname>getRingItem</methodname>
                           <methodparam>
                               <type>CRingBuffer&amp; </type><parameter>ringbuf</parameter>
                           </methodparam>
                            
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Givena reference to an NSCLDAQ
                            <type>CRingBuffer</type> object that is created
                            as a consumer; consumes a raw ring item from that
                            ringbuffer encapsulating it in a
                            <classname>CRingItem</classname>.
                           </para>
                           <para>
                            Note that ringbuffers and ring items are such that
                            the actual NSCLDAQ library version used does not matter much
                            in the execution of this method.  
                           </para>
                           <para>
                            If a complete ring item is not yet available for
                            this consumer <parameter>ringbuf</parameter>,
                            the calling program will block until one is.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual CRingItem* </type>
                           <methodname>getRingItem</methodname>
                           <methodparam>
                               <type>int </type><parameter>fd</parameter>
                           </methodparam>
                            
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Consumes a ring item from the file descriptor
                            <parameter>fd</parameter> and wraps it in a
                            new <classname>CRingItem</classname> object.
                            If the file descriptor is e.g. a pipe and no
                            ring item is available, this will block.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual CRingItem* </type>
                           <methodname>getRingItem</methodname>
                           <methodparam>
                               <type>std::istream&amp; </type><parameter>in</parameter>
                           </methodparam>
                            
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Consumes a raw ring item from the stream
                            <parameter>in</parameter> wraps it up in a new
                            <classname>CRingBuffer</classname> class, returning
                            a pointer to that object.  If <parameter>in</parameter>
                            is e.g. a pipe and no object is available, the program
                            will block until one is seen.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual std::ostream&amp; </type>
                           <methodname>putRingItem</methodname>
                           <methodparam>
                               <type>const CRingItem*</type><parameter> pItem</parameter>
                           </methodparam>
                           <methodparam>
                               <type>std::ostream&amp; </type><parameter>out</parameter>
                           </methodparam>
                            
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Puts the encapsulated ring item
                            pointed to by <parameter>pItem</parameter> to the C++
                            output stream <parameter>out</parameter>.  A reference
                            to the stream after the output is returned.
                           </para>
                           <para>
                            The ring itme is output in raw format.  This allows
                            <methodname>getRingItem</methodname> to reconstruct
                            the ring item.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual void </type>
                           <methodname>putRingItem</methodname>
                           <methodparam>
                               <type>const CRingItem* </type><parameter>pItem</parameter>
                           </methodparam>
                           <methodparam>
                               <type>int </type><parameter>fd</parameter>
                           </methodparam>
                            
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Outputs the ring item pointed to by
                            <parameter>pItem</parameter> to whatever
                            the file descriptor <parameter>fd</parameter>
                            is open on.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual void </type>
                           <methodname>putRingItem</methodname>
                           <methodparam>
                               <type>const CRingItem* </type><parameter>pItem</parameter>
                           </methodparam>
                           <methodparam>
                               <type>CRingBuffer&amp;</type><parameter> ringbuf</parameter>
                           </methodparam>
                            
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Puts the raw ring item encapsulated in
                            <parameter>pItem</parameter> into the ring buffer
                            refrenced by <parameter>ringbuf</parameter>.
                            <parameter>ringbuf</parameter> must have been created
                            
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual CAbnormalEndItem* </type>
                           <methodname>makeAbnormalEndItem()</methodname>
                           <void />
                            
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Creates an abnormal end ring item type.  This is
                            used by versions of NSCLDAQ to flag a run that was not
                            properly ended.  If this item type cannot be
                            created <literal>nullptr</literal> must be returned.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual CAbnormalEndItem* </type>
                           <methodname>makeAbnormalEndItem</methodname>
                           <methodparam>
                               <type>const CRingItem&amp; </type><parameter>rhs</parameter>
                           </methodparam>
                            
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Given an undifferentiated ring item reference,
                            <parameter>rhs</parameter>, creates the equivalent
                            <classname>CAbnormalEndItem</classname>. Note that if
                            this is not possible (e.g. because <parameter>rhs</parameter>
                            is not an abnormal end item or because the version of
                            NSCLDAQ format in the concrete implementation does not
                            yet support <classname>CAbnormalEndItem</classname>s,
                            <classname>std::bad_cast</classname> must be thrown.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual CDataFormatItem* </type>
                           <methodname>makeDataFormatItem</methodname>
                           <void />                            
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Creates and returns a pointer to a data format
                            item for the format represented by the concrete
                            factory.  If the version represented by the concrete
                            factory does not support data format items,
                            this method must return <literal>nullptr</literal>
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual CDataFormatItem* </type>
                           <methodname>makeDataFormatItem</methodname>
                           <methodparam>
                               <type>const CRingItem&amp;</type><parameter> rhs</parameter>
                           </methodparam>
                            
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Given an undifferentiated ring item;
                            <parameter>rhs</parameter>, an equivalent
                            <classname>CDataFormatItem</classname> object is
                            created and a pointer to it returned.
                            If <parameter>rhs</parameter> is not a data format
                            item, or data format items are not supported by the
                            concreate implementation the implementation must
                            throw <classname>std::bad_cast</classname>.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual CGlomParameters*</type>
                           <methodname> makeGlomParameters</methodname>
                           <methodparam>
                               <type>uint64_t </type><parameter>interval</parameter>
                           </methodparam>
                           <methodparam>
                               <type>bool </type><parameter>isBuilding</parameter>
                           </methodparam>
                           <methodparam>
                               <type>uint16_t </type><parameter>policy</parameter>
                           </methodparam>
                            
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Creates and returns a pointer to a
                            <classname>CGlomParameters</classname> item described
                            by its parameters.  If the underlying format does not
                            support glom parameter items, <literal>nullptr</literal>
                            must be returned.
                           </para>
                           <para>
                            Glom is the component of the event builder that
                            glues events together from a totally time ordered stream
                            of event fragments.  If <parameter>isBuilding</parameter>
                            is true, glom is building events and not running in the
                            test mode in which it just emits fragments without
                            bothering to build them.  When building, fragments
                            are built if they all fit in the timestamp window
                            defined by <parameter>interval</parameter>.  The units
                            of this are dependent on the application and simply
                            represent timestamp ticks.  
                           </para>
                           <para>
                            <parameter>policy</parameter>
                            is an integer that describes how output event timestamps
                            are created from the fragment timestamps in an event.
                            Constants in <filename>DataFormat.h</filename> describe
                             the legal values for this parameter which are:
                           </para>
                           <itemizedlist>
                            <listitem>
                               <para>
                                  <emphasis>GLOM_TIMESTAMP_FIRST</emphasis>  -
                                  The event timestamp is taken from the timestamp
                                  of its first, earliest, fragment.
                               </para>
                            </listitem>
                            <listitem>
                               <para>
                                  <emphasis>GLOM_TIMESTAMP_LAST</emphasis>  -
                                  The event timestamp is taken from the timestamp
                                  of its last, latest, fragment.
                               </para>
                            </listitem>
                            <listitem>
                               <para>
                                  <emphasis>GLOM_TIMESTAMP_AVERAGE</emphasis>  -
                                  the timestamp is computed from the average of
                                  all fragment timestamps in the event.
                               </para>
                            </listitem>
                           </itemizedlist>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual CGlomParameters* </type>
                           <methodname>makeGlomParameters</methodname>
                           <methodparam>
                               <type>const CRingItem&amp; </type><parameter>rhs</parameter>
                           </methodparam>
                            
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            If <parameter>rhs</parameter> references a
                            glom parameters item returns a newly created,
                            equivalent <classname>CGomParameters</classname> object's
                            pointer.   If <parameter>rhs</parameter> is not a glom
                            parameters object or if the concrete implementation does
                            not yet support items of that time,
                            <classname>std::bad_cast</classname> must be thrown.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual CPhysicsEventItem* </type>
                           <methodname>makePhysicsEventItem</methodname>
                           <methodparam>
                               <type>size_t </type><parameter>maxBody</parameter>
                           </methodparam>
                            
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Creates a new physics event item. <parameter>maxBody</parameter>
                            sets the maximum size event body that will be filled in.
                            It is used to reserve space into which the ring item will
                            be formatted.  The return value is a pointer to a newly
                            created physics event item object.
                           </para>
                           <para>
                            If the underlying format of the concrete factory
                            supports body headers, this item will not be
                            created with a body header.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual CPhysicsEventItem*</type>
                           <methodname> makePhysicsEventItem</methodname>
                           <methodparam>
                               <type>uint64_t </type><parameter>timestamp</parameter>
                           </methodparam>
                           <methodparam>
                               <type>uint32_t</type><parameter> source</parameter>
                           </methodparam>
                           <methodparam>
                               <type>uint32_t </type><parameter>barrier</parameter>
                           </methodparam>
                           <methodparam>
                               <type>size_t </type><parameter>maxBody</parameter>
                           </methodparam>
                            
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Makes a physics event item with a body header
                            (if supported by the concrete format).  IF body headers
                            are not supported the implementation should just invoke
                            the prior creational method.
                           </para>
                           <para>
                            As before, <parameter>maxBody</parameter> determines
                            the maximum body size of the item.  The remaining
                            parameter determine the contents of the body header:
                            <parameter>timestamp</parameter> is the Event/fragment
                            timestamp, <parameter>source</parameter> is the Event/fragment
                            source id and <parameter>barrier</parameter> is the event/fragment's
                            barrier type.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual CPhysicsEventItem* </type>
                           <methodname>makePhysicsEventItem</methodname>
                           <methodparam>
                               <type>const CRingItem&amp;</type><parameter> rhs</parameter>
                           </methodparam>
                            
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Given <parameter>rhs</parameter> a reference to a
                            ring item that actually contains a physics event,
                            creates a new ring item of type <classname>CPHysicsEventItem</classname>
                            that is a functional equivalent of <parameter>rhs</parameter>
                            and returns a pointer to that item.
                           </para>
                           <para>
                            If <parameter>rhs</parameter> is not, in fact,
                            a physics event item, this method throws
                            <classname>std::bad_cast</classname>.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual CRingFragmentItem* </type>
                           <methodname>makeRingFragmentItem</methodname>
                           <methodparam>
                               <type>   uint64_t </type><parameter>timestamp</parameter>
                           </methodparam>
                           <methodparam>
                               <type> uint32_t </type><parameter>source</parameter>
                           </methodparam>
                           <methodparam>
                               <type>uint32_t </type><parameter>payloadSize</parameter>
                           </methodparam>
                           <methodparam>
                               <type>const void* </type><parameter>payload</parameter>
                           </methodparam>
                           <methodparam>
                               <type>uint32_t </type><parameter>barrier</parameter>
                               <initializer>0</initializer>
                           </methodparam>
                            
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            A <classname>CRingFragmentItem</classname> represents
                            an event fragment whose payload is a ring item.
                            The fragment itself looks like a ring item and has an
                            obligatory body header. The body header is followed by
                            a payload which, for this type is assumed to be another
                            ring item.
                           </para>
                           <para>
                            The contents of the obligatory body header are defined by
                            <parameter>timestamp</parameter>, the fragment timestamp,
                            <parameter>source</parameter>, the fragment source id and
                            <parameter>barrier</parameter>, the optional barrier type.
                            If not provided <parameter>barrier</parameter> defaults to
                            zero which is no barrier.
                           </para>
                           <para>
                            The payload is defined by
                            <parameter>paylaodSize</parameter> which is the number
                            of bytes in the payload and <parameter>payload</parameter>
                            which points to the payload itself.
                           </para>
                           <para>
                            The return value is a pointer to a new created
                            <classname>CRingFragmentItem</classname>.
                            If the concrete factory is of a format that does not
                            support <classname>CRingFragmentItem</classname> object
                            (does not implement the ring fragment raw ring item),
                            a <literal>nullptr</literal> must be returned.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual CRingFragmentItem* </type>
                           <methodname>makeRingFragmentItem</methodname>
                           <methodparam>
                               <type>const CRingItem&amp; </type><parameter>rhs</parameter>
                           </methodparam>
                            
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            If <parameter>rhs</parameter> references a
                            <classname>CRingItem</classname> whose contents are
                            a fragment item, this method creates a new
                            <classname>CRingFragmentItem</classname>, fills it with
                            the contents of the <parameter>rhs</parameter> and
                            returns a pointer to the new item.
                           </para>
                           <para>
                            If <parameter>rhs</parameter> is not a ring fragment item
                            or the version of NSCLDAQ used by the concrete factory
                            does not support <classname>CRingFragmentItem</classname>s,
                            <classname>std::bad_cast</classname> must be thrown.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual CRingPhysicsEventCountItem* </type>
                           <methodname>makePhysicsEventCountItem</methodname>
                           <methodparam>
                               <type>uint64_t </type><parameter>count</parameter>
                           </methodparam>
                           <methodparam>
                               <type>uint32_t </type><parameter>timeoffset</parameter>
                           </methodparam>
                           <methodparam>
                               <type>time_t </type><parameter>stamp</parameter>
                           </methodparam>
                           <methodparam>
                               <type>int </type><parameter>divisor</parameter>
                               <initializer>1</initializer>
                           </methodparam>
                            
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            A physics event count item represents the number of
                            event triggers on a data source. This can be used
                            online analysis programs to know the fraction of the
                            data they are able to analyze.
                           </para>
                           <para>
                            <parameter>count</parameter> is the total number
                            of triggers this run.  <parameter>timeoffset</parameter>
                            is the time offset into the run at which the number
                            of triggers represents.  <parameter>divisor</parameter>,
                            if supplied indicates the number of timeoffset ticks
                            in a second.  This allows for run offsets to be represented
                            with sub-second resolution.  The <parameter>stamp</parameter>
                            parameter represents the clock time at which the item was created.
                           </para>
                           <para>
                            All versions of NSCLDAQ since version 10 (the lowest
                            version we attempt to handle in this library) support
                            event count items.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual CRingPhysicsEventCountItem* </type>
                           <methodname>makePhysicsEventCountItem</methodname>
                           <methodparam>
                               <type>const CRingItem&amp;</type><parameter> rhs</parameter>
                           </methodparam>
                            
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            If the contents of <parameter>rhs</parameter> are a
                            physics event count raw item, this method creates a new
                            <classname>CRingPhysicsEventCountItem</classname> object
                            to wrap a copy of the item in <parameter>rhs</parameter> and
                            returns a pointer to that object.
                           </para>
                           <para>
                            If <parameter>rhs</parameter> is not encapsulating an
                            event count item; <classname>std::bad_cast</classname>
                            is thrown.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual CRingScalerItem* </type>
                           <methodname>makeScalerItem</methodname>
                           <methodparam>
                               <type>size_t </type><parameter>numScalers</parameter>
                           </methodparam>
                            
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Creates a new scaler item and returns a pointer to it.
                            Object methods can be used to modify the contents of the
                            item.   The item is sized for <parameter>numScalers</parameter>
                            32 bit scalers.  The clock timestamp for the item
                            is its creation time. The counting interval is initialized
                            to from zero to zero and the time divisor is initialized to
                            1.
                           </para>
                           <para>
                            For formats that support a body header, this item
                            should be created with no body header.   A full
                            body header can, of course, be added with
                            the object's <methodname>setBodyHeader</methodname>.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual CRingScalerItem* </type>
                           <methodname>makeScalerItem</methodname>
                           <methodparam>
                               <type>uint32_t </type><parameter>startTime</parameter>
                           </methodparam>
                           <methodparam>
                               <type>uint32_t </type><parameter>stopTime</parameter>
                           </methodparam>
                           <methodparam>
                               <type>time_t   </type><parameter>timestamp</parameter>
                           </methodparam>
                           <methodparam>
                               <type>std::vector&lt;uint32_t&gt; </type><parameter>scalers</parameter>
                           </methodparam>
                           <methodparam>
                               <type>bool </type><parameter>isIncremental </parameter>
                               <initializer>true</initializer>
                           </methodparam>
                           <methodparam>
                               <type>uint32_t </type><parameter>sid</parameter>
                               <initializer>0</initializer>
                           </methodparam>
                           <methodparam>
                               <type>uint32_t</type><parameter>timeOffsetDivisor</parameter>
                               <initializer>1</initializer>
                           </methodparam>
                            
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Constructs a scaler item and returns a pointer to it.
                            The <parameter>startTime</parameter> and
                            <parameter>stopTime</parameter> parameters provide the
                            offset into the run at which the counting interval started
                            and ended.  The <parameter>divisor</parameter>
                            provides the number of ticks per second for both of these
                            parameters.
                           </para>
                           <para>
                            <parameter>scalers</parameter> is the array of
                            scaler values.  <parameter>isIncremental</parameter>
                            indicates if the scalers were zeroed after the read.
                           </para>
                           <para>
                            For versions that support an original source id,
                            <parameter>sid</parameter> provides this value.
                            This allows event built data to track the source id
                            of the emitter of this item even as Glom rewrites the
                            body header source id.
                           </para>
                           <para>
                            See concrete implementations for information about
                            how, if at all, the implementation fills in a body header
                            for the item.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual CRingScalerItem* </type>
                           <methodname>makeScalerItem</methodname>
                           <methodparam>
                               <type>const CRingItem&amp; </type><parameter>rhs</parameter>
                           </methodparam>
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            If <parameter>rhs</parameter> encapsulates a raw
                            scaler item a new <classname>CRingScalerItem</classname>
                            is created and the data in <parameter>rhs</parameter>
                            are copied into the new item.  A pointer to that new
                            item is returned.
                           </para>
                           <para>
                            If <parameter>rhs</parameter> does not represent
                            scaler data, <classname>std::bad_cast</classname>
                            is thrown.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual CRingTextItem* </type>
                           <methodname>makeTextItem</methodname>
                           <methodparam>
                               <type>uint16_t </type><parameter>type</parameter>
                           </methodparam>
                           <methodparam>
                               <type>std::vector&lt;std::string&gt; </type><parameter>theStrings</parameter>
                           </methodparam>
                             
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Creates a ring item that contains a set of strings.
                            The <parameter>type</parameter> parameter contains
                            the type of the ring item (type field of ring item header).
                            The possible values for this are in <filename>DataFormat.h</filename>
                            and can be:
                           </para>
                           <itemizedlist>
                            <listitem>
                               <para>
                                  <emphasis>PACKET_TYPES</emphasis>  describes
                                  the set of packet data types physics event bodies
                                  may have.
                               </para>
                            </listitem>
                            <listitem>
                               <para>
                                  <emphasis>MONITORED_VARIABLES</emphasis>
                                  Contains a set of variable names and values as
                                  Tcl scriptlets that would set those variables
                                  to their values.
                               </para>
                            </listitem>
                           </itemizedlist>
                           <para>
                            <parameter>theStrings</parameter> contains the
                            strings to put in the payload section of the body.
                           </para>
                           <para>
                            Timing information in the bodiesof this ring item type
                            are initialized as follows:  The run offset time is zero,
                            The clock timestamp is the creation time of the
                            object and the offset divisor is <literal>1</literal>.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual CRingTextItem* </type>
                           <methodname>makeTextItem</methodname>
                           <methodparam>
                               <type>    uint16_t </type><parameter>type</parameter>
                           </methodparam>
                           <methodparam>
                               <type>std::vector&lt;std::string&gt; </type><parameter>theStrings</parameter>
                           </methodparam>
                           <methodparam>
                               <type>uint32_t </type><parameter>offsetTime</parameter>
                           </methodparam>
                           <methodparam>
                               <type>time_t</type><parameter>timestamp</parameter>
                           </methodparam>
                           <methodparam>
                               <type>uint32_t </type><parameter>divisor</parameter>
                               <initializer>1</initializer>
                           </methodparam>
                            
                           
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Creates an item with a list of text strings encapsulates it
                            in a <classname>CRingTextItem</classname> and returns a
                            pointer to the resulting item.  As before,
                            <parameter>type</parameter> is the ring item type
                            and <parameter>theStrings</parameter> are the
                            text strings to store in the ring item.
                           </para>
                           <para>
                            Additional parameters provide time information.
                            <parameter>offsetTime </parameter> is the offset into the
                            run while <parameter>divisor</parameter> is the number
                            of counts in <parameter>offsetTime</parameter> per second.
                            <parameter>timestamp</parameter> is the clock time that will
                            tag the item.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual CRingTextItem* </type>
                           <methodname>makeTextItem</methodname>
                           <methodparam>
                               <type>const CRingItem&amp;</type><parameter> rhs</parameter>
                           </methodparam>
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Given that <parameter>rhs</parameter> encapsulates a
                            ring text item, this method creates a new
                            <parameter>CRingTextItem</parameter>, copies the raw
                            ring item encapsulated by <parameter>rhs</parameter>
                            and returns a pointer to that new
                            <classname>CRingTextItem</classname>.
                           </para>
                           <para>
                            If the ring item type of <parameter>rhs</parameter>
                            makes it clear that this is not a valid text item, a
                            <classname>std::bad_cast</classname> will be thrown.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual CUnknownFragment* </type>
                           <methodname>makeUnknownFragment</methodname>
                           <methodparam>
                               <type>uint64_t </type><parameter>timestamp</parameter>
                           </methodparam>
                           <methodparam>
                               <type>uint32_t </type><parameter>sourceid</parameter>
                           </methodparam>
                           <methodparam>
                               <type>uint32_t</type><parameter> barrier</parameter>
                           </methodparam>
                           <methodparam>
                               <type>uint32_t </type><parameter>size</parameter>
                           </methodparam>
                           <methodparam>
                               <type>void* </type><parameter>pPayload</parameter>
                           </methodparam>
                            
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            This method is the same as <methodname>makeRingFragmentItem</methodname>
                            but the payload is not assumed to be a ring item.
                            While ring fragment items have type
                            <literal>EVB_FRAGMENT</literal>,  these have type
                            <literal>EVB_UNKNOWN_PAYLOAD</literal>
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual CUnknownFragment* </type>
                           <methodname>makeUnknownFragment</methodname>
                           <methodparam>
                               <type>const CRingItem&amp; </type><parameter>rhs</parameter>
                           </methodparam>
                            
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Again see <methodname>makeRingFragmentItem</methodname>.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual CRingStateChangeItem* </type>
                           <methodname>makeStateChangeItem</methodname>
                           <methodparam>
                               <type>uint32_t </type><parameter>itemType</parameter>
                           </methodparam>
                           <methodparam>
                               <type>uint32_t</type><parameter> runNumber</parameter>
                           </methodparam>
                           <methodparam>
                               <type>uint32_t</type><parameter>timeOffset</parameter>
                           </methodparam>
                           <methodparam>
                               <type>time_t </type><parameter>timestamp</parameter>
                           </methodparam>
                           <methodparam>
                               <type>std::string </type><parameter>title</parameter>
                           </methodparam>
                            
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Creates a new state change ring item wrapping it in a
                            <classname>CRingStateChangeItem</classname> and returning a
                            pointer to the new object.
                           </para>
                           <para>
                            The <parameter>itemType</parameter> parameter provides
                            the exact state change reason.  Its possible values are
                            defined in <filename>DataFormat.h</filename> and are:
                            <literal>BEGIN_RUN</literal>, <literal>PAUSE_RUN</literal>,
                            <literal>RESUME_RUN</literal>, and <literal>END_RUN</literal>
                            with obvious (I hope) meanings.
                           </para>
                           <para>
                            <parameter>runNumber</parameter> provides the run number
                            of the run having the transition, and <parameter>title</parameter>
                            its title string.  <parameter>timeOffset</parameter>
                            provides the time offset into the run while
                            <parameter>timestamp</parameter> is intended
                            to provide an absolute clock time at which the
                            transtion occured.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual CRingStateChangeItem* </type>
                           <methodname>makeStateChangeItem</methodname>
                           <methodparam>
                               <type>const CRingItem&amp;</type><parameter> rhs</parameter>
                           </methodparam>
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            If <parameter>rhs</parameter> is a <classname>CRingItem</classname>
                            that is wrapping a state change raw ring item, this
                            method creates a new <classname>CRingStateChangeItem</classname>,
                            wraps a copy of the raw ring item in <parameter>rhs</parameter>
                            and returns a pointer to the new item to the caller.
                            If <parameter>rhs</parameter> is not a valid
                            state change item, <classname>std::bad_cast</classname>
                            is thrown.
                           </para>
                        </listitem>
                    </varlistentry>                
                </variablelist>
                             
            </refsect1>
        </refentry>
        
        <refentry>
           <refmeta>
              <refentrytitle>CRingItem (abstract)</refentrytitle>
              <manvolnum>3format</manvolnum>
           </refmeta>
           <refnamediv>
              <refname>CRingItem</refname>
              <refpurpose>Ultimate ring item base class</refpurpose>
            </refnamediv>
            <refsynopsisdiv>
                <programlisting>
#include &lt;CRingItem.h&lt;

class CRingItem {

public:
      CRingItem(uint16_t type, size_t maxBody = CRingItemStaticBufferSize - 10);

      CRingItem(const CRingItem&amp; rhs);
      CRingItem(pRingItem pItem);
      virtual ~CRingItem();
      virtual size_t getStorageSize() const;
      virtual size_t getBodySize()    const;
      virtual const void*  getBodyPointer() const;
      virtual void* getBodyPointer();
      void*  getBodyCursor();
      pRingItem  getItemPointer();
      const RingItem*  getItemPointer() const;
      uint32_t type() const;
      uint32_t size() const;
      virtual bool mustSwap() const;
      virtual bool hasBodyHeader() const;
      virtual void* getBodyHeader() const = 0;
      virtual uint64_t getEventTimestamp() const;
      virtual uint32_t getSourceId() const;
      virtual uint32_t getBarrierType() const;
      virtual void setBodyHeader(uint64_t timestamp, uint32_t sourceId,
                         uint32_t barrierType = 0) = 0;
      virtual void setBodyCursor(void* pNewCursor);
      virtual void updateSize();            /* Set the header size given the cursor. */
      virtual std::string typeName() const; // Textual type of item.
      virtual std::string toString() const; // Provide string dump of the item.
      virtual void* appendBodyData(const void* pSrc, uint32_t nBytes);


};
                </programlisting>
            </refsynopsisdiv>
            <refsect1>
                     <title>DESCRIPTION</title>
                  <para>
                    This is the ultimate base class for all ring item format classes.
                    It lives in the global namespace.  It provides interfaces
                    and services used by other derived classes.
                  </para>
                  <para>
                    While most of the virtual methods have default implementations,
                    if you are building a new formatting class hierarchy, you should
                    not count on those doing what you want if they require
                    knowledge of the format of the ring item format.
                  </para>
            </refsect1>
            <refsect1>
                <title>METHODS</title>
                <variablelist>
                    <varlistentry>
                       <term>
                        <constructorsynopsis>
                            <methodname>CRingItem</methodname>
                            <methodparam>
                                <type>uint16_t</type><parameter>type</parameter>
                            </methodparam>
                            <methodparam>
                                <type>size_t </type><parameter>maxBody</parameter>
                                <initializer>CRingItemStaticBufferSize - 10</initializer>
                            </methodparam>
                        </constructorsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Constructor.  <parameter>type</parameter> will be stored
                            in the ring item header's type field.  Note that
                            the header form is common for all formats.
                            The <parameter>type</parameter> is 16 bit wide because in
                            the original design it was also used to determine the
                            byte order of the originator.  Specifically, if the
                            'low order' 16 bits of a type field were zero, the
                            byte order of the originator was the opposite of the
                            consumer.  Now that little-endianess has won the
                            byte order wars and big-endinaness only appears
                            vestigially in network byte ordering,  We define
                            the byte ordering of Ring items to be little-endian.
                           </para>
                           <para>
                            <parameter>maxBody</parameter> determines the maximum
                            number of bytes the internal storage for the ring item
                            can hold in the body (the part following the header).
                            Note that the design of <classname>CRingItem</classname>
                            includes a decently sized static block of data.
                            If this value indicates the data will fit in that
                            block, no dynamic memory allocation is required and
                            that block is used.  If this value indicates that
                            the data won't fit, a block is dynamically allocated
                            and used.  The intent is to minimize the costly
                            set of dynamic memory allocations/deallocations
                            needed if all <classname>CRingItem</classname>
                            constructions dynamically allocated the needed
                            data.
                           </para>
                           <para>
                            The default value for <parameter>maxBody</parameter>
                            allows callers to use the static buffer and is
                            defined in <filename>CRingItem.h</filename>.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <constructorsynopsis>
                            <methodname>CRingItem</methodname>
                            <methodparam>
                                <type>pRingItem </type><parameter>pItem</parameter>
                            </methodparam>
                        </constructorsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Wraps a <classname>CRingItem</classname> object
                            around a raw ring item.  The type
                            <type>pRingItem</type> is defined in
                            <filename>DataFormat.h</filename>.
                           </para>
                           <para>
                            <parameter>pItem</parameter> is used to size
                            the ring item and copied into the data storage
                            region of the item.  The body cursor is set to point
                            after the ring item data.  This allows the
                            item to be mutated (via <methodname>getBodyPointer</methodname>)
                            and to be extended (via <methodname>getBodyCursor</methodname>,
                            <methodname>setBodyCursor</methodname>, and <methodname>updateSize</methodname>).
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual size_t </type>
                           <methodname>getStorageSize</methodname>
                           <void />
                           <modifier>const</modifier>
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Returns the capacity of the block of data that is being used
                            to store the ring item.   Can be used to determine
                            if sufficient storage has been allocated to
                            hold the desired ring item.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual size_t </type>
                           <methodname>getBodySize</methodname>
                           <void />
                           <modifier>const</modifier>
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Returns the current size, in bytes,
                            of the ring item body.
                            This computes the number of bytes between the
                            pointers returned by
                            <methodname>getBodyCursor</methodname> and the
                            <methodname>geBodyPointer</methodname>.  For it to be
                            accurate, <methodname>getBodyCursor</methodname>
                            must be updated (via <methodname>setBodyCursor</methodname>)
                            to point past the body of the ring item as it is
                            so far.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual const void*  </type>
                           <methodname>getBodyPointer</methodname>
                           <void /><modifier>const</modifier>
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Returns a pointer to the body of the item. Since
                            the pointer is const, this is intended to allow
                            read access.  Note that the concept of a ring item
                            <firstterm>body</firstterm> is not that straightforward.
                            In version 10, for example the body begins right after
                            the ring item header.  In v11, v12, which support body
                            headers the body may begin after the <type>uint32_t</type>
                            indicating there is no body header (which has different values
                            depending on version) or it may begin after the body
                            header if there is on.  Therefore, this is virtual
                            and implemented on a per version basis.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type> virtual void* </type>
                           <methodname>getBodyPointer</methodname>
                           <void />
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Same as above except that the pointer can be used
                            to modify the body contents.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>void*  </type>
                          <methodname>getBodyCursor</methodname>
                          <void />
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the body cursor of the item. When a ring item
                            is created, a pointer, called the body cursor is
                            created which points to the first free byte of memory
                            into which data can be appended to the ring item.
                            As data are appended to the ring item, the
                            object's body cursor should be reste with
                            <methodname>setBodyCursor</methodname>, at some point,
                            when the ring item has been completely built,
                            <methodname>updateSize</methodname> should be called
                            to compute the ring item's size and store it in the
                            size field of the ring item's header.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>pRingItem  </type>
                          <methodname>getItemPointer</methodname>
                          <void />
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns a pointer to the ring item as encapsulated
                            by this class.  Note that <type>pRingItem</type>
                            is defined in <filename>DataFormat.h</filename>.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>const RingItem*  </type>
                          <methodname>getItemPointer</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Same as above but the pointer only allows read access
                            to the contents of the ring item.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>uint32_t </type>
                          <methodname>type</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the full 32 bit size field of the
                            ring item.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>uint32_t </type>
                          <methodname>size</methodname>
                          <void /> <modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the size field of the header. Note that unless
                            <methodname>updateSize</methodname> has been called,
                            this value is not a reliable measure of the number
                            of bytes that make up the ring item.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual bool </type>
                          <methodname>mustSwap</methodname>
                          <void /> <modifier> const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns <literal>false</literal>.  All data is
                            now specified be little endian as are all computing
                            systems processing that data.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual bool </type>
                          <methodname>hasBodyHeader</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns <literal>true</literal> if the ring item
                            has a body header.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void* </type>
                          <methodname>getBodyHeader</methodname>
                          <void /> <modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns a pointer to the body header of the item
                            if it has one.  If it does not returns a
                            <literal>nullptr</literal>. 
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        <methodsynopsis>
                           <type>virtual uint64_t </type>
                           <methodname>getEventTimestamp</methodname>
                           <void /> <modifier>const</modifier>
                        </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Returns the event/fragment timestamp stored
                            in the body header of the ring item.  If the ring
                            item has no body header,
                            <classname>std::logic_error</classname> is thrown.
                            You can use e.g. <methodname>hasBodyHeader</methodname>
                            to test for the presence of a body header in the
                            item.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual uint32_t </type>
                          <methodname>getSourceId</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Retrieves the source id from the ring item's body header.
                            If the ring item does not have a body header,
                            <classname>std::logic_error</classname> is throw
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual uint32_t </type>
                          <methodname>getBarrierType</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the barrier type field from the item's
                            body header.   If the ring item does not have a body
                            header, <classname>std::logic_error</classname>
                            is thrown.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                        (pure virtual)
                        <methodsynopsis>
                          <type>virtual void </type>
                          <methodname>setBodyHeader</methodname>
                          <methodparam>
                              <type>uint64_t </type><parameter>timestamp</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t </type><parameter>sourceId</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t </type><parameter>barrierType</parameter>
                              <initializer>0</initializer>
                          </methodparam>
                       </methodsynopsis>
                       
                       </term>
                       <listitem>
                           <para>
                            If the format supports body headers a body header is
                            added to the item (if it does not already have one) or
                            the body header is modified as described by the method's
                            parameters.  If the format does not support body headers,
                            this should be implemented as a no-op.
                           </para>
                           <para>
                            Note that body data must never be overwritten.
                            If an item has a non-empty body but no body header,
                            then that body must be moved to make space for the
                            body header which is then put in the appropriate
                            place (after the ring item header in currently
                            supported formats).
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void </type>
                          <methodname>setBodyCursor</methodname>
                          <methodparam>
                              <type>void* </type><parameter>pNewCursor</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Updates the internal body cursor of the object
                            with <parameter>pNewCursor</parameter>.  If coupled
                            with a call to <methodname>updateSize</methodname>,
                            this causes the size field of the ring item header
                            to be computed and updated.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void</type>
                          <methodname>updateSize</methodname>
                          <void />
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Treating the current body cursor value as a pointer
                            to the byte following the current contents of the
                            ring item, the size of the ring item is computed
                            and stored in the size field of the ring item
                            header.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual std::string </type>
                          <methodname>typeName</methodname>
                          <void /> <modifier>() const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            The base class returns the string:
                            <literal>Unknown</literal> followed by the parenthesized
                            numeric
                            type from the ring item header in hexadecimal.
                            Derived classes are
                            expected to return a text string which indicates the
                            type of the ring item. 
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual std::string </type>
                          <methodname>toString</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Retuns a human readable stringified dump
                            of the body of the item.  In this case this is just
                            a byte by byte dump.  Derived classes are expected
                            to return something a bit more meaningful.  The
                            NSCLDAQ dumper, e.g. uses this string to
                            dump items it encounters.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void* </type>
                          <methodname>appendBodyData</methodname>
                          <methodparam>
                              <type>const void* </type><parameter>pSrc</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t </type><parameter>nBytes
                              </parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Appends the <parameter>nBytes</parameter> bytes
                            of data pointed to by <parameter>pSrc</parameter>
                            to the ring item.  The data are placed where
                            the current body cursor is pointing.  The body cursor
                            is updated and the size recomputed.
                           </para>
                           <para>
                            This is equivalent to the following code fragment:
                           </para>
                           <informalexample>
                            <programlisting>
  uint8_t* p = reinterpret_cast&lt;uint8_t*&gt;(getBodyCursor());
  memcpy(p, pSrc, nBytes);
  p += nBytes;
  setBodyCursor(p);
  updateSize();
  return p;

                            </programlisting>
                           </informalexample>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </refsect1>
        </refentry>
        <refentry>
           <refmeta>
              <refentrytitle>CAbnormalEndItem (abstract)</refentrytitle>
              <manvolnum>3format</manvolnum>
           </refmeta>
           <refnamediv>
              <refname>CAnbormaleEndItem (abstract)</refname>
              <refpurpose>Support ring items that flag abnormally ended runs.</refpurpose>
            </refnamediv>
            <refsynopsisdiv>
                <programlisting>
#include &lt;CAbnormalEndItem.h&gt;

class CAbnormalEndItem : public CRingItem
{
public:
    CAbnormalEndItem();
    virtual ~CAbnormalEndItem();

    virtual void* getBodyHeader() const;
    virtual void  setBodyHeader(uint64_t timestamp, uint32_t sourceId,
                         uint32_t barrierType = 0);

    virtual std::string typeName() const;
    virtual std::string toString() const;
};

                </programlisting>
            </refsynopsisdiv>
            <refsect1>
                     <title>DESCRIPTION</title>
                  <para>
                    In the event a data taking run ends abnormally,
                    Abnormal end run items can be emittted.  One purpose of
                    these is to inform event loggers that the event file they have
                    open can be closed. 
                  </para>
                  <para>
                    Normally an abnormal end run item is an indication of a
                    DAQ state transition from active or paused to not ready.
                  </para>
                  <para>
                    Abnormal end items were introduced into NSCLDAQ in version
                    11.  In version 11 and 12, they are simply ring item headers
                    with no body but the type <literal>ABNORMAL_ENDRUN</literal>.
                  </para>
            </refsect1>
            <refsect1>
                <title>METHODS</title>
                <para>
                    The methods below are normally implemented in version
                    specific implementation of <classname>CAbnormalEndRun</classname>
                </para>
                <variablelist>
                    <varlistentry>
                       <term><constructorsynopsis>
                           <methodname>CAbnormalEndItem</methodname>
                        <void />
                       </constructorsynopsis></term>
                       <listitem>
                           <para>
                            Constructs the item.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void* </type>
                          <methodname>getBodyHeader</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Normally returns <literal>nullptr</literal>
                            since these items don't have body headers.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void  </type>
                          <methodname>setBodyHeader</methodname>
                          <methodparam>
                              <type>uint64_t </type><parameter>timestamp</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t </type><parameter>sourceId</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t </type><parameter>barrierType</parameter>
                              <initializer>0</initializer>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Since the <classname>CAbnormalEndItem</classname>
                            never has a body header, this is a no-op.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual std::string </type>
                          <methodname>typeName</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the string
                            <literal>Abnormal End</literal>
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual std::string </type>
                          <methodname>toString</methodname>
                          <void /> <modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the string
                            <literal>Abnormal End\n</literal> where the
                            <literal>\n</literal> should be interpreted to mean
                            a new line.
                           </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </refsect1>
        </refentry>
        <refentry>
           <refmeta>
              <refentrytitle>CDataFormatItem (abstract)</refentrytitle>
              <manvolnum>3format</manvolnum>
           </refmeta>
           <refnamediv>
              <refname>CDataFormatItem (abstract)</refname>
              <refpurpose>Ring item that describes format version</refpurpose>
            </refnamediv>
            <refsynopsisdiv>
                <programlisting>
#include &lt;CDataFormatItem.h&gt;

class CDataFormatItem : public CRingItem
{
public:
    CDataFormatItem();
    virtual ~CDataFormatItem();

    CDataFormatItem(const CDataFormatItem&amp; rhs);
    CDataFormatItem(const CRingItem&amp; rhs) ;


    virtual uint16_t getMajor() const;
    virtual uint16_t getMinor() const;


    virtual std::string typeName() const;
    virtual std::string toString() const;

    virtual void* getBodyHeader() const;
    virtual void setBodyHeader(uint64_t timestamp, uint32_t sourceId,
                         uint32_t barrierType = 0);

};

                </programlisting>
            </refsynopsisdiv>
            <refsect1>
                     <title>DESCRIPTION</title>
                  <para>
                    THe data format ring item was introduced beginning in
                    NSCLDAQ-11.  It provides information about the version
                    (and therefore the  format) of NSCLDAQ that
                    generated the stream of ring items that follow.
                  </para>
            </refsect1>
            <refsect1>
                <title>METHODS</title>
                <variablelist>
                   <varlistentry>
                      <term><constructorsynopsis>
                          <methodname>CDataFormatItem</methodname>
                        <void />
                      </constructorsynopsis></term>
                      <listitem>
                          <para>
                            The constructor fill sin the item with the
                            major and minor vesions that define the data
                            format.
                       </para>
                    </listitem>
                   </varlistentry>
                   <varlistentry>
                      <term><methodsynopsis>
                         <type>virtual uint16_t </type>
                         <methodname>getMajor </methodname>
                         <void /><modifier>const</modifier>
                      </methodsynopsis></term>
                      <listitem>
                          <para>
                            Returns the major version of the data format.  In
                            practice, this is sufficient to establish the data
                            format.
                       </para>
                    </listitem>
                   </varlistentry>
                   <varlistentry>
                      <term><methodsynopsis>
                         <type>virtual uint16_t </type>
                         <methodname>getMinor</methodname>
                         <void /><modifier>const</modifier>
                      </methodsynopsis></term>
                      <listitem>
                          <para>
                            Returns the minor version of the data format.  In practice
                            this is seldom necessary.
                       </para>
                    </listitem>
                   </varlistentry>
                   <varlistentry>
                      <term><methodsynopsis>
                         <type>virtual std::string </type>
                         <methodname>typeName</methodname>
                         <void /><modifier>const</modifier>
                      </methodsynopsis></term>
                      <listitem>
                          <para>
                            Return the string:
                            <literal>Ring Item format version</literal>
                       </para>
                    </listitem>
                   </varlistentry>
                   <varlistentry>
                      <term><methodsynopsis>
                         <type>virtual std::string </type>
                         <methodname>toString</methodname>
                         <void /> <modifier>const</modifier>
                      </methodsynopsis></term>
                      <listitem>
                          <para>
                            Returns a human readable string that describes the
                            contents of the ring item.
                       </para>
                    </listitem>
                   </varlistentry>
                   <varlistentry>
                      <term><methodsynopsis>
                         <type>virtual void* </type>
                         <methodname>getBodyHeader</methodname>
                         <void /><modifier>const</modifier>
                      </methodsynopsis></term>
                      <listitem>
                          <para>
                            Returns <literal>nullptr</literal> since these items
                            never have a body header.
                       </para>
                    </listitem>
                   </varlistentry>
                   <varlistentry>
                      <term><methodsynopsis>
                         <type>virtual void </type>
                         <methodname>setBodyHeader</methodname>
                         <methodparam>
                             <type>uint64_t </type><parameter>timestamp</parameter>
                         </methodparam>
                         <methodparam>
                             <type>uint32_t </type><parameter>sourceId</parameter>
                         </methodparam>
                         <methodparam>
                             <type>uint32_t </type><parameter>barrierType </parameter>
                             <initializer>0</initializer>
                         </methodparam>
                      </methodsynopsis></term>
                      <listitem>
                          <para>
                            No-op since these items don't have body headers.
                       </para>
                    </listitem>
                   </varlistentry>                    
                </variablelist>
            </refsect1>
        </refentry>
        <refentry>
           <refmeta>
              <refentrytitle>CGlomParameters (abstract)</refentrytitle>
              <manvolnum>3format</manvolnum>
           </refmeta>
           <refnamediv>
              <refname>CGlomParameters (abstract)</refname>
              <refpurpose>Document event building parameters</refpurpose>
            </refnamediv>
            <refsynopsisdiv>
                <programlisting>
#include &lt;CGlomParameters.h&gt;

class CGlomParameters : public CRingItem
{
public:
    
    typedef enum _TimestampPolicy {
        first = 0, last = 1, average = 2
    } TimestampPolicy;
    
public:
    CGlomParameters(uint64_t interval, bool isBuilding, TimestampPolicy policy);
    
    virtual uint64_t coincidenceTicks() const;
    virtual bool     isBuilding() const;
    virtual TimestampPolicy timestampPolicy() const;

    virtual std::string typeName() const;  
    virtual std::string toString() const;
        
    virtual void* getBodyHeader() const;
    virtual void setBodyHeader(uint64_t timestamp, uint32_t sourceId,
                         uint32_t barrierType = 0);
    

};

                </programlisting>
            </refsynopsisdiv>
            <refsect1>
                     <title>DESCRIPTION</title>
                  <para>
                    NSCLDAQ versions that support event building use this ring item
                    type to allow the event builder to document its event builder
                    settings.  The most important of these is the actual event
                    building coincidence interval.
                  </para>
            </refsect1>
            <refsect1>
                <title>METHODS</title>
                <para>
                    The following public methods are provided.
                </para>
                <variablelist>
                    <varlistentry>
                       <term><constructorsynopsis>
                           <methodname>CGlomParameters</methodname>
                        <methodparam>
                            <type>uint64_t </type><parameter>interval</parameter>
                        </methodparam>
                        <methodparam>
                            <type>bool </type><parameter>isBuilding</parameter>
                        </methodparam>
                        <methodparam>
                            <type>TimestampPolicy </type><parameter>policy</parameter>
                        </methodparam>
                       </constructorsynopsis></term>
                       <listitem>
                           <para>
                            Fully parameterized construction.  <parameter>interval</parameter>
                            is the coincidence interval used to build events from
                            the sorted fragments.  If <parameter>isBuilding</parameter>
                            is false, the output stream is just a stream of single
                            fragment events, regardless of the coincidence interval.
                            This is intended for use in testing only.
                            <parameter>>policy</parameter> is the policy used to derive
                            timestamps of the output event stream from the
                            fragments that compose them.
                            See <literal>DATA TYPES and CONSTANTS</literal>
                            for valid values and their meanings.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual uint64_t </type>
                          <methodname>coincidenceTicks</methodname>
                          <void /> <modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the coincidence interval stored in the object.
                            The units of this value are timestamp ticks.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual bool     </type>
                          <methodname>isBuilding</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the state of the object's building flag.
                            If true, the data are event built. If not the
                            event builder was run in a test mode where
                            each event output consists of a single fragment.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual TimestampPolicy </type>
                          <methodname>timestampPolicy</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the timestamp policy used to derive the
                            timestamp of output events.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual std::string </type>
                          <methodname>typeName</methodname>
                          <void /> <modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns a string that identifies the ring item type:
                            <literal>Glom Parameters</literal>.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual std::string </type>
                          <methodname>toString</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns a stringified representation of the object.
                            Intended for use in e.g. <command>dumper</command>.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void* </type>
                          <methodname>getBodyHeader</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns a pointer to the object's body header.
                            Since glom parameter items dont, at present,
                            have body headers, expect a
                            <literal>nullptr</literal> to be returned.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void </type>
                          <methodname>setBodyHeader</methodname>
                          <methodparam>
                              <type>uint64_t </type><parameter>timestamp</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t sourceId</type><parameter></parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t </type><parameter>barrierType</parameter>
                              <initializer>0</initializer>
                          </methodparam>
                       </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Sets/adds a body header to the item.  Since
                            glom parameter items don't have a body header,
                            this is a no-op.
                           </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </refsect1>
            <refsect1>
                <title>DATA TYPES and CONSTANTS</title>
                <para>
                    The <classname>CGlomParameters</classname> class provides
                    a single data type:  <type>TimestampPolicy</type>.  THe
                    event builder in NSCLDAQ supports hierarchical event building.
                    This means that the output of an event builder can be input
                    for a subsequent event builder in the data acquisition
                    data flow.
                </para>
                <para>
                    This allows detector systems which require an event builder
                    of their own to be run together with other detector systems
                    by simply providing a second level event builder to glue together
                    events from each detector subsystem into coincident events.
                </para>
                <para>
                    This ability for hierarchical event building requires that
                    output events are also given a timestamp.  The
                    <type>TimestampPolicy</type> data type provides a type that
                    specifies how this output timestamp is determined.  It
                    can have the following values:
                </para>
                <variablelist>
                    <varlistentry>
                       <term><literal>first</literal></term>
                       <listitem>
                           <para>
                            The output timestamp is taken from the earliest (first)
                            fragment's timestamp.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><literal>last</literal></term>
                       <listitem>
                           <para>
                            The output timestamp is taken from the latest (last)
                            fragment's timestamp.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><literal>average</literal></term>
                       <listitem>
                           <para>
                            The output timestamp is the average of all timestamps
                            of the fragments that make up the event.
                           </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </refsect1>
        </refentry>
        <refentry>
           <refmeta>
              <refentrytitle>CPhysicsEventItem (abstract)</refentrytitle>
              <manvolnum>3format</manvolnum>
           </refmeta>
           <refnamediv>
              <refname>CPhysicsEventItem (abstract)</refname>
              <refpurpose>Encapsulate the data from a physics trigger.</refpurpose>
            </refnamediv>
            <refsynopsisdiv>
                <programlisting>
#include &lt;CPHysicsEventItem.h&gt;

class CPhysicsEventItem : public CRingItem
{
public:
    CPhysicsEventItem(size_t maxBody=8192);
  
    virtual std::string typeName() const;	// Textual type of item.
    virtual std::string toString() const; // Provide string dump of the item.
    
    virtual void* getBodyHeader() const;
    virtual void setBodyHeader(uint64_t timestamp, uint32_t sourceId,
                         uint32_t barrierType = 0);
  
};
                </programlisting>
            </refsynopsisdiv>
            <refsect1>
                     <title>DESCRIPTION</title>
                  <para>
                    <classname>CPHysicsEventItem</classname> is a ring item that
                    encapsulates data from a physics trigger.  As such, the body
                    of the ring item has no defined format but can be in whatever
                    format best suits the data from the trigger.
                  </para>
                  <para>
                    Note that event built data has a defined format that
                    describes how fragments appear in the event however, again,
                    the fragment payloads do not have a defined format.
                  </para>
            </refsect1>
            <refsect1>
                <title>METHODS</title>
                <variablelist>
                    <varlistentry>
                       <term><constructorsynopsis>
                           <methodname>CPhysicsEventItem</methodname>
                        <methodparam>
                            <type>size_t </type><parameter>maxBody</parameter>
                            <initializer>8192</initializer>
                        </methodparam>
                       </constructorsynopsis></term>
                       <listitem>
                           <para>
                            Constructs an item for a single physics trigger.
                            Note that the storage size is statically allocated
                            with <parameter>maxBody</parameter> bytes of payload
                            data.  The ring item header type field is initialized
                            to <literal>PHYSICS_EVENT</literal>.
                           </para>
                           <para>
                            Upon creating the item normally, if a body header
                            is required, <methodname>setBodyHeader</methodname>
                            is invoked.  <methodname>getBodyCursor</methodname>
                            is then used get a pointer into the object at where
                            the physics data should be put.  After incrementing
                            this pointer by an appopriate amount,
                            calls to <methodname>setBodyCursor</methodname>,
                            folowed by <methodname>updateSize</methodname>
                            are required to set the size field of the
                            ring item header.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual std::string </type>
                          <methodname>typeName</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns a string that represents the ring item type:
                            <literal>Event</literal>
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual std::string </type>
                          <methodname>toString</methodname>
                          <void /> <modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns a string that represents the contents of the
                            event.  This is used, e.g., by the
                            <command>dumper</command> command to render human
                            readable data.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void*</type>
                          <methodname>getBodyHeader</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns a pointer to the body header for the event.
                            If the event has no body header,
                            <literal>nullptr</literal> is returned. Note that
                            the base class <methodname>hasBodyHeader</methodname>
                            can be called to determine if the ring item type has
                            a body header.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void </type>
                          <methodname>setBodyHeader</methodname>
                          <methodparam>
                              <type>uint64_t </type><parameter>timestamp</parameter>
                          </methodparam>
                          <methodparam>
                              <type> uint32_t </type><parameter>sourceId</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t </type><parameter>barrierType </parameter>
                              <initializer>0</initializer>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Inserts a new or modifies an existing body header of the event.
                           </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </refsect1>
        </refentry>
        <refentry>
           <refmeta>
              <refentrytitle>CRingFragmentItem (abstract)</refentrytitle>
              <manvolnum>3format</manvolnum>
           </refmeta>
           <refnamediv>
              <refname>CRingFragmentItem (abstract)</refname>
              <refpurpose>Ring item to encapsulate event builder fragments.</refpurpose>
            </refnamediv>
            <refsynopsisdiv>
                <programlisting>
#include &lt;CRingFragmentItem.h&gt;

class CRingFragmentItem : public CRingItem
{
 

public:
  CRingFragmentItem(uint64_t timestamp, 
		    uint32_t source, 
		    uint32_t payloadSize, 
		    const void* pBody,
		    uint32_t barrier=0);

  virtual uint64_t     timestamp() const;
  virtual uint32_t     source() const;
  virtual size_t       payloadSize() const;
  virtual void*        payloadPointer();
  virtual uint32_t     barrierType() const;

  virtual std::string typeName() const;
  virtual std::string toString() const;
  
  virtual void setBodyHeader(uint64_t timestamp, uint32_t sourceId,
                         uint32_t barrierType = 0) ;
  
  virtual void* getBodyHeader() const;
  virtual bool hasBodyHeader() const;


};
                </programlisting>
            </refsynopsisdiv>
            <refsect1>
                     <title>DESCRIPTION</title>
                  <para>
                    The event builder sort stage can output a set of fragments
                    encapsulated in a ring item. The fragments look like
                    a ringitem header, a body header and an arbitrary payload.
                    The <classname>CRingFragmentItem</classname> represents
                    the items where the payload are established to be ring items
                    (note that the sort stage of the event builder is format
                    agnositic).
                  </para>
            </refsect1>
            <refsect1>
                <title>METHODS</title>
                <variablelist>
                    <varlistentry>
                       <term><constructorsynopsis>
                           <methodname>CRingFragmentItem</methodname>
                        <methodparam>
                            <type>uint64_t </type><parameter>timestamp</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint32_t </type><parameter>source</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint32_t </type><parameter>payloadSize</parameter>
                        </methodparam>
                        <methodparam>
                            <type>const void* </type><parameter>pBody</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint32_t </type><parameter>barrier</parameter>
                            <initializer>0</initializer>
                        </methodparam>
                       </constructorsynopsis></term>
                       <listitem>
                           <para>
                            Constructs the item.  The <parameter>timestamp</parameter>,
                            <parameter>sourcde</parameter> and optional
                            <parameter>barrier</parameter> parameters fill in
                            the body header.  The default value of 0
                            for the <parameter>barrier</parameter> represents a
                            non-barrier event.
                           </para>
                           <para>
                            The payload of the fragment is <parameter>payloadSize</parameter>
                            bytes taken from the data pointed to by <parameter>pBody</parameter>.
                           </para>
                           <para>
                            For this item, type, <parameter>pBody</parameter>
                            is expected to point to a ring item whose
                            header size field is the same as the
                            <parameter>payloadSize</parameter> parameter.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual uint64_t     </type>
                          <methodname>timestamp</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the timestamp from the item's body header.
                            Note that by definition, fragment items have
                            a body header.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual uint32_t     </type>
                          <methodname>source</methodname>
                          <void /><modifier> const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the source id from the item's body header.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual size_t  </type>
                          <methodname>payloadSize</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the size of the payload. Note that it is
                            acceptable, and normal for this to be computed by the
                            implementation from the ring item size and the body
                            header size
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void*        </type>
                          <methodname>payloadPointer</methodname>
                          <void />
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns a pointer to the payload data.  The pointer
                            allows the data to be edited as well as simply
                            inspected.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual uint32_t     </type>
                          <methodname>barrierType</methodname>
                          <void />
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the item's body header barrier type field.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual std::string </type>
                          <methodname>typeName</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns a string that describes the type of the
                            ring item: <literal>Event fragment</literal>
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual std::string </type>
                          <methodname>toString</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns a string representation of the  contents of
                            the ring item. This is used e.g. by
                            <command>dumper</command>
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>irtual void </type>
                          <methodname>setBodyHeader</methodname>
                          <methodparam>
                              <type>uint64_t </type><parameter>timestamp</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t </type><parameter>sourceId</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t </type><parameter>barrierType </parameter>
                              <initializer>0</initializer>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Modifies the contents of the item's body header
                            (this type always has  a body header).
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void* </type>
                          <methodname>getBodyHeader</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns a pointer to the object's body header.
                            Note that the actual shape of the body header
                            depends on the actual data format version.  Normally
                            each data version has an associated
                            <filename>DataFormat.h</filename> header which, among other
                            things defines a <type>BodyHeader</type> type
                            within a namespace specific to the format.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual bool</type>
                          <methodname> hasBodyHeader</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns <literal>true</literal> as this type of ring item
                            always has a body header.
                           </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
                
            </refsect1>
        </refentry>
        <refentry>
           <refmeta>
              <refentrytitle>CRingPhysicsEventCountItem (abstract)</refentrytitle>
              <manvolnum>3format</manvolnum>
           </refmeta>
           <refnamediv>
              <refname>CRingPhysicsEventCountItem (abstract)</refname>
              <refpurpose>Ring Item with trigger counts.</refpurpose>
            </refnamediv>
            <refsynopsisdiv>
                <programlisting>
#include &lt;CRingPhysicsEventCount.h&gt;

class CRingPhysicsEventCountItem : public CRingItem
{

public:
  CRingPhysicsEventCountItem();
  CRingPhysicsEventCountItem(uint64_t count,
			     uint32_t timeOffset, unsigned divisor = 1);
  CRingPhysicsEventCountItem(uint64_t count, 
			     uint32_t timeoffset, 
			     time_t stamp, uint32_t sid, unsigned divisor = 1);

  virtual uint32_t getTimeOffset() const;
  virtual void     setTimeOffset(uint32_t offset);
  virtual float    computeElapsedTime() const;
  virtual uint32_t getTimeDivisor() const;

  virtual time_t   getTimestamp() const;
  virtual void     setTimestamp(time_t stamp);

  virtual uint64_t getEventCount() const;
  virtual void     setEventCount(uint64_t count);
  
  virtual uint32_t getOriginalSourceId() const;

  virtual void setBodyHeader(uint64_t timestamp, uint32_t sourceId,
                         uint32_t barrierType = 0);
  virtual void* getBodyHeader() const; 

  virtual std::string typeName() const;	// Textual type of item.
  virtual std::string toString() const; // Provide string dump of the item.

};
                </programlisting>
            </refsynopsisdiv>
            <refsect1>
                     <title>DESCRIPTION</title>
                  <para>
                    Online analysis software often samples data in order to
                    avoid being the throughput bottleneck. It is useful for such
                    software to be able to compute the fraction of the actual
                    data it has analyzed.  This ring item provides the number
                    of physics triggers (<classname>CPHysicsEventItem</classname>
                    objects) that have been emitted by a readout (or the event builder)
                    at some point in time. By counting the number of physics
                    triggers processe and dividing by the number of actual
                    triggers, the fraction of data analyzed  can be computed.
                  </para>
            </refsect1>
            <refsect1>
                <title>METHODS</title>
                <variablelist>
                    <varlistentry>
                       <term><constructorsynopsis>
                           <methodname>CRingPhysicsEventCountItem</methodname>
                        <void />
                       </constructorsynopsis></term>
                       <listitem>
                           <para>
                            Constructs an event count item with a count of zero,
                            run time offset of zero and timestamp of the time
                            the constructor was invoked.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><constructorsynopsis>
                           <methodname>CRingPhysicsEventCountItem</methodname>
                        <methodparam>
                            <type>uint64_t </type><parameter>count</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint32_t </type><parameter>timeOffset</parameter>
                        </methodparam>
                        <methodparam>
                            <type>unsigned </type><parameter>divisor</parameter>
                        </methodparam>
                       </constructorsynopsis></term>
                       <listitem>
                           <para>
                            Creates an event count item where the trigger
                            count is initialized to <parameter>count</parameter>.
                            The run offset is given by <parameter>timeOffset</parameter>
                            with <parameter>divisor</parameter> ticks per second.
                            The clock time is set to the construction time of
                            the object.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><constructorsynopsis>
                           <methodname>CRingPhysicsEventCountItem</methodname>
                        <methodparam>
                            <type>uint64_t </type><parameter>count</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint32_t </type><parameter>timeoffset</parameter>
                        </methodparam>
                        <methodparam>
                            <type>time_t </type><parameter>stamp</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint32_t </type><parameter>sid</parameter>
                        </methodparam>
                        <methodparam>
                            <type> unsigned </type><parameter>divisor</parameter>
                            <initializer>1</initializer>
                        </methodparam>
                       </constructorsynopsis></term>
                       <listitem>
                           <para>
                            Full construction of a physics event count item
                            with a prototypical body header.  The additional
                            parameter from the previous constructor are
                            <parameter>stamp</parameter>, which provides
                            the clock time at which the item was constructed and
                            <parameter>sid</parameter> which provides the source
                            id for the original source id field (if any) of the
                            item.  
                           </para>
                           <para>
                            The original source id allows analysis programs to
                            track the originating data source for this item.
                            Note that the constructor does not produce a
                            body  header but one can be added with
                            <methodname>setBodyHeader</methodname>.
                            
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual uint32_t </type>
                          <methodname>getTimeOffset</methodname>
                          <void /> <modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the raw time offset into the run at which
                            this item was created.  Note that
                            <methodname>computeElapsedTime</methodname> is the
                            preferred method to get the elapsed run time.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void     </type>
                          <methodname>setTimeOffset</methodname>
                          <methodparam>
                              <type>uint32_t</type><parameter> offset</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Sets the object's raw run time offset.  This
                            offset is uncorrected by the offset divisor.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual float    </type>
                          <methodname>computeElapsedTime</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Computes the elapsed time in the run at which this
                            was emitted from the raw offset and the divisor.
                            Units are seconds.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual uint32_t </type>
                          <methodname>getTimeDivisor</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the number of ticks in a second in the
                            elapsed time raw value.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type> virtual time_t   </type>
                          <methodname>getTimestamp</methodname>
                          <void />
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Return the clock time associated with the item.
                           </para>
                        </listitem>
                    </varlistentry>
                   <varlistentry>
                      <term><methodsynopsis>
                         <type>virtual void     </type>
                         <methodname>setTimestamp</methodname>
                         <methodparam>
                             <type>time_t </type><parameter>stamp</parameter>
                         </methodparam>
                      </methodsynopsis></term>
                      <listitem>
                          <para>
                            Sets the clock time associated with the item.
                       </para>
                    </listitem>
                   </varlistentry>
                   <varlistentry>
                      <term><methodsynopsis>
                         <type>virtual uint64_t </type>
                         <methodname>getEventCount</methodname>
                         <void /><modifier>const</modifier>
                      </methodsynopsis></term>
                      <listitem>
                          <para>
                            Return the number of triggers documented by this
                            item.
                       </para>
                    </listitem>
                   </varlistentry>
                   <varlistentry>
                      <term><methodsynopsis>
                         <type>virtual void     </type>
                         <methodname>setEventCount</methodname>
                         <methodparam>
                             <type>uint64_t </type><parameter>count</parameter>
                         </methodparam>
                      </methodsynopsis></term>
                      <listitem>
                          <para>
                            sets the item's trigger count.
                       </para>
                    </listitem>
                   </varlistentry>
                   <varlistentry>
                      <term><methodsynopsis>
                         <type>virtual uint32_t </type>
                         <methodname>getOriginalSourceId</methodname>
                         <void /><modifier> const</modifier>
                      </methodsynopsis></term>
                      <listitem>
                          <para>
                            Returns the source id of the data source that emitted
                            this object.
                       </para>
                    </listitem>
                   </varlistentry>
                   <varlistentry>
                      <term>
                        <methodsynopsis>
                           <type>irtual std::string </type>
                           <methodname>typeName</methodname>
                           <void /><modifier>const</modifier>
                        </methodsynopsis>
                      </term>
                      <listitem>
                          <para>
                            Returns a string indicating the type of ring item
                            this object is:  <literal>Trigger count</literal>
                       </para>
                    </listitem>
                   </varlistentry>
                   <varlistentry>
                      <term><methodsynopsis>
                         <type>virtual std::string </type>
                         <methodname>toString</methodname>
                         <void /><modifier>const</modifier>
                      </methodsynopsis></term>
                      <listitem>
                          <para>
                            Return  a string that describes the contents of the
                            item.  This is used by, e.g. <command>dumper</command>
                       </para>
                    </listitem>
                   </varlistentry>
                   <varlistentry>
                      <term><methodsynopsis>
                         <type>virtual void </type>
                         <methodname>setBodyHeader</methodname>
                         <methodparam>
                             <type>uint64_t </type><parameter>timestamp</parameter>
                         </methodparam>
                         <methodparam>
                             <type>uint32_t </type><parameter>sourceId</parameter>
                         </methodparam>
                         <methodparam>
                             <type>uint32_t </type><parameter>barrierType </parameter>
                             <initializer>0</initializer>
                         </methodparam>
                      </methodsynopsis></term>
                      <listitem>
                          <para>
                            Adds a new body header or modifies the contents of the
                            existing body header.
                       </para>
                    </listitem>
                   </varlistentry>
                   <varlistentry>
                      <term><methodsynopsis>
                         <type>virtual void* </type>
                         <methodname>getBodyHeader</methodname>
                         <void /><modifier>const</modifier>
                      </methodsynopsis></term>
                      <listitem>
                          <para>
                            Returns a pointer to the body header or
                            <literal>nullptr</literal> if the object has no
                            body header.
                       </para>
                    </listitem>
                   </varlistentry>
                </variablelist>
            </refsect1>
            
        </refentry>
        <refentry>
           <refmeta>
              <refentrytitle>CRingScalerItem (abstract)</refentrytitle>
              <manvolnum>3format</manvolnum>
           </refmeta>
           <refnamediv>
              <refname>CRingScalerItem (abstract)</refname>
              <refpurpose>Encapsulate periodic scaler readouts.</refpurpose>
            </refnamediv>
            <refsynopsisdiv>
                <programlisting>
#include &lt;CRingScalerItem.h&gt;

class CRingScalerItem : public CRingItem
{
public:
  static uint32_t m_ScalerFormatMask;

public:
  CRingScalerItem(size_t numScalers);
  CRingScalerItem(uint32_t startTime,
		  uint32_t stopTime,
		  time_t   timestamp,
		  std::vector&lt;uint32_t&gt; scalers,
                  bool                  isIncremental = true,
                  uint32_t              sid = 0,
                  uint32_t              timeOffsetDivisor = 1);


  virtual void     setStartTime(uint32_t startTime);
  virtual uint32_t getStartTime() const;
  virtual float    computeStartTime() const;
  
  virtual void     setEndTime(uint32_t endTime);
  virtual uint32_t getEndTime() const;
  virtual float    computeEndTime() const;

  virtual uint32_t getTimeDivisor() const;

  virtual void     setTimestamp(time_t stamp);
  virtual time_t   getTimestamp() const;
  
  virtual bool isIncremental() const;

  virtual void     setScaler(uint32_t channel, uint32_t value) ;
  virtual uint32_t getScaler(uint32_t channel) const ;
  virtual std::vector&lt;uint32_t&gt; getScalers() const;

  virtual uint32_t getScalerCount() const;
  virtual uint32_t getOriginalSourceId() const;

  virtual void* getBodyHeader() const;
  virtual void setBodyHeader(
      uint64_t timestamp, uint32_t sourceId,
      uint32_t barrierType = 0
  );
  virtual std::string typeName() const;
  virtual std::string toString() const;

};
   


                </programlisting>
            </refsynopsisdiv>
            <refsect1>
                     <title>DESCRIPTION</title>
                  <para>
                    Most NSCLDAQ readout frameworks have the ability to periodically
                    read a set of counters or <firstterm>scalers</firstterm>.
                    These counters are passed up the data flow as
                    <classname>CRingScalerItem</classname> objects.
                  </para>
                  <para>
                    In version 10, there were a pair of underlying ring item types,
                    one for incremental and a second for non-incremental, high
                    time resolution items.  In versino 11+, these were
                    combined into a single periodic scaler item.
                  </para>
                  <para>
                    The <classname>CRingScalerItem</classname> class, provides
                    interfaces that can front-end any of the underlying scaler
                    ring items.
                  </para>
                  <para>
                    A complication for older readouts that use CAMAC scalers are
                    devices that readout 24 bits of data but whose controllers
                    set information in the top bits.   The
                    <varname>m_scalerFormatMask</varname> provides a mask
                    that is bit-wise anded with scaler values before those
                    values are returned to the user.  This mask is initialized
                    by all constructors
                    to <literal>0xffffffff</literal>, suitable for 32bit
                    scalers.  This member value is public and therefore can be
                    set to e.g.<literal>0xffffff</literal> in the event the scalers
                    are actually 24 bits wide.
                  </para>
            </refsect1>
            <refsect1>
                <title>METHODS</title>
                <variablelist>
                    <varlistentry>
                       <term><constructorsynopsis>
                           <methodname>CRingScalerItem</methodname>
                        <methodparam>
                            <type>size_t </type><parameter>numScalers</parameter>
                        </methodparam>
                       </constructorsynopsis></term>
                       <listitem>
                           <para>
                            Constructs a scaler item large enough to hold
                            <parameter>numScalers</parameter> 32 bit scaler counters.
                            The start/stop time offsets are both set to
                            <literal>0</literal> as are the scaler values.
                            The time divisor is initialized to <literal>1</literal>
                            and the clock time is set to the time at which
                            the item was constructed.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><constructorsynopsis>
                           <methodname>CRingScalerItem</methodname>
                        <methodparam>
                            <type>uint32_t </type><parameter>startTime</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint32_t </type><parameter>stopTime,</parameter>
                        </methodparam>
                        <methodparam>
                            <type>time_t   </type><parameter>timestamp</parameter>
                        </methodparam>
                        <methodparam>
                            <type>std::vector&lt;uint32_t&gt; </type><parameter>scalers,</parameter>
                        </methodparam>
                        <methodparam>
                            <type>bool </type><parameter>isIncremental</parameter>
                            <initializer>true</initializer>
                        </methodparam>
                        <methodparam>
                            <type>uint32_t </type><parameter>sid</parameter>
                            <initializer>0</initializer>
                        </methodparam>
                        <methodparam>
                            <type>uint32_t  </type><parameter>timeOffsetDivisor</parameter>
                            <initializer>1</initializer>
                        </methodparam>
                       </constructorsynopsis></term>
                       <listitem>
                           <para>
                            Fully constructs a scaler item.  The scaler values
                            are passed in via the <parameter>scalers</parameter>
                            parameter.  The size of that vector determines
                            the number of scalers the item will hold.
                           </para>
                           <para>
                            The interval start and stop offsets are given
                            by <parameter>startTime</parameter> and
                            <parameter>stopTime</parameter> respecively.
                            The optional <parameter>timeOffsetDivisor</parameter>
                            parameter provides the number of ticks in these
                            offset values per second providing support for
                            sub-second time resolution.
                           </para>
                           <para>
                            THe clock time is provided by
                            <parameter>timestamp</parameter>.
                           </para>
                           <para>
                            If <parameter>isIncremental</parameter> is false,
                            the counts are assumed to accumulate for the length
                            of the run.  Otherwise the counts in the scalers are
                            assumed to represent the counts over the interval
                            defined by <parameter>startTime</parameter>
                            through <parameter>stopTime</parameter>.
                           </para>
                           <para>
                            Beginning with the 12.0 data format, the
                            scaler bodies contain a field to retain the source id
                            of the data source tha originally created the item.
                            This is important because event builders overwrite
                            the source id of scaler items.  This field is
                            initialized with the value of the
                            <parameter>sid</parameter> parameter.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void     </type>
                          <methodname>setStartTime</methodname>
                          <methodparam>
                              <type>uint32_t </type><parameter>startTime</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Sets the offset into the run at which the scaler counting
                            interval began.
        
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual uint32_t</type>
                          <methodname> getStartTime() </methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the offset into the run at which the
                            scaler counting began.  See next method, however.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual float    </type>
                          <methodname>computeStartTime</methodname>
                          <void />
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Uses the scaler interval start offset and the
                            counting divisor to compute the start time offset
                            in seconds.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void     </type>
                          <methodname>setEndTime</methodname>
                          <methodparam>
                              <type>uint32_t </type><parameter>endTime</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Sets the offset into the run of the end of the
                            scaler counting interval
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual uint32_t </type>
                          <methodname>getEndTime</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the offset into the run at which the scaler
                            counting interval ended.  See, however the next
                            method.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual float    </type>
                          <methodname>computeEndTime</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Using the end offset and the offset divisor computes
                            and returns the number of seconds into the run at
                            which the scaler counting interval ended.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual uint32_t </type>
                          <methodname>getTimeDivisor</methodname>
                          <void /> <modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the number of ticks in the start and end
                            time offsets that correspond to a second.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void     </type>
                          <methodname>setTimestamp</methodname>
                          <methodparam>
                              <type>time_t </type><parameter>stamp</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Sets the clock time associated with the item
                            to be <parameter>stamp</parameter>.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual time_t   </type>
                          <methodname>getTimestamp</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the clock time associated with the item.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual bool </type>
                          <methodname>isIncremental</methodname>
                          <void />
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            If the scalers are cleared after each read, this
                            returns <literal>true</literal>, if they are allowed
                            to accumulate across counting intervales, this returns
                            <literal>false</literal>
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void     </type>
                          <methodname>setScaler</methodname>
                          <methodparam>
                              <type>uint32_t </type><parameter>channel</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t </type><parameter>value</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Sets the counts for the scaler  selected by
                            <parameter>channel</parameter> to
                            <parameter>value</parameter>. If <parameter>channel</parameter>
                            is out of range an <classname>std::out_of_range</classname>
                            exception is thrown.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual uint32_t </type>
                          <methodname>getScaler</methodname>
                          <methodparam>
                              <type>uint32_t </type><parameter>channel</parameter>
                          </methodparam>
                          <modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returs the value of the scaler selected by
                            <parameter>channel</parameter>.  If
                            <parameter>channel</parameter> is out of range a
                            <classname>std::out_of_range</classname>
                            exception is thrown.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual std::vector&lt;uint32_t&gt; </type>
                          <methodname>getScalers</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns a vector containing the values of the scaler
                            counts in the item.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual uint32_t </type>
                          <methodname>getScalerCount</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the number of scalers in the item.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type> virtual uint32_t </type>
                          <methodname>getOriginalSourceId</methodname>
                          <void /><modifier> const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the original source id field from the item.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void* </type>
                          <methodname>getBodyHeader</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns a pointer to the item's body header
                            or <literal>nullptr</literal> if it does not have one.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void </type>
                          <methodname>setBodyHeader</methodname>
                          <methodparam>
                              <type>   uint64_t </type><parameter>timestamp</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t </type><parameter>sourceId</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t </type><parameter>barrierType</parameter>
                              <initializer>0</initializer>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Sets new values for the body header of the item
                            if it already has one or creates a new one if it does not.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual std::string </type>
                          <methodname>typeName</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns a string that identifies the type of the item:
                            <literal>Scaler</literal>
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual std::string </type>
                          <methodname>toString</methodname>
                          <void /> <modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns a string tha details the contents of the
                            item.  This is used by e.g. <command>dumper</command>
                            to produce a formated dump of a stream of ring items.
                           </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </refsect1>
        </refentry>
        <refentry>
           <refmeta>
              <refentrytitle>CRingStateChangeItem (abstract)</refentrytitle>
              <manvolnum>3format</manvolnum>
           </refmeta>
           <refnamediv>
              <refname>CRingStateChangeItem (abstract)</refname>
              <refpurpose>Encapsulate run state change items.</refpurpose>
            </refnamediv>
            <refsynopsisdiv>
                <programlisting>
#include &lt;CRingStateChangeItem.h&gt;

class CRingStateChangeItem : public CRingItem
{


public:
  CRingStateChangeItem(uint16_t reason = BEGIN_RUN);
  CRingStateChangeItem(uint16_t reason,
		       uint32_t runNumber,
		       uint32_t timeOffset,
		       time_t   timestamp,
		       std::string title) ;
  

  virtual void setRunNumber(uint32_t run);
  virtual uint32_t getRunNumber() const;

  virtual void setElapsedTime(uint32_t offset);
  virtual uint32_t getElapsedTime() const;
  virtual uint32_t getTimeDivisor() const;
  virtual float    computeElapsedTime() const;

  virtual void setTitle(std::string title) ;
  virtual std::string getTitle() const;

  virtual void setTimestamp(time_t stamp);
  virtual time_t getTimestamp() const;
  virtual uint32_t getOriginalSourceId() const;

  virtual void* getBodyHeader() const;
  virtual void setBodyHeader(uint64_t timestamp, uint32_t sourceId,
                         uint32_t barrierType = 0);
  virtual std::string typeName() const;
  virtual std::string toString() const;

};

                </programlisting>
            </refsynopsisdiv>
            <refsect1>
                     <title>DESCRIPTION</title>
                  <para>
                    When the data acquisition system changes state, in a way that
                    can affect data taking, readers produce a state change item
                    so that this information can be documented in the data flow
                    and recorded to disk in the associated event file.
                  </para>
                  <para>
                    Thd <classname>CRingStateChange</classname> item encapsulates
                    such ring items.  Note that as of NSCLDAQ version 12, there
                    are four possible state change items, <literal>BEGIN_RUN</literal>,
                    <literal>PAUSE_RUN</literal>, <literal>RESUME_RUN</literal>
                    and <literal>END_RUN</literal>.  Note that not all readers
                    support pausing a run and the paused state will likely be
                    deprecated and phased out.
                  </para>
                  <para>
                    The definitions for these ring items types are in the
                    <filename>DataFormat.h</filename> header for the appropriate
                    data format or the abstract version of this file.  These
                    defintions should be considered stable.
                  </para>
            </refsect1>
            <refsect1>
                <title>METHODS</title>
                <variablelist>
                    <varlistentry>
                       <term><constructorsynopsis>
                           <methodname>CRingStateChangeItem</methodname>
                        <methodparam>
                            <type>uint16_t </type><parameter>reason </parameter>
                            <initializer>BEGIN_RUN</initializer>
                        </methodparam>
                       </constructorsynopsis></term>
                       <listitem>
                           <para>
                            Creates a state change item for the specified state
                            change type.  The offset time is set to zero, which is
                            appropriate for a begin run, the clock time stamp is
                            set to the current time.  The run number is also set
                            to zero.  The title is set to an empty string.
                            Other version specific initialization may occur.
                           </para>
                           <para>
                            If the format supports body headers and they are optionsal,
                            this construction will create an item without a body
                            header.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><constructorsynopsis>
                           <methodname> CRingStateChangeItem</methodname>
                        <methodparam>
                            <type>uint16_t </type><parameter>reason</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint32_t </type><parameter>runNumber</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint32_t timeOffset</type><parameter></parameter>
                        </methodparam>
                        <methodparam>
                            <type>time_t   </type><parameter>timestamp</parameter>
                        </methodparam>
                        <methodparam>
                            <type>std::string </type><parameter>title</parameter>
                        </methodparam>
                       </constructorsynopsis></term>
                       <listitem>
                           <para>
                            Full construction of a state change item.  The
                            <parameter>reason</parameter> is the type of state change
                            item as listed in <literal>DESCRIPTION</literal>.
                            <parameter>runNumber</parameter> us the number of the
                            run undergoing the transition.  <parameter>timeOffset</parameter>
                            is the offset into the run at which the transition occured.
                            This should always be <literal>0</literal> for
                            <literal>BEGIN_RUN</literal> transitions.
                            
                           </para>
                           <para>
                            <parameter>timestamp</parameter> is the clock time
                            at which the transition occured.   This is the output
                            of the unix <function>time</function> function.
                           </para>
                           <para>
                            Finally, <parameter>title</parameter> is the run's title.
                            This should be the same string for all transitions
                            within a run.   Note that there is a maximum
                            length to titles defined in
                            <filename>DataFormat.h</filename> with the symble
                            <literal>TITLE_MAXSIZE</literal>. Title strings longer
                            than that should be silently truncated by the
                            version's implementation.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void </type>
                          <methodname>setRunNumber</methodname>
                          <methodparam>
                              <type>uint32_t</type><parameter> run</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Modifies the item's run number.   This is most often
                            used when the minimal constructor is used to
                            create the item.  In that case, various methods
                            are used to fill in actual values of the fields.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual uint32_t </type>
                          <methodname>getRunNumber</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Return the run number from the state change ring item
                            encapsulated in the object.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void </type>
                          <methodname>setElapsedTime</methodname>
                          <methodparam>
                              <type>uint32_t </type><parameter>offset</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Sets the raw time offset of the state change item.
                            The offset says when in the timespan of the run
                            the state change occured.  It is zero at the beginning
                            of the run.  No attempt is made to synchronize this time
                            offset between several data sources.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual uint32_t </type>
                          <methodname>getElapsedTime</methodname>
                          <void />
                          <modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the raw time offset stored in the event.  This
                            is the time offset in to the run at which the state change
                            occured. Note that the time divisor (see below) represents
                            the numbver of ticks in the offset in a second.
                           </para>
                           <para>
                            It's usually preferrable to get the offset in seconds
                            using <methodname>computeElapedTime</methodname>.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual uint32_t </type>
                          <methodname>getTimeDivisor</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the time divisor.  This value represents the
                            number of ticks of time offset in a second.
                            Note that at present, all constructors initialize
                            this to <literal>1</literal> and there is no mechanism
                            to modify the divisor.  Later releases may provide
                            such a mechanism.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual float </type>
                          <methodname>computeElapsedTime</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Computes the time offset stored in the item in
                            seconds.  This is the preferred method to get the
                            time offset in the presence of the capability
                            for divisors that are greater than 1.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void </type>
                          <methodname>setTitle</methodname>
                          <methodparam>
                              <type>std::string </type><parameter>title</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Sets the title of the run for the state transition
                            item.  The state transition items that belong to the
                            same run should have the same title.  Note that
                            there is a maximum title length and implementations
                            should silently truncate any title longer than that.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual std::string </type>
                          <methodname>getTitle</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the value of the title string for the
                            transition object.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void </type>
                          <methodname>setTimestamp</methodname>
                          <methodparam>
                              <type>time_t </type><parameter>stamp</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Sets a clock times associted with the item.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual time_t </type>
                          <methodname>getTimestamp</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Return the clock time associated with the
                            item.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term>
                            <methodsynopsis>
                               <type>virtual uint32_t</type>
                               <methodname> getOriginalSourceId</methodname>
                               <void /><modifier>const</modifier>
                            </methodsynopsis>
                       </term>
                       <listitem>
                           <para>
                            Returns the original source id of the item.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void* </type>
                          <methodname>getBodyHeader</methodname>
                          <void /> <modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns a pointer to the object's body header.
                            If the object has no body header
                            <literal>nullptr</literal> is returned.  The
                            actual format of the body header
                            <emphasis>may</emphasis> vary from version to version.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void </type>
                          <methodname>setBodyHeader</methodname>
                          <methodparam>
                              <type>uint64_t </type><parameter>timestamp</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t </type><parameter>sourceId</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t </type><parameter>barrierType </parameter>
                              <initializer>0</initializer>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            IF the version supports it, either add or modify an
                            existing body header in the object.  If the version
                            does not support body headers, the method should do
                            nothing.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual std::string </type>
                          <methodname>typeName</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns a string that identifies the type of the object.
                            Note that the type is a fine grained concept.
                            For examle, if the type is
                            <literal>BEGIN_RUN</literal>,
                            this method returns <literal>Begin Run</literal>.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual std::string</type>
                          <methodname>toString</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns a string that describes the contents of the
                            item.  This is used by e.g.
                            <command>dumper</command> to emit formatted
                            ring items.
                           </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </refsect1>
        </refentry>
        <refentry>
           <refmeta>
              <refentrytitle>CRingTextItem (abstract)</refentrytitle>
              <manvolnum>3format</manvolnum>
           </refmeta>
           <refnamediv>
              <refname>CRingTextItem (abstract)</refname>
              <refpurpose>Encapsulate a ring item of text strings</refpurpose>
            </refnamediv>
            <refsynopsisdiv>
                <programlisting>
#include &lt;CRingTextItem.h&gt;


class CRingTextItem : public CRingItem
{
public:

  CRingTextItem(uint16_t type, size_t maxsize);
  CRingTextItem(uint16_t type,
		std::vector&lt;std::string&gt; theStrings);
  CRingTextItem(uint16_t type,
		std::vector&lt;std::string&gt; theStrings,
		uint32_t                 offsetTime,
		time_t                   timestamp, uint32_t divisor=1) ;
  
  virtual std::vector&lt;std::string&gt;  getStrings() const;

  virtual void     setTimeOffset(uint32_t offset);
  virtual uint32_t getTimeOffset() const;
  virtual float    computeElapsedTime() const;
  virtual uint32_t getTimeDivisor() const;

  virtual void     setTimestamp(time_t stamp);
  virtual time_t   getTimestamp() const;
  virtual uint32_t getOriginalSourceId() const;
  
  virtual void* getBodyHeader() const;
  virtual void setBodyHeader(
        uint64_t timestamp, uint32_t sid, uint32_t barrierType= 0
  );
  virtual std::string typeName() const;
  virtual std::string toString() const;
  
};

                </programlisting>
            </refsynopsisdiv>
            <refsect1>
                     <title>DESCRIPTION</title>
                  <para>
                    Several types of ring items contain lists of strings.
                    The strings are stored as a block of null terminated strings.
                    A field in the ring item contains the number of strings.k
                  </para>
                  <para>
                    The following item types (defined in <filename>DataFormat.h</filename>)
                    are valid text item types:
                 </para>
                  <variablelist>
                    <varlistentry>
                       <term><literal>PACKET_TYPES</literal></term>
                       <listitem>
                           <para>
                            The SBS readout framework can use this to provide
                            a dictionary of packet types that can be seen
                            within a <literal>PHYSICS_EVENT</literal>
                            item body.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><literal>MOINTORED_VARIABLES</literal></term>
                       <listitem>
                           <para>
                            The readout frameworks based on the Tcl command
                            language support monitoring a set of internal
                            variables.  This coupled with an EPICS client
                            provides the means to incorporate EPICS data in
                            event files.  Other possible uses for this
                            can be conceived.
                           </para>
                           <para>
                            The strings in this case are a set of script commands
                            that, when run, restore the Tcl variables monitored to
                            their values at that time in the run.
                           </para>
                        </listitem>
                    </varlistentry>
                  </variablelist>
            </refsect1>
            <refsect1>
                <title>METHODS</title>
                <variablelist>
                    <varlistentry>
                       <term><constructorsynopsis>
                           <methodname>CRingTextItem</methodname>
                        <methodparam>
                            <type>uint16_t </type><parameter>type</parameter>
                        </methodparam>
                        <methodparam>
                            <type>size_t </type><parameter>maxsize</parameter>
                        </methodparam>
                       </constructorsynopsis></term>
                       <listitem>
                           <para>
                            Constructor.  <parameter>type</parameter> is the item
                            type and <parameter>maxsize</parameter> sets a
                            limit on the ring item size.  Note that if you
                            already know the set of strings to put in the item,
                            it's better to use a consructor that takes them
                             as a parameter as then the actual maximum size
                             can be computed.
                           </para>
                           <para>
                            The string count for the item is initialized to zero.
                            The run offset is also initialized to zero as is the
                            original source id.  The clock time is initialized to the
                            current time.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><constructorsynopsis>
                           <methodname> CRingTextItem(</methodname>
                        <methodparam>
                            <type>uint16_t </type><parameter>type</parameter>
                        </methodparam>
                        <methodparam>
                            <type>std::vector&lt;std::string&gt; </type><parameter>theStrings</parameter>
                        </methodparam>
                       </constructorsynopsis></term>
                       <listitem>
                           <para>
                            In this constructor, <parameter>theStrings</parameter>
                            is used to compute the required item size.  The
                            strings are set into the item's string pool
                            as null terminated strings and the string count
                            is set to <literal>theStrings.size()</literal>.
                            The offset, original source id, and clock time are
                            initialized as in the previous constructor.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><constructorsynopsis>
                           <methodname>CRingTextItem</methodname>
                        <methodparam>
                            <type>uint16_t </type><parameter>type</parameter>
                        </methodparam>
                        <methodparam>
                            <type>std::vector&lt;std::string&gt;</type><parameter> theStrings</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint32_t  </type><parameter>offsetTime</parameter>
                        </methodparam>
                        <methodparam>
                            <type>time_t </type><parameter>timestamp</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint32_t </type><parameter>divisor</parameter>
                            <initializer>1</initializer>
                        </methodparam>
                       </constructorsynopsis></term>
                       <listitem>
                           <para>
                            Fully parameterized constructor.  This constructor
                            adds <parameter>offsetTime</parameter> to set the
                            time  offset in the run at which the item was emitted,
                            <parameter>timestamp</parameter> which allows the
                            clock time the item was emitted to be expclicitly
                            specified and <parameter>divisor</parameter>
                            (optional, defaults to 1) which indicates the number
                            of ticks of <parameter>offsetTime</parameter> in
                            a second.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual std::vector&lt;std::string&gt;</type>
                          <methodname> getStrings</methodname>
                          <void /><modifier> const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns a vector that contains the text strings in the
                            object's payload.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void     </type>
                          <methodname>setTimeOffset</methodname>
                          <methodparam>
                              <type>uint32_t </type><parameter>offset</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Set the offset into the run at which this object was
                            emitted.  Note that this, together with the time divisor
                            determine the number of seconds into the run the
                            object was emitted.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual uint32_t </type>
                          <methodname>getTimeOffset</methodname>
                          <void /> <modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the raw time offset. Note that calling
                            <methodname>computeElapsedTime</methodname>
                            is the perferred method to call to get the run time
                            offset in seconds.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual float</type>
                          <methodname>computeElapsedTime</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Return the elapsed time in the run at which this
                            item was emitted, in seconds.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual uint32_t </type>
                          <methodname>getTimeDivisor</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Return the number of offset ticks per second.  
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void </type>
                          <methodname>setTimestamp</methodname>
                          <methodparam>
                              <type>time_t </type><parameter>stamp</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Sets the clock time at which the item was emitted.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual time_t  </type>
                          <methodname> getTimestamp</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns the clock time associated with the item.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual uint32_t </type>
                          <methodname>getOriginalSourceId</methodname>
                          <void /><modifier> const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            return the item's original source id.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>irtual void* </type>
                          <methodname>getBodyHeader</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            If the item has a body header, this returns a pointer
                            to it.  Otherwise, <literal>nullptr</literal>
                            is returned.  Note that the structure of the body
                            header depends on the format version.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual void </type>
                          <methodname>setBodyHeader</methodname>
                          <methodparam>
                              <type>uint64_t </type><parameter>timestamp</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t </type><parameter>sid</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t </type><parameter>barrierType</parameter>
                              <initializer>0</initializer>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            If the item has a body header it is modified as indicated
                            by the parameters.  IF not, one is created and filled in
                            as indicated by the parameters.  If the data format
                            does not support body headers, this method should
                            be a no-op.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type> virtual std::string </type>
                          <methodname>typeName</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns a string that identifies the item type.  This
                            will be one of <literal>Packet types</literal> or
                            <literal>Monitored Variables</literal>
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual std::string </type>
                          <methodname>toString</methodname>
                          <void /><modifier>const</modifier>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Returns a string that describes the contents of
                            the item in human readable form.
                           </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </refsect1>
        </refentry>
        <refentry>
           <refmeta>
              <refentrytitle>CUnknownFragment (abstract)</refentrytitle>
              <manvolnum>3format</manvolnum>
           </refmeta>
           <refnamediv>
              <refname>CUnknownFragment (abstract)</refname>
              <refpurpose></refpurpose>
            </refnamediv>
            <refsynopsisdiv>
                <programlisting>
#include &lt;CUnknownFragment.h&gt;

class CUnknownFragment : public CRingFragmentItem
{
    
public:
    CUnknownFragment(uint64_t timestamp, uint32_t sourceid, uint32_t barrier,
                     uint32_t size, void* pPayload);

    std::string typeName() const;
    
};
                </programlisting>
            </refsynopsisdiv>
            <refsect1>
                     <title>DESCRIPTION</title>
                  <para>
                       This is identical to <classname>CRingFragmentItem</classname>
                       however the payload is known not to be a ring item.
                       The type is <literal>EVB_UNKNOWN_PAYLOAD</literal>
                  </para>
            </refsect1>
        </refentry>
       </section>
       <section>
        <title>NSCLDAQ version 10 format</title>
        <para>
            Version 10 of NSCLDAQ is the earliest version of NSCLDAQ that used
            ringbuffers and ring items for data flow.  As  such, its data
            format is the most primitive.  Version 10 does not support body headers.
            Event building in NSCLDAQ 10  motivated the addition of body headers
            in later versions.  
        </para>
        <para>
            The version 10 headers are in the v10 subdirectory of the installation
            headers.  Furthermore all classes and definitions live in the
            <literal>v10</literal> namespace.  The <filename>v10/DataFormat.h</filename>
            header provides formatting data and structs for the NSCLDAQ version
            10 internals.
        </para>
        <refentry>
           <refmeta>
              <refentrytitle>RingItemFactory (version 10)</refentrytitle>
              <manvolnum>3format</manvolnum>
           </refmeta>
           <refnamediv>
              <refname>RingItemFactory (verson 10)</refname>
              <refpurpose>Generate v10 ring item objects.</refpurpose>
            </refnamediv>
            <refsynopsisdiv>
                <programlisting>
#include &lt;v10/RingItemFactory.h&gt;

namespace v10 {
    
    class RingItemFactory : public RingItemFactoryBase {
    public:
        
        ::CRingItem* makeRingItem(uint16_t type, size_t maxBody);
        ::CRingItem* makeRingItem(uint16_t type, uint64_t timestamp, uint32_t sourceId,
                size_t maxBody, uint32_t barrierType = 0 );
        ::CRingItem* makeRingItem(const ::CRingItem&amp; rhs);
        ::CRingItem* makeRingItem(const RingItem* pRawRing);
        
        virtual CRingItem* getRingItem(CRingBuffer&amp; ringbuf) ;
        virtual CRingItem* getRingItem(int fd) ;
        virtual CRingItem* getRingItem(std::istream&amp; in);
        
        virtual std::ostream&amp; putRingItem(const CRingItem* pItem, std::ostream&amp; out) ;
        virtual void putRingItem(const CRingItem* pItem, int fd) ;
        virtual void putRingItem(const CRingItem* pItem, CRingBuffer&amp; ringbuf) ;
        
        
        virtual CAbnormalEndItem* makeAbnormalEndItem() ;
        virtual CAbnormalEndItem* makeAbnormalEndItem(const CRingItem&amp; rhs) ;
        
    
        virtual CDataFormatItem* makeDataFormatItem() ;
        virtual CDataFormatItem* makeDataFormatItem(const CRingItem&amp; rhs);
        
        
        virtual CGlomParameters* makeGlomParameters(
            uint64_t interval, bool isBuilding, uint16_t policy
        );
        virtual CGlomParameters* makeGlomParameters(const CRingItem&amp; rhs) ;
        
        
        virtual CPhysicsEventItem* makePhysicsEventItem(size_t maxBody) ;
        virtual CPhysicsEventItem* makePhysicsEventItem(
            uint64_t timestamp, uint32_t source, uint32_t barrier,
            size_t maxBody
        ) ;
        virtual CPhysicsEventItem* makePhysicsEventItem(const CRingItem&amp; rhs) ;
        
        
        virtual CRingFragmentItem* makeRingFragmentItem(
            uint64_t timestamp, uint32_t source, uint32_t payloadSize,
            const void* payload, uint32_t barrier=0
        ) ;
        virtual CRingFragmentItem* makeRingFragmentItem(const CRingItem&amp; rhs) ;
    
        
        virtual CRingPhysicsEventCountItem* makePhysicsEventCountItem(
            uint64_t count, uint32_t timeoffset, time_t stamp,
            int divisor=1
        );
        virtual CRingPhysicsEventCountItem* makePhysicsEventCountItem(const CRingItem&amp; rhs);
        
        
        virtual CRingScalerItem* makeScalerItem(size_t numScalers);
        virtual CRingScalerItem* makeScalerItem(
            uint32_t startTime,
            uint32_t stopTime,
            time_t   timestamp,
            std::vector&lt;uint32_t&gt; scalers,
            bool                  isIncremental = true,
            uint32_t              sid = 0,
            uint32_t              timeOffsetDivisor = 1
        );
        virtual CRingScalerItem* makeScalerItem(const CRingItem&amp; rhs);
        
        
        virtual CRingTextItem* makeTextItem(
            uint16_t type,
            std::vector&lt;std::string&gt; theStrings
        );
        virtual CRingTextItem* makeTextItem(
            uint16_t type,
            std::vector&lt;std::string&gt; theStrings,
            uint32_t                 offsetTime,
            time_t                   timestamp, uint32_t divisor=1
        );
        virtual CRingTextItem* makeTextItem(const CRingItem&amp; rhs);
        
        
        virtual CUnknownFragment* makeUnknownFragment(
            uint64_t timestamp, uint32_t sourceid, uint32_t barrier,
            uint32_t size, void* pPayload
        );
        virtual CUnknownFragment* makeUnknownFragment(const CRingItem&amp; rhs);
        
        virtual CRingStateChangeItem* makeStateChangeItem(
            uint32_t itemType, uint32_t runNumber,
            uint32_t timeOffset,
            time_t   timestamp,
            std::string title
        );
        virtual CRingStateChangeItem* makeStateChangeItem(const CRingItem&amp; rhs);
    };
        

}             
                </programlisting>
            </refsynopsisdiv>
            <refsect1>
                     <title>DESCRIPTION</title>
                  <para>
                    <classname>v10::RingItemFactory</classname> is a factory class
                    that creates ring items for NSCLDAQ version 10.  The classes
                    in this format class hierarchy are all in the
                    <literal>v10</literal> namespace.   They derive directly
                    from the corresponding classes in the abstract format items
                    described in the previous section.
                  </para>
                  <para>
                    Note that this allows return values to be pointer to those
                    classes.
                  </para>
                  <para>
                    Since all items are dynamically created via <function>new</function>,
                    we recommend that you use these factory methods to initialize
                    smart pointers.  For example, if you read a ring item
                    from an event file you might have a code fragment that looks
                    like the following
                  </para>
                  <example>
                    <title>Using smart pointers with the v10 factory object</title>
                    <programlisting>
#include &lt;v10/RingItemFactory.h&gt;
#include &lt;v10/DataFormat.h&gt;
#include &lt;CRingItem.h&gt;                 <co id='v10fact.includes' />
#include &lt;CRingScalerItem.h&gt;
#include &lt;memory&gt;
#include &lt;fstream&gt;

...
std::ifstream in("run-0012-00.evt", ios::in | ios::binary); <co id='v10fact.open' />
...

v10::RingItemFactory fact;
std::unique_ptr&lt;CRingItem&gt; item(fact.getRingItem(in));  <co id='v10fact.read' />

if (item->type() == v10::INCREMENTAL_SCALERS ||
    item->type() == v10::TIMESTAMPED_NONINCR_SCALERS)) {
    std::unique_ptr&lt;CRingScalerItem&gt; scaler(fact.makeScalerItem(*item)); <co id='v10fact.make' />
    processScalers(scaler);                                <co id='v10fact.procscaler' />
}

...

                    </programlisting>
                  </example>
                  <calloutlist>
                    <callout arearefs='v10fact.includes' >
                        <para>
                            The headers we need include the data format header
                            which supplies the ring item types, the
                            factory the base <classname>CRingItem</classname>
                            and <classname>CRingScalerItem</classname>
                            definitions so that the compiler knows the
                            virtual method interfaces.
                        </para>
                        <para>
                            The file stream header and memory header are needed
                            to get data from the stream and to store pointers
                            into a smart pointer object to ensure the objects
                            we create get destroyed.
                        </para>
                    </callout>
                    <callout arearefs='v10fact.open' >
                        <para>
                            When opening a stream on an event file we must not only
                            specify we're going to read it but that we'll also
                            want the stream opened in binary mode to prevent any
                            character based translations that  otherwise might occur.
                        </para>
                    </callout>
                    <callout arearefs='v10fact.read' >
                        <para>
                            The factories provide a method to read a ring item
                            from a stream and wrap it with a <classname>CRingItem</classname>
                            base class.  This line does that and stores the pointer
                            to the resulting, dynamically created object in a
                            <classname>std::unique_ptr</classname> so that we don't
                            have to worry about deallocating the object later in
                            the code.
                        </para>
                    </callout>
                    <callout arearefs='v10fact.make' >
                        <para>
                            After determining that <varname>item</varname>
                            'points' to a scaler item, we use the
                            <methodname>makeScalerItem</methodname> factory
                            method to take a copy of the data and wrap it in a
                            version 10 scaler item.  The pointer to this is
                            also stored in a <classname>std::unique_ptr</classname>
                            object.
                        </para>
                    </callout>
                    <callout arearefs='v10fact.procscaler' >
                        <para>
                            The <function>processScaler</function> call just
                            represents some arbitrary processing.  While
                            <varname>item</varname> is valid after the
                            if block exits, the <classname>scaler</classname>
                            object is freed when that block exits so all
                            processing of the scaler must be done prior
                            to exiting that block.
                        </para>

                    </callout>
                  </calloutlist>
            </refsect1>
            <refsect1>
                <title>METHODS</title>
                <variablelist>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>::CRingItem* </type>
                          <methodname>makeRingItem</methodname>
                          <methodparam>
                              <type>uint16_t </type><parameter>type</parameter>
                          </methodparam>
                          <methodparam>
                              <type>size_t </type><parameter>maxBody</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Creates a new ring item that is undifferentiated,
                            that is it implements no type specific methods.
                            <parameter>type</parameter> is put in the ring item
                            header's type field.  Storage capacity sufficient for
                            a body of up to <parameter>maxBody</parameter>
                            bytes of data are reserved though you'll need to
                            communicate the size of the item (normally via
                            the object's <methodname>setBodyCursor</methodname>
                            and <methodname>updateSize</methodname> methods) to
                            actually fill in the header's size field.
                           </para>
                           <para>
                            The returned value is a pointer to a
                            <classname>v10::CRingItem</classname> object
                            (cast to <classname>::CRingItem</classname>).
                            The caller is responsible for deleting the object
                            when it is no longer needed (e.g. by initializing a smart
                            pointer object with it).
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>::CRingItem* </type>
                          <methodname>makeRingItem</methodname>
                          <methodparam>
                              <type>uint16_t </type><parameter>type</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint64_t </type><parameter>timestamp</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t </type><parameter>sourceId</parameter>
                          </methodparam>
                          <methodparam>
                              <type>size_t </type><parameter>maxBody</parameter>
                          </methodparam>
                          <methodparam>
                              <type>uint32_t</type><parameter> barrierType</parameter>
                              <initializer>0</initializer>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Creates an undifferentiateded ring item that is parameterized
                            for a body header.  Since version 10 does not support
                            body headers, the remaining parameters are silently
                            ignored.  This method, however allows the V10 factory
                            to be treated interchangeably with e.g. the V11
                            factory once it has been created.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>::CRingItem* </type>
                          <methodname>makeRingItem</methodname>
                          <methodparam>
                              <type>const ::CRingItem&amp; </type><parameter>rhs</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Makes a ring item by copying the contents of another
                            ring item.  Note that the results are not well defined
                            if the <parameter>rhs</parameter> item comes from
                            a different ring item format than this factory
                            (e.g. is a version 12 ring item).
                           </para>
                           <para>
                            In practice this is not a problem unless you are writing
                            a format converter.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>::CRingItem* </type>
                          <methodname>makeRingItem</methodname>
                          <methodparam>
                              <type>const RingItem* </type><parameter>pRawRing</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Wraps a raw ring item in a <classname>v10::CRingItem</classname>
                            object and returns a pointer to that object.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual CRingItem* </type>
                          <methodname>getRingItem</methodname>
                          <methodparam>
                              <type>CRingBuffer&amp;</type><parameter>ringbuf</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Reads a ring item from the ringbuffer
                            <parameter>ringbuf</parameter> and wraps it in a new
                            <type>v10::CRingBuffer</type>.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual CRingItem* </type>
                          <methodname>getRingItem</methodname>
                          <methodparam>
                              <type>int</type><parameter> fd</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Reads a ring item from the entity open on the linux
                            file descriptor <parameter>fd</parameter> and wraps it
                            into a new <type>v10::CRingBuffer</type>.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual CRingItem* </type>
                          <methodname>getRingItem</methodname>
                          <methodparam>
                              <type>std::istream&amp; </type><parameter>in</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Reads a ring item from the C++ <classname>istream</classname>
                            referenced by <parameter>in</parameter> and wraps it in a
                            <classname>v10::CRingItem</classname>.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><methodsynopsis>
                          <type>virtual std::ostream&amp;</type>
                          <methodname> putRingItem</methodname>
                          <methodparam>
                              <type>const CRingItem*</type><parameter> pItem</parameter>
                          </methodparam>
                          <methodparam>
                              <type>std::ostream&amp; </type><parameter>out</parameter>
                          </methodparam>
                       </methodsynopsis></term>
                       <listitem>
                           <para>
                            Puts the wrapped ring item pointed to by <parameter>pItem</parameter>
                            in the <classname>std::ostream</classname> referenced by <paramter>out</paramter>.
                            The raw binary of the ring item is output which allows it to be read in using
                             <methodname>getRingItem</methodname> at some later date.
                           </para>
                           <para>
                            The <parameter>out</parameter> stream must be open
                            for write and in binary mode.  Note any actual ring item
                            type can be used for the <paramter>pItem</paramter>
                            since they all ultimately descend from
                            <classname>::CRingItem</classname>.
                           </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </refsect1>
        </refentry>
       </section>
    </chapter>
</book>